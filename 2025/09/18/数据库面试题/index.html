<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL面试题 | NINGXIU's 学习博客</title><meta name="author" content="NINGXIU"><meta name="copyright" content="NINGXIU"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="07281.数据库的分类有哪些？（谈谈你知道的数据库？）分为关系型数据库(RDBMS)、非关系型数据库(NoSQL) 关系型数据库(RDBMS)，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 关系型数据库数据之间的关系性强，查询同类信息快，存储的数据结构可以很复杂。  常见的关系型数据库：mysql、oracle、db2、sql server  非关系型数据库(NoSQL)：Not">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL面试题">
<meta property="og:url" content="https://ningxiu2978.github.io/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="NINGXIU&#39;s 学习博客">
<meta property="og:description" content="07281.数据库的分类有哪些？（谈谈你知道的数据库？）分为关系型数据库(RDBMS)、非关系型数据库(NoSQL) 关系型数据库(RDBMS)，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 关系型数据库数据之间的关系性强，查询同类信息快，存储的数据结构可以很复杂。  常见的关系型数据库：mysql、oracle、db2、sql server  非关系型数据库(NoSQL)：Not">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ningxiu2978.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-18T13:18:22.257Z">
<meta property="article:modified_time" content="2025-09-18T13:19:31.787Z">
<meta property="article:author" content="NINGXIU">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ningxiu2978.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL面试题",
  "url": "https://ningxiu2978.github.io/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/",
  "image": "https://ningxiu2978.github.io/img/avatar.jpg",
  "datePublished": "2025-09-18T13:18:22.257Z",
  "dateModified": "2025-09-18T13:19:31.787Z",
  "author": [
    {
      "@type": "Person",
      "name": "NINGXIU",
      "url": "https://ningxiu2978.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ningxiu2978.github.io/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":-1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL面试题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://pic1.imgdb.cn/item/65578a9fc458853aef80544a.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">NINGXIU's 学习博客</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL面试题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-18T13:18:22.257Z" title="发表于 2025-09-18 21:18:22">2025-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-18T13:19:31.787Z" title="更新于 2025-09-18 21:19:31">2025-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="0728"><a href="#0728" class="headerlink" title="0728"></a><strong>0728</strong></h3><h4 id="1-数据库的分类有哪些？（谈谈你知道的数据库？）"><a href="#1-数据库的分类有哪些？（谈谈你知道的数据库？）" class="headerlink" title="1.数据库的分类有哪些？（谈谈你知道的数据库？）"></a>1.数据库的分类有哪些？（谈谈你知道的数据库？）</h4><p>分为关系型数据库(RDBMS)、非关系型数据库(NoSQL)</p>
<p><strong>关系型数据库</strong>(<strong>RDBMS</strong>)，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p>
<p>关系型数据库数据之间的关系性强，查询同类信息快，存储的数据结构可以很复杂。</p>
<ul>
<li>常见的关系型数据库：<strong>mysql、oracle、db2、sql server</strong></li>
</ul>
<p><strong>非关系型数据库</strong>(<strong>NoSQL</strong>)：Not-Only SQL ，泛指非关系型数据库，是对关系型数据库的补充。</p>
<p>非关系型数据库数据之间可以没有关系，结构简单更容易扩展，在大量数据的情况下，读写性能优秀</p>
<ul>
<li>常见的非关系型数据库：<strong>Redis、MongoDB</strong></li>
</ul>
<h4 id="2-sql的分类？（分别是做什么的、关键字？）"><a href="#2-sql的分类？（分别是做什么的、关键字？）" class="headerlink" title="2.sql的分类？（分别是做什么的、关键字？）"></a>2.<strong>sql的分类</strong>？（分别是做什么的、关键字？）</h4><p>sql是操作数据库的一种语言</p>
<p>DDL数据定义语言、DML数据操作语言、DQL数据查询语言、DCL数据控制语言</p>
<p><strong>DDL</strong>，操作数据库、表、列等，常用语句：<code>CREATE</code>、 <code>ALTER</code>、<code>DROP</code></p>
<p><strong>DML</strong>，操作数据库中<strong>表里的数据</strong>；常用语句：<code>INSERT</code>、 <code>UPDATE</code>、 <code>DELETE</code></p>
<p><strong>DQL</strong>，查询数据 常用语句：<code>SELECT</code></p>
<p><strong>DCL</strong>，操作访问权限和安全级别； 常用语句：<code>GRANT</code>(授权)、<code>revoke</code>(回收)、<code>commit</code>(提交)、<code>roolback</code>(回滚)</p>
<p>​	**TCL **是事务控制语言，用于控制处理事务。其常用关键字为<code>commit</code>、<code>rollback</code>。</p>
<h4 id="3-列举mysql常用的数据类型？（场景应用说明）"><a href="#3-列举mysql常用的数据类型？（场景应用说明）" class="headerlink" title="3.列举mysql常用的数据类型？（场景应用说明）"></a>3.列举mysql常用的数据类型？（场景应用说明）</h4><p><strong>整数类型：</strong></p>
<p><code>TINYINT</code>，适合<strong>存储状态值</strong>，如 0&#x2F;1 表示开关</p>
<p>​				<code>age TINYINT UNSIGNED</code>（适合存储 0-120 的年龄）</p>
<p>​			【使用 <code>UNSIGNED</code> 关键字可取消负数范围，使正数范围扩大一倍】</p>
<p><code>INT</code>，常用整数，适合<strong>用户id、数量</strong>等</p>
<p><code>BIGINT</code>，适合<strong>存储大数值</strong>，如<strong>订单号</strong></p>
<p><strong>浮点类型：</strong></p>
<p><code>FLOAT</code>，适合不需要极高精度的小数，例如产品评分</p>
<p><code>DOUBLE</code>，用于更精确的计算，如科学数据</p>
<p><code>DECIMAL(M,D)</code>，用于<strong>财务计算</strong>，如金额</p>
<p><strong>日期和时间类型：</strong></p>
<p><code>DATE</code>，存储日期，如生日</p>
<p><code>TIME</code>，存储时间（时分秒）</p>
<p><code>DATETIME</code>，存储日期和时间，如<strong>订单创建时间</strong></p>
<p><code>TIMESTAMP</code>，存储日期和时间，范围小，受时区影响，常用于<strong>记录最后修改时间</strong></p>
<p><code>YEAR</code>，存储年</p>
<p><strong>字符串类型：</strong></p>
<p><code>CHAR(M)</code>，<code>M</code> 为字符数（1-255），适合<strong>长度固定的数据</strong>（如<strong>密码哈希、身份证号、性别</strong>）</p>
<p><code>VARCHAR(M)</code>，<code>M</code> 为最大字符数（1-65,535），适合<strong>长度不固定的数据</strong>（如用户名、文章摘要）</p>
<p>文本类型<code>TEXT</code>，适合<strong>文章内容等大段文本</strong>（如文章内容、评论），不能有默认值。</p>
<p>二进制类型：<code>BLOB</code>，用于存储二进制数据（如图片、文件）</p>
<p>JSON 类型：<code>JSON</code>：存储 JSON 格式数据（对象或数组）</p>
<p>空间数据类型：</p>
<p><strong><code>GEOMETRY</code></strong>：存储几何对象（点、线、多边形等）。</p>
<p><strong><code>POINT</code></strong>、<strong><code>LINESTRING</code></strong>、<strong><code>POLYGON</code></strong> 等：特定几何类型。用于地理信息系统（GIS）应用</p>
<h4 id="4-说说drop，truncate，delete的作用和区别"><a href="#4-说说drop，truncate，delete的作用和区别" class="headerlink" title="4.说说drop，truncate，delete的作用和区别"></a>4.说说drop，truncate，delete的作用和区别</h4><p>（1）这个三个关键字都是<strong>删除</strong>的意思<br>（2）<strong>DROP</strong> 删除整个表（结构）<br>	  <strong>TRUNCATE</strong>： 清空表中的数据，包含主键自增列的数据（可以理解为：删除表，重新<strong>创建了一个新表</strong>）;<br>		<strong>DELETE</strong>: 不删除表结构，可以清空表数据，也可以<strong>根据条件</strong>删除指定的数据</p>
<p>（3）delete属于<strong>DML</strong>，会被事务管理，可以回滚，且表空间不会被释放；</p>
<p>​		drop和truncate都属于<strong>DDL</strong>，不被事务管理，不能回滚，但是表空间会被释放。</p>
<p>​	<strong>delete效率低、truncate效率高</strong></p>
<h4 id="5、写出DDL和DML语句中增删改的语法"><a href="#5、写出DDL和DML语句中增删改的语法" class="headerlink" title="5、写出DDL和DML语句中增删改的语法"></a>5、写出DDL和DML语句中增删改的语法</h4><h5 id="5-1-DDL"><a href="#5-1-DDL" class="headerlink" title="5.1 DDL"></a>5.1 DDL</h5><p>(1)创建表:	create table表名();<br>(2)修改表名:	alter tablel 旧表名 rename to 新表名;<br>(3)新增字段:	alter table 表名 add 字段名 字段类型;<br>(4)修改字段名:	alter table 表名 change 旧字段名 新字段名 类型;<br>(5)修改字段类型:	alter table 表名 modify 字段名 新类型;<br>(6)删除字段:	alter table 表名 drop 字段名;<br>(7) 删除表:	drop table 表名;</p>
<h5 id="5-2-DML"><a href="#5-2-DML" class="headerlink" title="5.2 DML"></a>5.2 DML</h5><p>(1)新增数据:	insert into 表名（字段1, 字段2..) values (值1,值2…);<br>(2)更新数据:	update 表名 set 字段名1&#x3D;值1, 字段名2&#x3D;值2, …[where条件];<br>(3)删除数据:	delete from 表名 [where条件];</p>
<h3 id="0729"><a href="#0729" class="headerlink" title="0729"></a><strong>0729</strong></h3><h4 id="1，sql-中如何给字段取别名，"><a href="#1，sql-中如何给字段取别名，" class="headerlink" title="1，sql 中如何给字段取别名，"></a>1，sql 中如何给字段取别名，</h4><h4 id="（有几种方式，分别在什么场景下使用？）"><a href="#（有几种方式，分别在什么场景下使用？）" class="headerlink" title="（有几种方式，分别在什么场景下使用？）"></a>（有几种方式，分别在什么场景下使用？）</h4><p>​	在 sql 语句中，使用 as 关键字 给<strong>表、字段、查询结果</strong>取别名</p>
<p>​	在简单的查询语句中，as 关键字可以省略不写，使语句更简洁</p>
<p>​	在复杂查询语句中，建议不要省略 as 关键字，这样可读性会更好</p>
<h4 id="2，distinct-关键字的作用是什么？（如何使用？需要注意什么）"><a href="#2，distinct-关键字的作用是什么？（如何使用？需要注意什么）" class="headerlink" title="2，distinct 关键字的作用是什么？（如何使用？需要注意什么）"></a>2，distinct 关键字的作用是什么？（如何使用？需要注意什么）</h4><p>​	1.distinct 关键字的作用是在查询中<strong>去除重复的数据</strong></p>
<p>​	2.该关键字使用在指定的字段前面</p>
<p>​	3.需要注意的是，使用 distinct 关键字的字段要紧跟在 <strong>select 关键字后面</strong></p>
<h4 id="3，where-子句种常见的运算符有哪些？"><a href="#3，where-子句种常见的运算符有哪些？" class="headerlink" title="3，where 子句种常见的运算符有哪些？"></a>3，where 子句种常见的运算符有哪些？</h4><p>​	1.where 子句是用来做条件筛选的</p>
<p>​	2.where 子句中可以使用的运算符包括：</p>
<ul>
<li><p>比较运算符，例如：&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &lt;&gt;, !&#x3D;</p>
</li>
<li><p>逻辑运算符，例如 and(并且运算)， or(或运算)， not(取反运算)</p>
</li>
<li><p>其它特殊的运算符：between(在指定区间取值)， in(符合一组数据中的一个即可)， is null(返回null数据)…</p>
</li>
<li><p><strong>比较运算符</strong>：&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &lt;&gt;, !&#x3D;</p>
</li>
<li><p><strong>逻辑运算符</strong>：AND, OR, NOT</p>
</li>
<li><p><strong>范围运算符</strong>：BETWEEN…AND…</p>
</li>
<li><p><strong>集合运算符</strong>：IN, NOT IN</p>
</li>
<li><p><strong>空值判断</strong>：IS NULL, IS NOT NULL</p>
</li>
<li><p><strong>模糊匹配</strong>：LIKE（<code>_</code>   <code>%</code>）, NOT LIKE</p>
<p><strong>注意</strong>：在 SQL中，NULL值与任何值的比较（包括!&#x3D;)都会返回UNKNOWN</p>
</li>
</ul>
<h4 id="4，like-模糊查询用法"><a href="#4，like-模糊查询用法" class="headerlink" title="4，like 模糊查询用法"></a>4，like 模糊查询用法</h4><ol>
<li>like 模糊查询中有两个关键的字符，分别是 <code>%</code>  和 <code>_</code></li>
<li>% 用来做<strong>模糊</strong>，可以匹配<strong>任意个字符</strong>；</li>
<li>如果我们想要<strong>精准匹配</strong>，可以使用 _, 一个 _ 匹配<strong>一个字符</strong><ul>
<li>例如：’a%’匹配所有以a开头的字符串，而’a_’只匹配两个字符且第一个字符为a的字符串。</li>
</ul>
</li>
<li>索引查询条件中like以 % 开头，索引会失效</li>
</ol>
<h4 id="5，列举聚合函数？说出每个聚合函数的作用"><a href="#5，列举聚合函数？说出每个聚合函数的作用" class="headerlink" title="5，列举聚合函数？说出每个聚合函数的作用"></a>5，列举聚合函数？说出每个聚合函数的作用</h4><p>常用的聚合函数有5个</p>
<ol>
<li>求最大值、最小值、求和、求平均值的聚合函数分别是：<code>MAX, MIN、SUM、AVG</code></li>
<li>统计记录数使用 count 函数，需要注意的是，在使用 count 时，如果使用的是 *， 也会统计出 null 值的数据行数量， 如果使用的是指定的字段名称，那么该字段位 null 数据行不会统计</li>
</ol>
<h4 id="6，having-和-where-的区别，使用场景？"><a href="#6，having-和-where-的区别，使用场景？" class="headerlink" title="6，having 和 where 的区别，使用场景？"></a>6，having 和 where 的区别，使用场景？</h4><p>(1) having 和 where 都是用来做<strong>条件筛选</strong>的</p>
<p>(2)不同的是:<br>where 是对<strong>所有的记录</strong>进行筛选， having 是对<strong>分组后</strong>的记录进行筛选；</p>
<p>where 不能放在 group by 子句后面</p>
<p>having 是固定和 group by 一起使用，放在 group by 后面，作用相当于 where</p>
<p><strong>where 后面不能使用聚合函数, having 可以</strong></p>
<h4 id="7，order-by-子句如何实现多字段排序；"><a href="#7，order-by-子句如何实现多字段排序；" class="headerlink" title="7，order by 子句如何实现多字段排序；"></a>7，order by 子句如何实现多字段排序；</h4><ul>
<li><code>desc</code> 降序</li>
<li><code>asc</code>  升序（<strong>默认值</strong>）</li>
</ul>
<p>使用<strong>逗号分隔</strong>多个排序字段，并可以为每个字段指定排序方向</p>
<h4 id="8、order-by-和-group-by-的区别"><a href="#8、order-by-和-group-by-的区别" class="headerlink" title="8、order by 和 group by 的区别"></a>8、order by 和 group by 的区别</h4><ol>
<li>这两个子句在 sql 语法中的作用不一样</li>
<li>order by 指的是 排序查询，可以根据一个字段或多个字段排序，默认 asc 升序，我们也可以指定降序排序，使用 desc 关键字</li>
<li>group by 的作用是分组查询，可以根据一个字段或多个字段进行分组查询，需要注意的是<strong>查询的结果</strong>只能是<strong>分组的列 和 聚合函数</strong>，可以使用 having 关键字筛选分组后的数据</li>
</ol>
<h4 id="9，mysql-中，limit-子句如何实现分页查询？谈谈它的参数的作用"><a href="#9，mysql-中，limit-子句如何实现分页查询？谈谈它的参数的作用" class="headerlink" title="9，mysql 中，limit 子句如何实现分页查询？谈谈它的参数的作用"></a>9，mysql 中，limit 子句如何实现分页查询？谈谈它的参数的作用</h4><p>1.在mysql中使用 <code>limit</code> 关键字实现分页查询</p>
<p>2.limit 关键字后面可以跟 <strong>2个参数</strong>，第一个参数表示 <strong>起始的索引值</strong>，第二个参数表示查询的<strong>每页记录数</strong></p>
<p>3.limit 后面也可以<strong>只跟一个参数</strong>，此时该参数指的是所有记录中的<strong>前n条记录</strong>（也可以理解位第一页的数据）；</p>
<p>4.**mysql 8.0 **以后新增了一个分页语法，是 <strong>limit 记录数 offset 起始索引</strong></p>
<h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><h4 id="1、sql-中如何处理-null-值"><a href="#1、sql-中如何处理-null-值" class="headerlink" title="1、sql 中如何处理 null 值"></a>1、sql 中如何处理 null 值</h4><blockquote>
<ol>
<li><p>在sql 中我们可以使用 <strong>coalesce</strong> 函数 和 <strong>ifnull</strong> 函数</p>
</li>
<li><p>这两个函数都可以接收<strong>两个参数</strong>，第一个参数不为 null，返回第一个参数，为 null 则返回第二个参数</p>
</li>
</ol>
</blockquote>
<h4 id="2、说说-if-和-case-函数的用法"><a href="#2、说说-if-和-case-函数的用法" class="headerlink" title="2、说说 if 和 case 函数的用法"></a>2、说说 if 和 case 函数的用法</h4><ol>
<li>这两个都是<strong>流程控制函数</strong></li>
<li><code>if</code> 函数接收三个参数，第一个参数是<strong>表达式</strong>，如果表达成立，则该函数返回第二个参数值，如果不成立则返回第三个参数值（类似于java中的三元表达式）  </li>
<li><code>case</code> 函数有两种用法<ul>
<li>第一种用于<strong>条件匹配</strong>，在 when 关键字后面指定条件，如果条件成立，则返回当前then的结果</li>
<li>第二种用于<strong>精准匹配</strong>，这个时候是在 case 后面指定要匹配的值，和 when 后面的值进行比较，如果匹配上了，则返回当前then的结果</li>
<li>这两种用法中，如果不满足条件 或者 精准匹配，都是返回 <strong>esle</strong> 后面的结果</li>
</ul>
</li>
<li>需要注意的是：要使用 <strong>end</strong> 关键字来结束 case 语法</li>
</ol>
<h4 id="3、列举常用的函数"><a href="#3、列举常用的函数" class="headerlink" title="3、列举常用的函数"></a>3、列举常用的函数</h4><ol>
<li>5个聚合函数 </li>
<li>null值处理函数：COALESCE()  和 ifnull()</li>
<li>数学函数：ceil(),floor(),  RAND(),  TRUNCATE()</li>
<li>字符串函数：trim(), substring(), concat(), lower(), UPPER()</li>
<li>日期函数：CURRENT_DATE(),CURRENT_TIME() NOW(), TIMESTAMPDIFF()</li>
<li>流程控制函数： if()</li>
</ol>
<h3 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h3><h4 id="1-MySQL中如何设置主键自增"><a href="#1-MySQL中如何设置主键自增" class="headerlink" title="1.MySQL中如何设置主键自增?"></a>1.MySQL中如何设置<strong>主键自增</strong>?</h4><p>MySQL中通过将关键字 <code>auto_increment</code>添加到要自增的字段声明上设置主键自增。<br>其设置<code>auto_increment</code>有以下条件：<br>	1.字段要求具有<strong>索引</strong>，一般我们是给主键添加，而主键具有<strong>主键索引</strong>；<br>	2.要求字段的类型必须是<strong>数字类型</strong>，包括整数和浮点数；<br>	3.在一张表中只能有<strong>一个主键自增列</strong>存在。</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="2-数据库的约束有哪些"><a href="#2-数据库的约束有哪些" class="headerlink" title="2.数据库的约束有哪些?"></a>2.数据库的约束有哪些?</h4><p>​	1、<strong>概念</strong>：约束是作用于作用域中字段上的规则，用于限制存储在表中的数据<br><strong>目的</strong>：保证数据库中数据的正确，有效性和完整性</p>
<p>​	2、约束的分类</p>
<p>数据库中常见的约束有6个</p>
<p>(1) <strong>主键约束</strong>(<code>primary key</code>):当前字段是数据的唯一标识符，<strong>唯一且不能为空</strong>，例如：表中 id 字段<br>(2) <strong>外键约束</strong>(<code>foreign key</code>): 用来让两张表的数据之间<strong>建立连接</strong>，保证数据的一致性和完整性(当前表的外键是<strong>一般是</strong>另一张表的主键)，例如：员工表中设置 部门编号为 外键，可以关联部门表<br>(3) <strong>非空约束(</strong><code>not null</code>): 限制当前字段的数据<strong>不能为null</strong>，例如：给员工 姓名字段添加非空约束，姓名不能为空<br>(4) <strong>唯一约束</strong>(<code>unique</code>): 保证该字段的所有数据都是<strong>唯一、不重复，可以为null</strong>，例如：给员工 身份证号码添加唯一约束<br>(5) <strong>检查约束</strong>(<code>check</code>): 保证字段的值满足某一个条件(男&#x2F;女)，或者某个区间，例如：性别 字段 设置检查约束，限制当前字段 只能输入‘男’或 ‘女’<br>(6) <strong>默认值约束</strong>(<code>default</code>): 保存数据时,如果没有指定该字段的值,则采用默认值(入职时间,岗位)，例如：员工 岗位 字段，插入字段时 不指定字段，默认为 ‘员工’</p>
<h3 id="内外连接"><a href="#内外连接" class="headerlink" title="内外连接"></a>内外连接</h3><h4 id="3-内连接、外连接的区别有哪些"><a href="#3-内连接、外连接的区别有哪些" class="headerlink" title="3.内连接、外连接的区别有哪些?"></a><strong>3.内连接、外连接的区别有哪些?</strong></h4><p>(1)内连接和外连接都是用来<strong>多表查询</strong>的；</p>
<p>(2)内连接使用 <strong>INNER JOIN</strong> 实现 ，外连接 使用 <strong>LEFT JOIN</strong> 或者 <strong>RIGHT JOIN</strong> 实现；</p>
<p>(3)<strong>内连接</strong>是返回满足所有条件的数据行，</p>
<p>而<strong>外连接</strong>是返回主表的所有数据和副表中满足条件的数据行，不满足条件的使用<strong>null填充</strong></p>
<p><strong>使用场景：</strong></p>
<p>查询所有的员工信息和员工的部门信息，使用<strong>外连接</strong>，查询所有的员工，包括没有部门的员工信息</p>
<p>查询所有 <strong>有部门</strong>的员工信息，应该使用<strong>内连接</strong>，只返回有部门的员工信息</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="1、什么是视图，说一说视图的作用？"><a href="#1、什么是视图，说一说视图的作用？" class="headerlink" title="1、什么是视图，说一说视图的作用？"></a>1、什么是视图，说一说视图的作用？</h4><ul>
<li><p>视图是由查询语句定义的<strong>虚拟表</strong>（基于SQL查询语句的结果集生成的一张虚拟表），本身不存储数据（只存储查询的定义），数据来源于表，使用 <code>view</code> 关键字创建</p>
<p><strong>作用</strong>：</p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>简化复杂查询</strong>：<strong>封装</strong>常用的查询逻辑，使SQL更易理解和维护</li>
<li><strong>数据安全</strong>：通过视图控制用户对敏感数据的访问权限</li>
<li><strong>逻辑隔离</strong>：<ul>
<li>通过基表创建的多个视图，逻辑是相互隔离</li>
<li>屏蔽底层表结构变化，提供统一的数据接口</li>
</ul>
</li>
</ul>
</blockquote>
<p>总的来说，视图可以简化复杂查询，增强数据的安全性和逻辑性</p>
<h4 id="2-通过视图更新基表要满足什么条件？"><a href="#2-通过视图更新基表要满足什么条件？" class="headerlink" title="2.通过视图更新基表要满足什么条件？"></a>2.通过视图更新基表要满足什么条件？</h4><ul>
<li>视图定义中只包含<strong>一个基表</strong></li>
<li>视图中包含基表的<strong>主键或唯一键</strong></li>
<li>视图中没有包含<strong>聚合函数</strong>(如SUM, AVG, COUNT等)</li>
<li>视图中没有包含<strong>DISTINCT</strong>关键字</li>
<li>视图的定义中不能包含<strong>表达式</strong>或者<strong>子查询</strong></li>
</ul>
<h4 id="3、视图和表的区别是什么"><a href="#3、视图和表的区别是什么" class="headerlink" title="3、视图和表的区别是什么"></a>3、视图和表的区别是什么</h4><blockquote>
<ol>
<li>存储方式：视图是虚拟表，不存储数据，基表是存储实际数据的；</li>
<li>空间占用：视图仅仅占用定义的空间，表占用物理存储空间；</li>
<li>更新操作：视图更新基表有限制，表可以直接更新</li>
</ol>
</blockquote>
<h4 id="4、查询视图和查询基表，谁的效率高，为什么？"><a href="#4、查询视图和查询基表，谁的效率高，为什么？" class="headerlink" title="4、查询视图和查询基表，谁的效率高，为什么？"></a>4、查询视图和查询基表，谁的效率高，为什么？</h4><blockquote>
<p>查询基表的效率高，<br>视图相当于一个中间商，查询视图，本质是通过是视图查询基表，效率没有直接查询基表的效率高</p>
<p>因为视图不存储数据，每次查询视图时，都需要执行视图定义中的 select 语句，动态生成结果，而直接查询基表可以直接读取存储的数据，减少计算开销。</p>
</blockquote>
<h4 id="5、哪些情况下，视图无法直接执行-INSERT、UPDATE-或-DELETE-操作？至少列举-3-种"><a href="#5、哪些情况下，视图无法直接执行-INSERT、UPDATE-或-DELETE-操作？至少列举-3-种" class="headerlink" title="5、哪些情况下，视图无法直接执行 INSERT、UPDATE 或 DELETE 操作？至少列举 3 种"></a>5、哪些情况下，视图无法直接执行 INSERT、UPDATE 或 DELETE 操作？至少列举 3 种</h4><blockquote>
<ol>
<li>视图定义中使用了 distinct 或者 聚合函数</li>
<li>视图的查询中使用了多表连接（join）</li>
<li>视图的定义中，字段包含表达式计算（ 例如 sal*1.2）</li>
</ol>
</blockquote>
<h4 id="6、某电商系统需要频繁查询-“近-30-天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？"><a href="#6、某电商系统需要频繁查询-“近-30-天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？" class="headerlink" title="6、某电商系统需要频繁查询 “近 30 天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？"></a>6、某电商系统需要频繁查询 “近 30 天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？</h4><blockquote>
<p>适合<br>原因：使用视图的目的是为了简化查询语句<br>当前的业务中：近 30 天已付款 的查询条件是固定的，查询 订单及对应商品名称 也是固定，也就是说这个复杂查询的sql语句不会变化，所以适合使用 视图 来优化</p>
</blockquote>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="1-什么是存储过程？存储过程优缺点？"><a href="#1-什么是存储过程？存储过程优缺点？" class="headerlink" title="1.什么是存储过程？存储过程优缺点？"></a>1.什么是存储过程？存储过程优缺点？</h4><ul>
<li>存储过程是一组<strong>预先编译</strong>好的<strong>SQL语句集合</strong></li>
<li>存储在数据库<strong>服务器</strong>中，由客户端通过名称和参数<strong>重复调用</strong>执行</li>
<li>可以接收参数、执行特定操作并返回结果</li>
<li>使用BEGIN…END构造来包含多条语句</li>
</ul>
<blockquote>
<ul>
<li><p><strong>优点</strong></p>
</li>
<li><p>(1)存储过程是<strong>预编译</strong>的代码块**，执行效率高**<br>(2)存储过程在<strong>服务器端运行</strong>，减少客户端压力<br>(3)存储过程只需要<strong>创建一次</strong>，可以<strong>重复使用</strong><br>(4)存储过程代替大量的SQL语句，提高通信速率<br>(5)可以一定程度上<strong>确保数据安全</strong></p>
</li>
<li><p>事务处理：可以在存储过程中进行完整的事务控制</p>
<p><strong>缺点</strong></p>
<ul>
<li><strong>不同数据库的存储过程语法不同，可移植性差</strong></li>
<li><strong>调试和维护较困难</strong></li>
<li>占用数据库资源较多</li>
<li>对数据库服务器产生一定负担</li>
</ul>
</li>
<li><p>不适合处理大量的文本和图像数据</p>
</li>
</ul>
</blockquote>
<h4 id="2-说一下存储过程的参数"><a href="#2-说一下存储过程的参数" class="headerlink" title="2.说一下存储过程的参数"></a>2.说一下存储过程的参数</h4><blockquote>
<ul>
<li>IN参数：输入参数，在存储过程中值不会被修改</li>
<li>OUT参数：输出参数，在存储过程中赋值后返回给调用者（可以重新赋值，在调用存储过程时可以获取该结果）</li>
<li>INOUT参数：既是入参，也是出参，具备入参和出参的特点，调用时提供值并能被修改后返回</li>
</ul>
</blockquote>
<h4 id="4-说一说系统变量、用户变量和局部变量的作用"><a href="#4-说一说系统变量、用户变量和局部变量的作用" class="headerlink" title="4.说一说系统变量、用户变量和局部变量的作用"></a>4.说一说系统变量、用户变量和局部变量的作用</h4><blockquote>
<ol>
<li>系统变量：是控制数据库特定行为的参数，这些变量可以被设置为特定的值来改变服务器的默认设置，比如说 autocommit，这个系统变量可以设置提交事务的行为</li>
<li>用户变量和局部变量 可以用来保存一些临时数据，例如 在 存储过程中声明局部变量，接收 sql 操作的结果</li>
</ol>
</blockquote>
<h4 id="5、创建存储过程时，BEGIN-END块的作用是什么？如果存储过程只有一条-SQL-语句，是否可以省略？"><a href="#5、创建存储过程时，BEGIN-END块的作用是什么？如果存储过程只有一条-SQL-语句，是否可以省略？" class="headerlink" title="5、创建存储过程时，BEGIN...END块的作用是什么？如果存储过程只有一条 SQL 语句，是否可以省略？"></a>5、创建存储过程时，<code>BEGIN...END</code>块的作用是什么？如果存储过程只有一条 SQL 语句，是否可以省略？</h4><blockquote>
<p>BEGIN…END 块的作用是包裹多条 sql 语句或者复杂的业务逻辑<br>可以省略</p>
</blockquote>
<h4 id="6、-调用存储过程使用什么语句？若存储过程有-OUT-参数，如何获取其返回值？"><a href="#6、-调用存储过程使用什么语句？若存储过程有-OUT-参数，如何获取其返回值？" class="headerlink" title="6、 调用存储过程使用什么语句？若存储过程有 OUT 参数，如何获取其返回值？"></a>6、 调用存储过程使用什么语句？若存储过程有 OUT 参数，如何获取其返回值？</h4><blockquote>
<p>使用 call 存储过程名称来调用</p>
<p>我们可以在存储过程外面声明一个用户变量，在调用 存储过程是，使用该变量接收 out 参数</p>
</blockquote>
<h4 id="7、MySQL-中能否直接修改存储过程的逻辑（如-SQL-语句）？若不能，如何实现-“修改”-效果？"><a href="#7、MySQL-中能否直接修改存储过程的逻辑（如-SQL-语句）？若不能，如何实现-“修改”-效果？" class="headerlink" title="7、MySQL 中能否直接修改存储过程的逻辑（如 SQL 语句）？若不能，如何实现 “修改” 效果？"></a>7、MySQL 中能否直接修改存储过程的逻辑（如 SQL 语句）？若不能，如何实现 “修改” 效果？</h4><blockquote>
<p>在 8.0.16 版本之前使用 drop，create 重新创建来修改 存储过程的逻辑</p>
<p>在 8.0.16 版本之后可以使用 alter 关键字修改 存储过程的逻辑，语法和创建的语法类似</p>
</blockquote>
<h4 id="8、-为什么说存储过程可能增加数据库维护成本？请举例说明。"><a href="#8、-为什么说存储过程可能增加数据库维护成本？请举例说明。" class="headerlink" title="8、 为什么说存储过程可能增加数据库维护成本？请举例说明。"></a>8、 为什么说存储过程可能增加数据库维护成本？请举例说明。</h4><blockquote>
<p>可移植性不高，切换数据库，那么存储过程的语法可能需要重写<br>逻辑复杂不易维护</p>
</blockquote>
<h4 id="9、某系统需要-“根据用户-ID-批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？"><a href="#9、某系统需要-“根据用户-ID-批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？" class="headerlink" title="9、某系统需要 “根据用户 ID 批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？"></a>9、某系统需要 “根据用户 ID 批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？</h4><blockquote>
<p>适合<br>使用存储过程的目的是为了简化操作逻辑，提升执行效率，在当前的业务中<br>删除的逻辑复杂，且逻辑是一致的不会变化，所以适合使用存储过程</p>
</blockquote>
<h4 id="10、-存储过程中能否使用事务控制语句（如BEGIN-TRANSACTION、COMMIT）？请说明原因"><a href="#10、-存储过程中能否使用事务控制语句（如BEGIN-TRANSACTION、COMMIT）？请说明原因" class="headerlink" title="10、 存储过程中能否使用事务控制语句（如BEGIN TRANSACTION、COMMIT）？请说明原因"></a>10、 存储过程中能否使用事务控制语句（如<code>BEGIN TRANSACTION</code>、<code>COMMIT</code>）？请说明原因</h4><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="1-什么是游标，说说它的作用"><a href="#1-什么是游标，说说它的作用" class="headerlink" title="1. 什么是游标，说说它的作用"></a>1. 什么是游标，说说它的作用</h4><ul>
<li>游标是数据库中用于<strong>逐行遍历查询结果集</strong>的数据库对象，可以在存储过程和存储函数中声明使用，声明游标的关键字是 <code>cursor</code></li>
<li>游标相当于一个集合，<strong>保存查询出来的一组数据，可以逐行遍历</strong></li>
</ul>
<p>游标的主要<strong>作用</strong>：</p>
<blockquote>
<p>逐行处理查询结果集</p>
<p>对每一行数据进行单独的操作和处理</p>
<p>在存储过程中实现复杂的逻辑控制</p>
<p>处理需要循环操作的业务场景</p>
</blockquote>
<h4 id="2-游标和普通-select-查询的核心区别"><a href="#2-游标和普通-select-查询的核心区别" class="headerlink" title="2. 游标和普通 select 查询的核心区别"></a>2. 游标和普通 select 查询的核心区别</h4><p><strong>普通 SELECT 查询</strong>：一次性返回所有符合条件的记录(依从性返回所有结果集)，适合批量数据处理</p>
<p><strong>游标查询</strong>：游标允许逐行访问结果集，适合需要对每行数据进行单独处理的场景,支持循环控制流程</p>
<h4 id="3-使用游标的步骤"><a href="#3-使用游标的步骤" class="headerlink" title="3. 使用游标的步骤"></a>3. 使用游标的步骤</h4><ul>
<li>声明游标：定义游标关联的查询结果集(declare 游标名称 cursor for 查询语句);</li>
<li>声明 not found 异常处理器：标记循环遍历游标结束的条件；</li>
<li>打开游标：open 游标名称</li>
<li>获取数据：fetch 游标名称 into 变量</li>
<li>关闭游标：close 游标名称</li>
</ul>
<h4 id="4-什么场景适合使用游标，什么场景不适合？"><a href="#4-什么场景适合使用游标，什么场景不适合？" class="headerlink" title="4. 什么场景适合使用游标，什么场景不适合？"></a>4. 什么场景适合使用游标，什么场景不适合？</h4><p>适合使用游标的<strong>场景</strong>：</p>
<p>需要逐行处理结果集（例如：批量更新员工的部门，又比如根据条件修改员工的工资）</p>
<blockquote>
<p>需要对每行数据进行不同的复杂处理逻辑</p>
<p>需要根据当前行数据决定后续操作</p>
<p>处理数据量较小且需要精细控制的场景</p>
</blockquote>
<p>不适合使用游标的场景：</p>
<p>结果集太大不合适使用游标（游标加载全部数据到内存，效率低），可以通过 update&#x2F;delete直接操作表</p>
<blockquote>
<p>简单的批量数据操作（用 UPDATE、DELETE 等更高效）</p>
<p>大数据量处理（性能较差）</p>
<p>只需要统计或聚合操作的场景</p>
</blockquote>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="5-MySQL-中3种常见异常"><a href="#5-MySQL-中3种常见异常" class="headerlink" title="5. MySQL 中3种常见异常"></a>5. MySQL 中3种常见异常</h4><ul>
<li>主键冲突： sqlstate ‘23000’， 错误码 1062;</li>
<li>除零异常： sqlstate ‘22012’, 错误码 1365;</li>
<li>数据类型不匹配异常： sqlstate ‘22005’， 错误码 1366;</li>
<li>游标遍历结束：not found</li>
</ul>
<h4 id="6-MySQL-中异常处理的两种方式"><a href="#6-MySQL-中异常处理的两种方式" class="headerlink" title="6. MySQL 中异常处理的两种方式"></a>6. MySQL 中异常处理的两种方式</h4><p><strong>EXIT</strong> 方式：</p>
<ul>
<li>捕获异常后，退出当前存储过程，适用于严重的错误，例如：<strong>主键冲突，事务失败</strong></li>
</ul>
<blockquote>
<p>遇到异常时立即退出当前执行块</p>
<p>适用于严重错误，需要立即终止程序执行的场景</p>
<p>保证数据的完整性和一致性</p>
</blockquote>
<p><strong>CONTINUE</strong> 方式：</p>
<ul>
<li>捕获异常后，继续执行过程，适用于不影响后续逻辑的轻微错误，例如：<strong>游标结束</strong></li>
</ul>
<blockquote>
<p>遇到异常时记录错误但继续执行后续代码</p>
<p>适用于可容忍的错误，希望程序继续运行的场景</p>
<p>用于批量处理中部分数据出错但不影响整体流程的情况</p>
</blockquote>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><h4 id="存储函数和存储过程的区别"><a href="#存储函数和存储过程的区别" class="headerlink" title="存储函数和存储过程的区别?"></a><strong>存储函数和存储过程的区别?</strong></h4><ul>
<li>1.声明的<strong>关键字</strong>不一样：存储过程使用 <code>procedure</code>，函数使用 <code>function</code></li>
<li>2**.参数类型**支持不一样：存储过程支持 IN\OUT\INOUT参数类型，函数仅支持 IN类型参数</li>
<li>3.<strong>返回结果</strong>的处理方式不一样：存储过程可以通过<br>OUT参数返回结果，或者不返回结果，函数必须返回结果，使用 return 关键字</li>
<li>4.<strong>调用方式</strong>：存储过程通过 call 语句调用，函数可以直接嵌套在 sql 语句中</li>
<li>5.<strong>事务支持不一样</strong>：存储过程完全支持事务，函数支持事务但是有限制(不推荐在函数中使用事务)</li>
</ul>
<h4 id="1、什么是存储函数？其核心特征是什么？"><a href="#1、什么是存储函数？其核心特征是什么？" class="headerlink" title="1、什么是存储函数？其核心特征是什么？"></a>1、什么是存储函数？其核心特征是什么？</h4><p>存储函数是预编译并存储在数据库中的SQL程序，必须返回一个值，可嵌入SQL语句（如<code>SELECT</code>）中调用，用于实现特定计算或查询逻辑。</p>
<p><strong>核心特征</strong>：<strong>强制返回值</strong>、仅支持<code>IN</code>参数、可嵌入SQL。</p>
<h4 id="存储函数特性选项说明："><a href="#存储函数特性选项说明：" class="headerlink" title="存储函数特性选项说明："></a>存储函数<strong>特性选项</strong>说明：</h4><p>标明特性的目的是：告诉数据库引擎，优化函数的执行效率<br>取值如下：<br>（1）<strong>DETERMINISTIC</strong> ：输入相同的参数时，返回的结果时固定的，多次调用，直接复用结果，有助于优化器提速；<br><strong>确定性函数</strong>：是指每次调用函数时，传同一个参数，返回值是固定的<br>如果 传递一个参数 返回值是固定的<br>第一次调用时会执行函数，计算出结果并缓存；之后每次调用则使用缓存的结果，不需要再次执行函数过程，提升执行效率<br>（2）<strong>SQL DATA ACCESS</strong> ：声明的函数对数据的操作类型<br>   <strong>no sql</strong> ：无数据操作<br>   <strong>reads sql data</strong> ：仅读数据<br>   <strong>modifies sql data</strong> ：修改数据</p>
<h4 id="2、存储函数为什么必须有返回值？如何指定返回值类型？"><a href="#2、存储函数为什么必须有返回值？如何指定返回值类型？" class="headerlink" title="2、存储函数为什么必须有返回值？如何指定返回值类型？"></a>2、存储函数为什么必须有返回值？如何指定返回值类型？</h4><p>存储函数本质是“计算工具”，需像数学函数（<code>f(x)=y</code>）一样输出结果，因此必须通过<code>RETURN</code>语句返回值。通过<code>CREATE FUNCTION</code>中的<code>RETURNS 数据类型</code>（如<code>RETURNS INT</code>）指定返回值类型。</p>
<h4 id="3、存储函数与存储过程在参数类型上有何区别？"><a href="#3、存储函数与存储过程在参数类型上有何区别？" class="headerlink" title="3、存储函数与存储过程在参数类型上有何区别？"></a>3、存储函数与存储过程在参数类型上有何区别？</h4><p>存储函数仅支持<code>IN</code>类型参数（输入参数，默认隐含）；存储过程支持<code>IN</code>（输入）、<code>OUT</code>（输出）、<code>INOUT</code>（双向）三种参数类型。</p>
<h4 id="4、存储函数能否直接返回结果集？（如SELECT-FROM-表）？为什么？"><a href="#4、存储函数能否直接返回结果集？（如SELECT-FROM-表）？为什么？" class="headerlink" title="4、存储函数能否直接返回结果集？（如SELECT * FROM 表）？为什么？"></a>4、存储函数能否直接返回结果集？（如<code>SELECT * FROM 表</code>）？为什么？</h4><p>不能。存储函数中的<code>SELECT</code>语句必须通过<code>INTO</code>子句将结果存入变量（如<code>SELECT name INTO var FROM users</code>），无法直接返回结果集；存储过程则可直接返回结果集。</p>
<h4 id="5、什么场景适合使用存储函数？举一个实际业务例子。"><a href="#5、什么场景适合使用存储函数？举一个实际业务例子。" class="headerlink" title="5、什么场景适合使用存储函数？举一个实际业务例子。"></a>5、什么场景适合使用存储函数？举一个实际业务例子。</h4><p>适合<strong>计算型场景</strong>，适合简单计算、数据转换或单行查询结果处理，如<strong>数学运算、格式转换、业务规则计算</strong></p>
<p>例子：计算员工年终奖金的函数，根据工龄和绩效返回奖金金额</p>
<p>例如：创建<code>calc_age(birth_date DATE)</code>函数，根据出生日期计算年龄，可直接在<code>SELECT</code>中调用（<code>SELECT name, calc_age(birth) FROM users</code>）。</p>
<h4 id="6、存储函数中如何主动抛出异常？请写出核心代码。"><a href="#6、存储函数中如何主动抛出异常？请写出核心代码。" class="headerlink" title="6、存储函数中如何主动抛出异常？请写出核心代码。"></a>6、存储函数中如何<strong>主动抛出异常</strong>？请写出核心代码。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;自定义错误信息&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>SIGNAL</code>语句。例如：参数非法时抛异常：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF price <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">  SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> </span><br><span class="line">  <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;价格不能为负数&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>



<h4 id="7、创建存储函数时，DETERMINISTIC特性的作用是什么？默认值是什么？"><a href="#7、创建存储函数时，DETERMINISTIC特性的作用是什么？默认值是什么？" class="headerlink" title="7、创建存储函数时，DETERMINISTIC特性的作用是什么？默认值是什么？"></a>7、创建存储函数时，<code>DETERMINISTIC</code>特性的作用是什么？默认值是什么？</h4><p>DETERMINISTIC表示函数输入相同参数时返回结果固定（如数学计算），帮助优化器缓存结果提升效率。</p>
<p>默认值是<code>NOT DETERMINISTIC</code>（非确定性）</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h3><h4 id="1、什么是触发器？其“自动触发”的核心条件是什么？"><a href="#1、什么是触发器？其“自动触发”的核心条件是什么？" class="headerlink" title="1、什么是触发器？其“自动触发”的核心条件是什么？"></a>1、什么是触发器？其“自动触发”的核心条件是什么？</h4><p>触发器是<strong>与表关联</strong>的特殊程序，当表发生<code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>操作时自动执行。</p>
<p><strong>核心条件</strong>：关联表发生指定触发事件（如<code>INSERT</code>），且满足触发时机（<code>BEFORE</code>&#x2F;<code>AFTER</code>）。</p>
<h4 id="2、触发器的BEFORE和AFTER触发时机有何本质区别？分别适用于什么场景？"><a href="#2、触发器的BEFORE和AFTER触发时机有何本质区别？分别适用于什么场景？" class="headerlink" title="2、触发器的BEFORE和AFTER触发时机有何本质区别？分别适用于什么场景？"></a><strong>2、触发器的<code>BEFORE</code>和<code>AFTER</code>触发时机有何本质区别？分别适用于什么场景？</strong></h4><p><code>BEFORE</code>在操作执行前触发，可修改即将插入&#x2F;更新的数据（如<strong>校验</strong>、自动计算字段）；<br>例如在插入员工数据之前，检验是否允许插入；</p>
<p><code>AFTER</code>在操作执行后触发，适合<strong>记录日志、同步数据</strong>（无法修改已提交数据）。<br>例如在插入员工后，记录日志。</p>
<h4 id="3、触发器中NEW和OLD关键字的作用是什么？分别在哪些触发事件中可用"><a href="#3、触发器中NEW和OLD关键字的作用是什么？分别在哪些触发事件中可用" class="headerlink" title="3、触发器中NEW和OLD关键字的作用是什么？分别在哪些触发事件中可用"></a>3、触发器中<code>NEW</code>和<code>OLD</code>关键字的作用是什么？分别在哪些触发事件中可用</h4><p><code>NEW.字段</code>引用插入&#x2F;更新后的新值（<code>INSERT</code>&#x2F;<code>UPDATE</code>可用）；</p>
<p><code>OLD.字段</code>引用更新&#x2F;删除前的旧值（<code>UPDATE</code>&#x2F;<code>DELETE</code>可用）。</p>
<p>例如：<code>UPDATE</code>触发器中，<code>OLD.price</code>是旧价格，<code>NEW.price</code>是新价格。</p>
<h4 id="4、触发器能否修改自身关联表的数据？为什么？"><a href="#4、触发器能否修改自身关联表的数据？为什么？" class="headerlink" title="4、触发器能否修改自身关联表的数据？为什么？"></a>4、触发器能否修改自身关联表的数据？为什么？</h4><p>不建议。若触发器中修改自身关联表（如<code>UPDATE</code>触发器又<code>UPDATE</code>同表），可能导致递归触发（无限循环执行），引发性能问题或数据异常。</p>
<h4 id="5、什么场景适合使用触发器？举一个实际业务例子。"><a href="#5、什么场景适合使用触发器？举一个实际业务例子。" class="headerlink" title="5、什么场景适合使用触发器？举一个实际业务例子。"></a>5、什么场景适合使用触发器？举一个实际业务例子。</h4><p>适合<strong>自动维护数据一致性、记录变更日志。如审计日志、数据同步</strong></p>
<p>例如：创建<code>AFTER UPDATE</code>触发器，当<code>products</code>表价格修改时，自动向<code>price_logs</code>表插入旧价格、新价格和修改时间。</p>
<h4 id="6、触发器与存储过程的核心区别是什么？"><a href="#6、触发器与存储过程的核心区别是什么？" class="headerlink" title="6、触发器与存储过程的核心区别是什么？"></a>6、触发器与存储过程的核心区别是什么？</h4><p>触发器是“事件驱动自动执行”，无需手动调用，依附于表的操作；</p>
<p>存储过程是“手动调用执行”，可独立存在，不依赖表事件。</p>
<h4 id="7、如何查看某张表关联的所有触发器？"><a href="#7、如何查看某张表关联的所有触发器？" class="headerlink" title="7、如何查看某张表关联的所有触发器？"></a>7、如何查看某张表关联的所有触发器？</h4><p>通过系统表查询：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS </span><br><span class="line"><span class="keyword">WHERE</span> EVENT_OBJECT_TABLE <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="定时任务（MySQL事件）"><a href="#定时任务（MySQL事件）" class="headerlink" title="定时任务（MySQL事件）"></a><strong>定时任务（MySQL事件）</strong></h3><h4 id="1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？"><a href="#1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？" class="headerlink" title="1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？"></a>1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？</h4><p>MySQL事件是按<strong>预设时间</strong>&#x2F;<strong>周期</strong>自动执行的SQL程序（如数据清理、统计），依赖<strong>事件调度器</strong>（<code>event_scheduler</code>） 进程监控和触发执行。</p>
<h4 id="2、启用MySQL事件调度器的临时和永久方式分别是什么？"><a href="#2、启用MySQL事件调度器的临时和永久方式分别是什么？" class="headerlink" title="2、启用MySQL事件调度器的临时和永久方式分别是什么？"></a>2、启用MySQL事件调度器的临时和永久方式分别是什么？</h4><p><em>临时启用</em>：<code>SET GLOBAL event_scheduler = ON;</code>；</p>
<p><em>永久启用</em>：修改配置文件（如<code>my.cnf</code>）添加<code>event_scheduler = ON</code>，重启MySQL生效。</p>
<h4 id="3、MySQL事件支持哪两种触发模式？分别用什么语法定义？"><a href="#3、MySQL事件支持哪两种触发模式？分别用什么语法定义？" class="headerlink" title="3、MySQL事件支持哪两种触发模式？分别用什么语法定义？"></a>3、MySQL事件支持哪两种触发模式？分别用什么语法定义？</h4><p>（1）<strong>一次性</strong>触发：<code>ON SCHEDULE AT &#39;具体时间&#39;</code></p>
<p>（如<code>AT &#39;2025-12-31 23:59&#39;</code>）；<br>（2）<strong>周期性</strong>触发：<code>ON SCHEDULE EVERY 时间间隔 [STARTS 开始时间]</code></p>
<p>（如<code>EVERY 1 DAY STARTS &#39;2025-01-01 03:00&#39;</code>）。</p>
<h4 id="4、创建定时任务时，ON-COMPLETION-PRESERVE的作用是什么？默认行为是什么？"><a href="#4、创建定时任务时，ON-COMPLETION-PRESERVE的作用是什么？默认行为是什么？" class="headerlink" title="4、创建定时任务时，ON COMPLETION PRESERVE的作用是什么？默认行为是什么？"></a>4、创建定时任务时，<code>ON COMPLETION PRESERVE</code>的作用是什么？默认行为是什么？</h4><p><code>ON COMPLETION PRESERVE</code>表示事件执行完成后保留（不自动删除）；</p>
<p>默认行为是<code>ON COMPLETION NOT PRESERVE</code>（一次性事件执行后自动删除）。</p>
<h4 id="5、定时任务适合处理哪些业务场景？不适合哪些场景？"><a href="#5、定时任务适合处理哪些业务场景？不适合哪些场景？" class="headerlink" title="5、定时任务适合处理哪些业务场景？不适合哪些场景？"></a>5、<strong>定时任务</strong>适合处理哪些<strong>业务场景</strong>？不适合哪些场景？</h4><p><strong>适合</strong>：数据库内部周期性操作（如每日清理过期数据、每小时统计订单）；</p>
<p><strong>不适合</strong>：实时性要求极高的任务（调度器有秒级延迟）、跨数据库&#x2F;系统的复杂操作。</p>
<h4 id="6、如何暂停一个正在运行的定时任务？如何彻底删除？"><a href="#6、如何暂停一个正在运行的定时任务？如何彻底删除？" class="headerlink" title="6、如何暂停一个正在运行的定时任务？如何彻底删除？"></a>6、如何暂停一个正在运行的定时任务？如何彻底删除？</h4><p>暂停（禁用）：<code>ALTER EVENT 事件名 DISABLE;</code>；</p>
<p>彻底删除：<code>DROP EVENT IF EXISTS 事件名;</code>。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、说说事务的四大特性"><a href="#1、说说事务的四大特性" class="headerlink" title="1、说说事务的四大特性"></a>1、说说事务的四大特性</h4><blockquote>
<p><strong>事务的四大特性（ACID）：</strong><br><strong>原子性（Atomicity）</strong>：是指事务是一个不可分割的整体，事务中的操作要么全部成功，要么全部失败回滚；</p>
<p>例如：转账业务中减钱和加钱的操作，要么同时成功，要么同时失败。</p>
<p><strong>一致性（Consistency）</strong>：是指一个事务中，事务前后数据的完整性必须保持一致；</p>
<p>例如：转账业务中，转账前和转账后，总金额必须一致。</p>
<p><strong>隔离性（Isolation）</strong>：多个事务，在并发事务中，一个事务不能被其他事务所干扰，多个并发事务之间数据要相互隔离。<br><strong>持久性（Durability）</strong>：是指一个事务一旦被提交，该事务对数据库中数据的操作，必须被持久化</p>
</blockquote>
<h4 id="2、说说事务的隔离级别"><a href="#2、说说事务的隔离级别" class="headerlink" title="2、说说事务的隔离级别"></a>2、说说事务的隔离级别</h4><blockquote>
<p>事务的隔离级别从低到高：<br><strong>读未提交（Read Uncommitted）</strong>：允许读取未提交的数据，可能出现脏读、不可重复读和幻读。<br><strong>读已提交（Read Committed）</strong>：只允许读取已提交的数据，避免了脏读，但可能出现不可重复读和幻读。（oracle默认）<br><strong>可重复读（Repeatable Read）</strong>：在同一事务中多次读取同样的数据结果一致，避免了脏读和不可重复读，但可能出现幻读。MySQL的InnoDB默认使用这种隔离级别。</p>
<p>mysql中InnoDB增强，通过<strong>间隙锁和临键锁</strong>也解决了幻读</p>
<p><strong>串行化（Serializable）</strong>：最高级别，事务串行执行，避免了所有并发问题，但性能最差。</p>
</blockquote>
<h4 id="3、什么是事务？请用生活中的例子类比事务的核心特性。"><a href="#3、什么是事务？请用生活中的例子类比事务的核心特性。" class="headerlink" title="3、什么是事务？请用生活中的例子类比事务的核心特性。"></a>3、什么是事务？请用生活中的例子类比事务的核心特性。</h4><p>事务是数据库中的一系列操作，这些操作要么全部成功执行，要么全部不执行，是数据库操作的基本单位。</p>
<p>以<strong>银行转账</strong>为例：</p>
<p>原子性：小明给小红转账1000元，要么成功（小明账户-1000，小红账户+1000），要么失败（两个账户都不变），不会出现只扣款不到账的情况。</p>
<p>一致性：转账前后，两个账户的总金额保持不变，符合”钱不会凭空消失或增加”的规则。</p>
<p>隔离性：小明给小红转账的同时，小王也在查询小红的账户余额，小王应该只能看到转账完成前或完成后的状态，而不是中间状态。</p>
<p>持久性：一旦转账成功，即使银行系统立即崩溃，重启后小红的账户里仍然有这笔钱。</p>
<h4 id="4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？"><a href="#4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？" class="headerlink" title="4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？"></a>4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？</h4><p>在MySQL中：</p>
<p>**原子性（Atomicity）**依赖 <strong>undo log（回滚日志）</strong>，记录操作的反向逻辑，事务失败时通过undo log撤销已执行的修改； </p>
<p>**持久性（Durability）**依赖 <strong>redo log（重做日志）</strong>，事务提交时先将修改写入redo log（磁盘），即使数据库崩溃，重启后可通过redo log恢复已提交的修改。  </p>
<h4 id="5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？"><a href="#5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？" class="headerlink" title="5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？"></a>5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？</h4><ul>
<li>核心区别：RC级别下，事务中两次读取同一数据可能因其他事务提交而不一致（不可重复读）；RR级别下，事务中多次读取数据结果一致（通过MVCC和间隙锁实现）。  </li>
<li>InnoDB默认隔离级别是可重复读（RR）。</li>
</ul>
<h4 id="6、什么是”脏读”？如何通过隔离级别避免脏读？"><a href="#6、什么是”脏读”？如何通过隔离级别避免脏读？" class="headerlink" title="6、什么是”脏读”？如何通过隔离级别避免脏读？"></a>6、什么是”脏读”？如何通过隔离级别避免脏读？</h4><p><strong>脏读</strong>：<strong>一个事务读取到另一个事务未提交的数据</strong>。这种情况下，如果未提交的事务最终回滚，那么读取到的数据就是无效的。</p>
<p>如何通过隔离级别避免脏读： 设置事务隔离级别至少为”<strong>读已提交（Read Committed）</strong>“或更高级别。</p>
<ul>
<li>读未提交（Read Uncommitted）：允许脏读</li>
<li>读已提交（Read Committed）：避免脏读，但可能有不可重复读</li>
<li>可重复读（Repeatable Read）：避免脏读和不可重复读</li>
<li>串行化（Serializable）：避免所有并发问题</li>
</ul>
<h4 id="7、事务的并发问题"><a href="#7、事务的并发问题" class="headerlink" title="7、事务的并发问题"></a><strong>7、事务的并发问题</strong></h4><blockquote>
<p>1、<strong>脏读</strong>：是指一个事务读取到了另外一个事务未提交的数据（脏数据）；</p>
<p>2、<strong>不可重复读</strong>：当前事务在读取数据时，另外一个事务修改了数据，导致当前事务对数据的两次查询结果不一致；<br>3、<strong>幻读</strong>：当前事务读取<strong>表</strong>数据，另外一个事务对<strong>表</strong>的数据进行了新增或删除，导致当前事务对表的两次查询结果不一致。</p>
</blockquote>
<h4 id="8、长事务有哪些风险？如何优化长事务？"><a href="#8、长事务有哪些风险？如何优化长事务？" class="headerlink" title="8、长事务有哪些风险？如何优化长事务？"></a>8、长事务有哪些风险？如何优化长事务？</h4><p><strong>风险包括</strong>：占用锁资源导致并发阻塞、产生大量undo log占用磁盘空间、数据库崩溃后恢复时间长。<br><strong>优化方案</strong>：拆分长事务为短事务（如批量更新分批次执行）、减少事务中的非数据库操作（如网络请求）、合理设置锁等待超时时间。 </p>
<h4 id="9、事务的”一致性”与数据库三范式的”一致性”有何区别？"><a href="#9、事务的”一致性”与数据库三范式的”一致性”有何区别？" class="headerlink" title="9、事务的”一致性”与数据库三范式的”一致性”有何区别？"></a>9、事务的”一致性”与数据库三范式的”一致性”有何区别？</h4><ul>
<li><p><strong>事务的一致性</strong>：指事务执行前后，数据从一个合法状态转换到另一个合法状态（如库存不能为负），是运行时的数据正确性保障；  </p>
</li>
<li><p><strong>三范式的一致性</strong>：指表结构设计中数据无冗余、无异常，是设计时的数据存储合理性保障。</p>
</li>
</ul>
<h4 id="10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。"><a href="#10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。" class="headerlink" title="10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。"></a>10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">手动控制事务的核心语句包括`BEGIN`、`COMMIT`、`ROLLBACK`。  </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账示例（A账户向B账户转100元）：  </span></span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- A扣款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>; <span class="comment">-- B入账</span></span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 提交事务（若两句都成功）</span></span><br><span class="line"><span class="comment">-- 若中间出错，执行 ROLLBACK; 撤销所有修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 使用存储过程，完成转账业务操作</span></span><br><span class="line"><span class="comment">-- 需求</span></span><br><span class="line"><span class="comment">-- （1）查询余额 &gt; 1000 的 就可以转账， 小于 1000， 提示余额不足</span></span><br><span class="line"><span class="comment">-- （2）转账过程中出现异常，就回滚事务  </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> transfer_money;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> transfer_money(</span><br><span class="line"> <span class="keyword">IN</span> out_id <span class="type">INT</span>,  <span class="comment">-- 转出账户</span></span><br><span class="line"> <span class="keyword">IN</span> in_id <span class="type">INT</span>,   <span class="comment">-- 转入账户</span></span><br><span class="line"> <span class="keyword">IN</span> `money` <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),   <span class="comment">-- 转账金额</span></span><br><span class="line"> <span class="keyword">OUT</span> result_msg  <span class="type">VARCHAR</span>(<span class="number">255</span>)   <span class="comment">-- 转账结果</span></span><br><span class="line">)</span><br><span class="line">label: <span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- 声明变量</span></span><br><span class="line">   <span class="keyword">DECLARE</span> out_balance <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);   <span class="comment">-- 转出账户的余额</span></span><br><span class="line">   <span class="keyword">DECLARE</span> has_in_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   <span class="comment">-- 判断转入账户是否存在</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">-- 异常处理处理器</span></span><br><span class="line">   <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span>  <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">     <span class="keyword">ROLLBACK</span>;  <span class="comment">--  回滚事务</span></span><br><span class="line">     <span class="keyword">SET</span> result_msg :<span class="operator">=</span> <span class="string">&#x27;转账失败，系统出现异常，请重试！&#x27;</span>;</span><br><span class="line">   <span class="keyword">END</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">-- 判断转入账户是否存在</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> has_in_id <span class="keyword">FROM</span> `account` <span class="keyword">WHERE</span> id <span class="operator">=</span> in_id; </span><br><span class="line">   </span><br><span class="line">   IF has_in_id <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">     <span class="keyword">SET</span> result_msg :<span class="operator">=</span> <span class="string">&#x27;转入账户不存在！&#x27;</span>;</span><br><span class="line">     LEAVE label;</span><br><span class="line">   <span class="keyword">END</span> IF; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">-- 开始事务</span></span><br><span class="line">   <span class="keyword">START</span> TRANSACTION;   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">-- 查询转出账户余额</span></span><br><span class="line">   <span class="keyword">SELECT</span> balance <span class="keyword">INTO</span> out_balance <span class="keyword">FROM</span> `account` <span class="keyword">WHERE</span> id <span class="operator">=</span> out_id;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">-- 判断余额</span></span><br><span class="line">   IF out_balance <span class="operator">&gt;=</span> `money` <span class="keyword">THEN</span></span><br><span class="line">       <span class="comment">-- 转出账户减钱</span></span><br><span class="line">      <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> `money`  <span class="keyword">WHERE</span>  id <span class="operator">=</span>  out_id;</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- 模拟的sql异常  </span></span><br><span class="line">      <span class="comment">-- select * from ccc;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">-- 转入账户加钱</span></span><br><span class="line">      <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> `money`  <span class="keyword">WHERE</span> id <span class="operator">=</span>  in_id;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">-- 转账完成</span></span><br><span class="line">      <span class="keyword">COMMIT</span>;</span><br><span class="line">      <span class="keyword">SET</span> result_msg :<span class="operator">=</span> <span class="string">&#x27;转账成功&#x27;</span>;</span><br><span class="line">   <span class="keyword">ELSE</span> </span><br><span class="line">     <span class="keyword">ROLLBACK</span>;</span><br><span class="line">     <span class="keyword">SET</span> result_msg :<span class="operator">=</span> <span class="string">&#x27;转账失败，您的余额不足！&#x27;</span>;</span><br><span class="line">   <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@result</span> :<span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确转账</span></span><br><span class="line"><span class="comment">-- CALL transfer_money(1, 3, 1000, @result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 余额不足</span></span><br><span class="line"><span class="comment">-- CALL transfer_money(3, 2, 2000, @result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 账号不存在</span></span><br><span class="line"><span class="comment">-- CALL transfer_money(2, 5, 2000, @result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 出现异常</span></span><br><span class="line"><span class="keyword">CALL</span> transfer_money(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="variable">@result</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><h4 id="1、什么是数据库设计三范式"><a href="#1、什么是数据库设计三范式" class="headerlink" title="1、什么是数据库设计三范式"></a>1、什么是数据库设计三范式</h4><p>数据库的三大范式是<strong>关系型数据库</strong>设计中用于<strong>规范表结构</strong>、<strong>减少数据冗余</strong>和<strong>避免更新异常</strong>的重要原则。</p>
<p>1NF：列不可分割（原子性）。<br>2NF：消除非主属性对复合主键的部分依赖（基于1NF）。<br>3NF：消除非主属性之间的传递依赖（基于2NF）。</p>
<blockquote>
<p><strong>第一范式（1NF）</strong>：要求表中的每个字段都是<strong>原子性</strong>的，不可再分。</p>
<p><strong>第二范式（2NF）</strong>：在1NF的基础上，要求非主键字段必须<strong>完全</strong>依赖于主键，而不是部分依赖。解决的是<strong>复合主键</strong>下，表中<strong>数据冗余和更新异常</strong>的问题</p>
<p><strong>第三范式（3NF）</strong>：在2NF的基础上，要求消除非主键字段对主键的<strong>传递依赖</strong>。解决的是非主键属性对主键的<strong>依赖传递问题</strong>（非主键属性之间存在依赖）</p>
</blockquote>
<h4 id="2、什么是数据库范式？其核心目的是什么？"><a href="#2、什么是数据库范式？其核心目的是什么？" class="headerlink" title="2、什么是数据库范式？其核心目的是什么？"></a>2、什么是数据库范式？其核心目的是什么？</h4><p>数据库范式（Normal Form）是关系型数据库设计的规范，用于指导表结构设计以<strong>减少数据冗余</strong>和<strong>避免更新异常</strong>（如插入异常、删除异常、修改异常）。</p>
<p>**核心目的：**通过合理拆分表，确保数据的一致性和存储效率。 </p>
<h4 id="3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。"><a href="#3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。" class="headerlink" title="3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。"></a>3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。</h4><p>第一范式（1NF）定义：要求表中的每个字段都是原子性的，不可再分，即每个字段只包含单一值，不能有重复的属性组。</p>
<p>不满足1NF的例子： 学生表(学号, 姓名, 课程[语文,数学,英语]) ，”课程”字段包含多个值，不是原子性的。</p>
<p>满足1NF的例子： 学生表(学号, 姓名) 选课表(学号, 课程名称)，每个字段都是原子性的，不可再分。 </p>
<h4 id="4、-第二范式（2NF）的前提是什么？其核心要求是什么？"><a href="#4、-第二范式（2NF）的前提是什么？其核心要求是什么？" class="headerlink" title="4、 第二范式（2NF）的前提是什么？其核心要求是什么？"></a>4、 第二范式（2NF）的前提是什么？其核心要求是什么？</h4><p>第二范式（2NF）的前提：首先满足第一范式（1NF）。</p>
<p><strong>核心要求</strong>：表中的非主键字段必须完全依赖于主键，而不是部分依赖。即如果一个表有复合主键，那么每个非主键字段都必须依赖于整个主键，而不能只依赖于主键的一部分。</p>
<p>例如：选课表(学号, 课程号, 成绩, 课程名称) ，其中(学号,课程号)是复合主键，”成绩”完全依赖于(学号,课程号)，但”课程名称”只依赖于”课程号”，这就是部分依赖，不满足2NF。</p>
<h4 id="5、-第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？"><a href="#5、-第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？" class="headerlink" title="5、 第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？"></a>5、 第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？</h4><p>第三范式（3NF）的前提：满足第二范式（2NF）。</p>
<p><strong>核心要求</strong>：表中的非主键字段不能依赖于其他非主键字段，即消除非主键字段对主键的传递依赖。</p>
<p>与2NF的区别：</p>
<ul>
<li>2NF解决的是非主键字段对主键的<strong>部分依赖</strong>问题</li>
<li>3NF解决的是非主键字段对主键的<strong>传递依赖</strong>问题</li>
</ul>
<p>例如：学生表(学号, 姓名, 系名, 系主任) 其中”学号”是主键，”系主任”依赖于”系名”，而”系名”依赖于”学号”，这就形成了”学号-&gt;系名-&gt;系主任”的传递依赖，不满足3NF。</p>
<p>需拆分出<code>系表</code>（存储<code>系别</code>和<code>系主任</code>），<code>学生表</code>仅保留<code>学号</code>和<code>系别</code>，通过<code>系别</code>关联。 </p>
<h4 id="6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？"><a href="#6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？" class="headerlink" title="6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？"></a>6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？</h4><p><strong>不一定</strong>。三范式虽减少冗余，但可能导致表数量过多，查询时需频繁关联（如多表JOIN），降低查询性能。 </p>
<p><strong>反范式化</strong>是指有选择地增加冗余字段，减少表关联，提升查询效率，适合读多写少的场景（如电商商品详情页，将商品分类名称冗余到商品表，避免关联分类表）。 </p>
<h4 id="7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。"><a href="#7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。" class="headerlink" title="7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。"></a>7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。</h4><p><strong>例如现在有一张学生表</strong>，维护学生的<strong>学号</strong>，学生的<strong>老师编号</strong>以及<strong>老师的手机号</strong>，现在这张表的字段存在依赖传递问题，老师的手机号依赖老师的编号，老师的编号依赖学生学号，不满足第三范式；                                                            </p>
<p>假如有一条数据：1号学生对应的老师编号是 101， 老师的手机号是 123，  那么现在如果我们更新1号学生的教师手机号为456，那么该学生表中 其它学号的学生对应的 101 号教师的手机号就不匹配了，出现更新异常。</p>
<p><strong>解决</strong>这个问题的方式有两种：</p>
<blockquote>
<p>（1）更新1号学生信息的同时，要更新表中所有该教师的手机号，非常麻烦<br>（2）设计更规范的表，将学生表拆分成两张表，将教师的手机号和教师编号单独使用教师表维护，学生表只维护学号和直接依赖的教师编号即可，这就是符合 数据库设计的第三范式，消除非主键对主键的传递依赖</p>
</blockquote>
<blockquote>
<p><strong>不满足三范式的表例子</strong>： 学生选课表(学号, 姓名, 课程号, 课程名称, 成绩)</p>
<p>这个表中，”课程名称”依赖于”课程号”，而不是直接依赖于主键”学号”，形成了传递依赖，不满足3NF。</p>
</blockquote>
<p><strong>可能导致的更新异常：</strong></p>
<ol>
<li><strong>更新异常</strong>：如果需要修改某个课程的名称，必须找到并更新所有选修该课程的记录，否则会导致数据不一致。例如，课程”C001”名称从”数据库”改为”数据库原理”，需要修改所有选修C001的记录。</li>
<li><strong>插入异常</strong>：如果要添加一门新课程，但还没有学生选修，就无法在该表中添加课程信息。</li>
<li><strong>删除异常</strong>：如果某门课程的所有学生记录都被删除，则该课程的信息也会丢失。</li>
</ol>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="1、什么是存储引擎？MySQL中常见的存储引擎有哪些？"><a href="#1、什么是存储引擎？MySQL中常见的存储引擎有哪些？" class="headerlink" title="1、什么是存储引擎？MySQL中常见的存储引擎有哪些？"></a>1、什么是存储引擎？MySQL中常见的存储引擎有哪些？</h4><p>存储引擎就是<strong>存储数据、建立索引、更新&#x2F;查询数据</strong>等技术的实现方式 。存储引擎是<strong>基于表</strong>的，而不是基于库的，所以存储引擎也可被称为<strong>表类型</strong>。</p>
<p><strong>常见的存储引擎</strong>：</p>
<blockquote>
<p>1、 <strong>InnoDB</strong>：是一种兼顾高可靠性和高性能的通用存储引擎，从MySQL 5.5开始成为<strong>默认</strong>的存储引擎。它<strong>支持事务处理（ACID兼容）、行级锁定、外键约束、崩溃恢复</strong>等特性，适合于<strong>高并发环境</strong>下的数据操作。</p>
<p>2、MyISAM：在MySQL 5.5之前是默认的存储引擎。它不支持事务和行级锁，但因为其设计简单，所以在某些读密集型应用中表现良好。不过，它的表级锁定限制了写操作的并发性。</p>
<p>3、Memory：将所有数据保存在内存中，因此读写速度非常快，适用于需要快速查找的临时表格。但是由于数据只存在于内存中，所以如果服务器关闭或崩溃，数据会丢失，安全性差。</p>
</blockquote>
<h4 id="2、InnoDB和MyISAM的核心区别是什么？（高频考点）"><a href="#2、InnoDB和MyISAM的核心区别是什么？（高频考点）" class="headerlink" title="2、InnoDB和MyISAM的核心区别是什么？（高频考点）"></a>2、InnoDB和MyISAM的核心区别是什么？（高频考点）</h4><blockquote>
<p><strong>事务支持</strong>：<br>InnoDB 提供完整的 <strong>ACID 事务支持</strong>，而 MyISAM 完全不支持事务。</p>
<p><strong>锁机制</strong>：<br>InnoDB 采用<strong>行级锁</strong>，允许多个事务并发修改不同行；MyISAM 使用<strong>表级锁</strong>，任何写操作都会锁定整个表，遇到大量并发写入时性能瓶颈明显。</p>
<p><strong>数据完整性</strong>：<br>InnoDB 支持<strong>外键约束</strong>和<strong>崩溃自动恢复</strong>（通过 redo log）；MyISAM 不支持外键，崩溃后需要手动修复表（崩溃后可能数据损坏）。</p>
<p><strong>索引结构</strong>：<br>InnoDB 采用<strong>聚簇索引</strong>，数据与主键索引绑定存储；MyISAM 使用非聚簇索引，数据与索引分离存储。</p>
<p><strong>文件存储</strong>：<br>InnoDB 将数据+索引存储在 <code>.ibd</code> 文件中；MyISAM 分离存储数据（<code>.MYD</code>）和索引（<code>.MYI</code>）。</p>
<p><strong>适用场景</strong>：<br>InnoDB 适合<strong>高并发事务型</strong>应用（如电商、金融）；MyISAM 适合读多写少的事务性要求不高的场景（密集型应用）。</p>
</blockquote>
<h4 id="3、为什么InnoDB是MySQL的默认存储引擎？"><a href="#3、为什么InnoDB是MySQL的默认存储引擎？" class="headerlink" title="3、为什么InnoDB是MySQL的默认存储引擎？"></a>3、为什么InnoDB是MySQL的默认存储引擎？</h4><blockquote>
<ol>
<li>支持事务和ACID特性，保证数据一致性；  </li>
<li>行级锁支持高并发场景，减少锁冲突；  </li>
<li>聚簇索引设计提升查询效率；  </li>
<li>支持崩溃恢复和外键，适合复杂业务场景（如电商、金融）。</li>
</ol>
</blockquote>
<h4 id="4、Memory存储引擎的特点和适用场景？"><a href="#4、Memory存储引擎的特点和适用场景？" class="headerlink" title="4、Memory存储引擎的特点和适用场景？"></a>4、Memory存储引擎的特点和适用场景？</h4><blockquote>
<p><strong>核心特点</strong>：</p>
<ul>
<li>数据存储在<strong>内存</strong>中，读写速度极快，但数据易失性使其不适合持久化存储。</li>
<li>使用<strong>哈希表</strong>实现索引，查找速度快，但索引大小受内存限制。</li>
<li><strong>不支持事务</strong>和行级锁定，只能进行<strong>表级锁定</strong>，写操作时会锁定整个表。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>临时</strong>数据存储和查询，如复杂查询的中间结果存储、临时排序等，提升查询效率。</li>
<li>缓存频繁查询的数据，如热点数据缓存，减少磁盘 I&#x2F;O 操作，加快查询速度。</li>
<li>性能测试和调试，因其内存操作的高效性，可快速测试数据库性能或调试 SQL 查询。</li>
</ul>
</blockquote>
<h4 id="5、说说mysql-体系结构"><a href="#5、说说mysql-体系结构" class="headerlink" title="5、说说mysql 体系结构"></a>5、说说mysql 体系结构</h4><ul>
<li>连接层：主要负责连接处理、授权认证、安全方案等功能。</li>
<li>服务层：主要负责核心服务功能，比如sql接口，完成缓存查询，内置函数的执行等功能。</li>
<li><strong>引擎层</strong>：存储引擎主要负责 mysql 中数据的存储和提取。</li>
<li>存储层：主要负责将数据存储到磁盘文件中</li>
</ul>
<h4 id="6、存储引擎的选择"><a href="#6、存储引擎的选择" class="headerlink" title="6、存储引擎的选择"></a>6、存储引擎的选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB : 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、什么是索引？索引的核心作用是什么？"><a href="#1、什么是索引？索引的核心作用是什么？" class="headerlink" title="1、什么是索引？索引的核心作用是什么？"></a>1、什么是索引？索引的核心作用是什么？</h4><blockquote>
<ol>
<li><p>索引是数据库中用于<strong>快速定位表中数据</strong>的结构，就像书的目录，可根据索引快速找到对应数据。</p>
</li>
<li><p><strong>核心作用</strong>：加速查询速度（减少数据扫描范围）；但会降低写入性能（需维护索引结构）。</p>
</li>
</ol>
</blockquote>
<h4 id="2、常见的索引类型有哪些？"><a href="#2、常见的索引类型有哪些？" class="headerlink" title="2、常见的索引类型有哪些？"></a>2、常见的索引类型有哪些？</h4><ul>
<li><strong>按结构分</strong>：B+树索引（最常用）、哈希索引、全文索引、R树索引。  </li>
<li><strong>按功能分</strong>：  <ul>
<li>聚簇索引（主键索引，叶子节点存完整数据）；  </li>
<li>非聚簇索引（二级索引，叶子节点存主键值）；  </li>
<li>联合索引（多列组合索引）；  </li>
<li>唯一索引（值唯一，如身份证号）。</li>
</ul>
</li>
</ul>
<p><strong>结构：</strong></p>
<p>​	<strong>B+树索引（最常用）、哈希索引、全文索引、R树索引。</strong>  </p>
<p>（1）<strong>主键索引</strong>：针对于表中主键创建的索引，默认自动创建, 只能有一个，关键字：PRIMARY<br>（2）<strong>唯一索引</strong>：避免同一个表中某数据列中的值重复，可以有多个，关键字：UNIQUE<br>（3）<strong>普通索引</strong>：快速定位特定数据，最基本的索引类型，无唯一性限制<br>（4）<strong>全文索引</strong>：全文索引查找的是文本中的关键词，而不是比较索引中的值</p>
<p><strong>功能：</strong><br>（1）<strong>聚集索引&#x2F;聚簇索引</strong>(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。</p>
<p>（2）<strong>二级索引&#x2F;非聚簇索引</strong>(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</p>
<p>（3） <strong>联合索引</strong>：多列组合索引（需遵循最左前缀原则）</p>
<h4 id="3、B-树索引的优势是什么？（高频考点）"><a href="#3、B-树索引的优势是什么？（高频考点）" class="headerlink" title="3、B+树索引的优势是什么？（高频考点）"></a><strong>3、B+树索引的优势是什么？（高频考点）</strong></h4><blockquote>
<p>1.b+tree 可以存放<strong>多个节点</strong></p>
<p>2.非叶子结点只存储<strong>索引键</strong>（好处：每页存放的节点数量可以更多，树的高度越低，查询效率越快）</p>
<p>3.所有的<strong>数据</strong>都存储在<strong>叶子结点</strong>（好处：在叶子结点形成双向链表，更利于范围查询）</p>
</blockquote>
<blockquote>
<ul>
<li>叶子节点按顺序链表连接，支持范围查询（如<code>BETWEEN</code>、<code>ORDER BY</code>）；  </li>
<li>非叶子节点仅存索引键，索引树高度低（通常3-4层），查询效率高；  </li>
<li>所有数据存在叶子节点，查询结果稳定（每次查询路径长度一致）。  </li>
<li><strong>稳定的查询性能</strong>：所有数据都存储在叶子节点，查询任何数据的路径长度都相同，保证了稳定的查询性能</li>
</ul>
</blockquote>
<h4 id="4、聚簇索引和非聚簇索引的区别？"><a href="#4、聚簇索引和非聚簇索引的区别？" class="headerlink" title="4、聚簇索引和非聚簇索引的区别？"></a>4、聚簇索引和非聚簇索引的区别？</h4><blockquote>
<ul>
<li><strong>聚簇索引</strong>：索引和数据存于同一文件（InnoDB的主键索引），叶子节点即数据行；查询时找到索引即可获取数据，效率高。  一个表只能有<strong>一个聚簇索引</strong></li>
<li><strong>非聚簇索引</strong>：索引和数据分离（MyISAM所有索引），叶子节点存数据地址；查询时需先查索引，再通过地址取数据（回表），效率较低。一个表可以有多个非聚簇索引</li>
</ul>
</blockquote>
<p><strong>聚集索引</strong>的特点是：默认使用主键创建聚集索引，叶子节点保存了整行数据</p>
<p><strong>非聚集索引</strong>的特点是：使用其它字段创建的例如单列索引、联合索引都是非聚集索引，叶子节点保存的是主键，如果不能在非聚集索引表中直接查询到数据，那么需要回聚集索引表查询数据，也就是回表查询。</p>
<h4 id="5、聚簇索引选取的规则？"><a href="#5、聚簇索引选取的规则？" class="headerlink" title="5、聚簇索引选取的规则？"></a><strong>5、聚簇索引选取的规则？</strong></h4><p>如果存在主键，主键索引就是聚簇（聚集）索引</p>
<p>如果不存在主键，将使用<strong>第一个唯一(UNIQUE)索引</strong>作为聚簇（聚集）索引</p>
<p>如果表没有主键或合适的唯一索引，InnoDB会自动生成一个<strong>rowid</strong>作为隐藏的聚簇（聚集）索引</p>
<h4 id="6、聚簇索引和二级索引谁的查询的效率高？为什么？"><a href="#6、聚簇索引和二级索引谁的查询的效率高？为什么？" class="headerlink" title="6、聚簇索引和二级索引谁的查询的效率高？为什么？"></a>6、聚簇索引和二级索引谁的查询的效率高？为什么？</h4><ul>
<li>聚簇索引的效率高</li>
<li>聚簇索引将数据存储与索引放到了一块，二级索引将数据与索引分开存储，<br>它的索引结构的叶子节点关联的是对应的主键，使用二级索引查询，还是需要回表查询聚簇索引</li>
</ul>
<h4 id="7、哪些情况会导致索引失效？（高频考点）"><a href="#7、哪些情况会导致索引失效？（高频考点）" class="headerlink" title="7、哪些情况会导致索引失效？（高频考点）"></a>7、哪些情况会导致索引失效？（高频考点）</h4><ol>
<li><strong>查询条件中使用函数或表达式</strong>：<code>WHERE YEAR(create_time)=2023</code></li>
<li><strong>隐式类型转换</strong>：字符串索引列使用数字查询 <code>WHERE id=&#39;100&#39;</code> (id 是整数)</li>
<li><strong>LIKE语句以 % 开头</strong>：<code>WHERE name LIKE &#39;%abc&#39;</code></li>
<li><strong><code>OR</code>连接的列中有非索引列</strong>：<code>WHERE id=1 OR age=20</code>（age 无索引）</li>
<li><strong>联合索引未遵循最左前缀原则</strong>：如联合索引<code>(a,b,c)</code>，查询<code>b=1</code>会失效</li>
<li><strong>使用不等于操作符</strong>：<code>WHERE status != 1</code></li>
<li><strong>数据量过少</strong>：优化器判定全表扫描更快（通常 &lt; 10 行）</li>
</ol>
<h4 id="8、如何使用索引优化sql查询"><a href="#8、如何使用索引优化sql查询" class="headerlink" title="8、如何使用索引优化sql查询"></a><strong>8、如何使用索引优化sql查询</strong></h4><p><img src="/images/image-20250821112955243.png" alt="image-20250821112955243"></p>
<h4 id="9、联合索引的“最左前缀原则”是什么？"><a href="#9、联合索引的“最左前缀原则”是什么？" class="headerlink" title="9、联合索引的“最左前缀原则”是什么？"></a>9、联合索引的“最左前缀原则”是什么？</h4><p>查询条件必须包含联合索引中最左边的列，才能有效利用索引，跳过中间某列时，后面列的索引会失效。</p>
<ul>
<li>联合索引<code>(a,b,c)</code>的生效顺序为<code>a</code>→<code>a,b</code>→<code>a,b,c</code>；  </li>
<li>若查询条件不包含最左列（如<code>b=1</code>或<code>b=1 AND c=2</code>），索引失效；  </li>
<li>设计时需将高频查询列放左侧（如<code>(用户ID, 订单时间)</code>）。</li>
</ul>
<h4 id="10、为什么不建议大量创建索引？"><a href="#10、为什么不建议大量创建索引？" class="headerlink" title="10、为什么不建议大量创建索引？"></a><strong>10、为什么不建议大量创建索引？</strong></h4><ol>
<li>写入（INSERT&#x2F;UPDATE&#x2F;DELETE）时需维护索引结构，耗时增加；  </li>
<li>索引占用磁盘空间，过多会浪费存储；  </li>
<li>优化器可能选择低效索引，反而降低查询性能。</li>
</ol>
<p>索引也是一个表结构，它会占据磁盘空间<br>在增删改数据的时候，加了索引的字段，索引表的结构会跟着发生更新，大量创建索引的话，那么更新的索引表就多，降低性能</p>
<p><img src="/images/image-20250818171655861.png" alt="image-20250818171655861"></p>
<p><img src="/images/QQ_1755484187346.png" alt="img"></p>
<h4 id="11、InnoDB为什么推荐使用自增主键作为聚簇索引？"><a href="#11、InnoDB为什么推荐使用自增主键作为聚簇索引？" class="headerlink" title="11、InnoDB为什么推荐使用自增主键作为聚簇索引？"></a><strong>11、InnoDB为什么推荐使用自增主键作为聚簇索引？</strong></h4><ul>
<li>自增主键保证新数据追加到索引树末尾，避免索引树分裂（减少碎片）；  </li>
<li>自增主键值小且连续，节省索引空间；  </li>
<li>若用非自增主键（如UUID），会导致索引树频繁分裂，降低性能。</li>
</ul>
<h4 id="12、主键索引原则"><a href="#12、主键索引原则" class="headerlink" title="12、主键索引原则"></a>12、主键索引原则</h4><p><img src="/images/image-20250818172539922.png" alt="image-20250818172539922"></p>
<p><img src="/images/QQ_1755484176270.png" alt="img"></p>
<h3 id="mysql管理-常用工具"><a href="#mysql管理-常用工具" class="headerlink" title="mysql管理 常用工具"></a>mysql管理 常用工具</h3><h4 id="举例说明常见的mysql管理工具，并说明作用"><a href="#举例说明常见的mysql管理工具，并说明作用" class="headerlink" title="举例说明常见的mysql管理工具，并说明作用"></a><strong>举例说明常见的mysql管理工具，并说明作用</strong></h4><p>mysql客户端、mysqladmin、mysqlbinlog、mysqlshow、mysqldump、mysqlimport  和 source</p>
<p>1.<strong>mysql</strong>（命令行客户端工具）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>连接 MySQL 服务器并执行 SQL 命令</li>
<li>支持批处理脚本操作</li>
<li>远程连接管理数据库</li>
</ul>
<p>2.<strong>mysqladmin</strong>（管理客户端）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>检查服务器状态和配置</li>
<li>创建&#x2F;删除数据库</li>
<li>刷新权限&#x2F;日志</li>
<li>关闭服务器</li>
</ul>
<p>3.<strong>mysqlbinlog</strong>（二进制日志工具）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>解析二进制日志文件（binlog）</li>
<li>数据恢复和审计</li>
<li>主从复制故障排查</li>
</ul>
<p>4.<strong>mysqlshow</strong>（元数据查看工具）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>显示数据库&#x2F;表&#x2F;列结构</li>
<li>统计数据库对象信息</li>
<li>快速查看表状态</li>
</ul>
<p>5.<strong>mysqldump</strong>（数据备份工具）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>逻辑备份数据库</li>
<li>生成 SQL 格式转储文件</li>
<li>支持全库&#x2F;单库&#x2F;单表备份</li>
</ul>
<p>6.<strong>mysqlimport</strong>（数据导入工具）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>批量导入文本文件数据</li>
<li>高效加载分隔符格式数据</li>
<li>与 mysqldump 的 <code>-T</code> 选项配对使用</li>
</ul>
<p>7.<strong>source</strong>（SQL 脚本执行命令）</p>
<p><strong>作用</strong>：</p>
<ul>
<li>在 MySQL 客户端内执行 SQL 脚本</li>
<li>恢复 mysqldump 备份</li>
<li>批量执行 DDL&#x2F;DML 语句</li>
</ul>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="1、数据库锁的核心作用是什么？"><a href="#1、数据库锁的核心作用是什么？" class="headerlink" title="1、数据库锁的核心作用是什么？"></a>1、数据库锁的核心作用是什么？</h4><p>协调并发事务对共享资源的访问，保证数据一致性（避免脏读、不可重复读、幻读），同时平衡并发性能。</p>
<h4 id="2、MySQL-中有哪些锁类型？（按粒度-类型分类）"><a href="#2、MySQL-中有哪些锁类型？（按粒度-类型分类）" class="headerlink" title="2、MySQL 中有哪些锁类型？（按粒度&#x2F;类型分类）"></a>2、MySQL 中有哪些锁类型？（按粒度&#x2F;类型分类）</h4><ul>
<li>按粒度：表锁（MyISAM）、行锁（InnoDB）、页锁（少见）；  </li>
<li>按类型：共享锁（S锁，只读）、排他锁（X锁，读写）；  </li>
<li>特殊锁：意向锁（IS&#x2F;IX，表级）、间隙锁（Gap Lock，范围锁）、临键锁（Next-Key Lock，记录+间隙锁）。</li>
</ul>
<h4 id="3、行锁和表锁的区别是什么？"><a href="#3、行锁和表锁的区别是什么？" class="headerlink" title="3、行锁和表锁的区别是什么？"></a>3、行锁和表锁的区别是什么？</h4><table>
<thead>
<tr>
<th>维度</th>
<th>行锁（InnoDB）</th>
<th>表锁（MyISAM）</th>
</tr>
</thead>
<tbody><tr>
<td>锁定粒度</td>
<td>单行记录</td>
<td>整张表</td>
</tr>
<tr>
<td>并发能力</td>
<td>高（支持多事务并行）</td>
<td>低（锁冲突概率高）</td>
</tr>
<tr>
<td>开销</td>
<td>大（加锁慢）</td>
<td>小（加锁快）</td>
</tr>
<tr>
<td>死锁</td>
<td>可能发生</td>
<td>不会发生</td>
</tr>
</tbody></table>
<h4 id="4、InnoDB-的行锁是如何实现的？为什么行锁必须基于索引？"><a href="#4、InnoDB-的行锁是如何实现的？为什么行锁必须基于索引？" class="headerlink" title="4、InnoDB 的行锁是如何实现的？为什么行锁必须基于索引？"></a>4、InnoDB 的行锁是如何实现的？为什么行锁必须基于索引？</h4><p>InnoDB 行锁通过 <strong>索引</strong> 实现：  </p>
<ul>
<li>若 SQL 条件命中索引（如 <code>WHERE id=1</code>），则锁定对应索引行；  </li>
<li>若条件无索引（如 <code>WHERE name=&#39;xxx&#39;</code>），则行锁退化为<strong>表锁</strong>（全表扫描并锁定所有行）。</li>
</ul>
<h4 id="5、间隙锁（Gap-Lock）和临键锁（Next-Key-Lock）的作用是什么？"><a href="#5、间隙锁（Gap-Lock）和临键锁（Next-Key-Lock）的作用是什么？" class="headerlink" title="5、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的作用是什么？"></a>5、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的作用是什么？</h4><ul>
<li>间隙锁：锁定<strong>索引区间的间隙</strong>（如 <code>WHERE id BETWEEN 1 AND 10</code> 会锁定(1,10)的间隙），防止其他事务插入新数据，解决<strong>幻读</strong>；  </li>
<li>临键锁：间隙锁 + 记录锁（如锁定id&#x3D;5及之前的间隙），是 InnoDB <strong>可重复读（RR）</strong> 隔离级别的默认锁算法。</li>
</ul>
<h4 id="6、什么是-MVCC？它如何与锁机制协同工作？"><a href="#6、什么是-MVCC？它如何与锁机制协同工作？" class="headerlink" title="6、什么是 MVCC？它如何与锁机制协同工作？"></a>6、什么是 MVCC？它如何与锁机制协同工作？</h4><p>MVCC（多版本并发控制）通过保存数据的<strong>多个版本</strong>（Undo Log + 隐藏字段 <code>trx_id</code>&#x2F;<code>roll_pointer</code>）实现读并发：  </p>
<ul>
<li><strong>快照读</strong>（普通 <code>SELECT</code>）：基于事务启动时的 Read View 读取历史版本，无需加锁；  </li>
<li><strong>当前读</strong>（<code>SELECT FOR UPDATE</code>&#x2F;<code>UPDATE</code>）：加行锁或间隙锁，确保读取最新数据并阻止并发修改。</li>
</ul>
<h4 id="7、MySQL-死锁的常见原因是什么？如何排查和解决？"><a href="#7、MySQL-死锁的常见原因是什么？如何排查和解决？" class="headerlink" title="7、MySQL 死锁的常见原因是什么？如何排查和解决？"></a>7、MySQL 死锁的常见原因是什么？如何排查和解决？</h4><ul>
<li>原因：<strong>循环锁等待</strong>（如事务A锁表1→等表2，事务B锁表2→等表1）、<strong>锁粒度冲突</strong>（行锁与表锁）、<strong>索引失效导致锁范围过大</strong>；  </li>
<li>排查：<code>SHOW ENGINE INNODB STATUS\G</code> 查看死锁日志，或查询 <code>performance_schema.innodb_lock_waits</code>；  </li>
<li>解决：固定锁顺序（如按表名升序加锁）、缩短事务时长、设置锁超时（<code>innodb_lock_wait_timeout</code>）。</li>
</ul>
<h4 id="8、如何优化数据库锁的性能？"><a href="#8、如何优化数据库锁的性能？" class="headerlink" title="8、如何优化数据库锁的性能？"></a><strong>8、如何优化数据库锁的性能？</strong></h4><ul>
<li>索引优化：确保 SQL 走索引，避免行锁变表锁；  </li>
<li>事务优化：缩小事务范围（只包含必要操作）、避免长事务；  </li>
<li>锁粒度优化：用行锁替代表锁，或用乐观锁（版本号）减少锁竞争；  </li>
<li>隔离级别优化：读已提交（RC）比可重复读（RR）锁竞争更少（需业务容忍不可重复读）。</li>
</ul>
<h4 id="9、事务隔离级别如何影响锁的行为？"><a href="#9、事务隔离级别如何影响锁的行为？" class="headerlink" title="9、事务隔离级别如何影响锁的行为？"></a>9、事务隔离级别如何影响锁的行为？</h4><ul>
<li><strong>读未提交（RU）</strong>：无锁，直接读未提交数据（脏读风险）；  </li>
<li><strong>读已提交（RC）</strong>：快照读（MVCC），当前读加行锁（防止脏读，仍有不可重复读&#x2F;幻读）；  </li>
<li><strong>可重复读（RR）</strong>：快照读复用 Read View，当前读加间隙锁&#x2F;临键锁（防止不可重复读，幻读需依赖间隙锁）；  </li>
<li><strong>串行化（SERIALIZABLE）</strong>：所有操作加表锁，事务串行执行（无并发，但最安全）。</li>
</ul>
<h4 id="10、为什么-InnoDB-的可重复读（RR）能防止幻读？"><a href="#10、为什么-InnoDB-的可重复读（RR）能防止幻读？" class="headerlink" title="10、为什么 InnoDB 的可重复读（RR）能防止幻读？"></a>10、为什么 InnoDB 的可重复读（RR）能防止幻读？</h4><p>RR 级别通过 <strong>MVCC（快照读）</strong> + <strong>间隙锁&#x2F;临键锁（当前读）</strong> 协同实现：  </p>
<ul>
<li>快照读：事务内多次查询基于同一 Read View，只能看到事务启动前已提交的数据；  </li>
<li>当前读：加间隙锁锁定范围，阻止其他事务插入新数据，从而避免幻读。</li>
</ul>
<h4 id="11、执行-SELECT-FROM-table-WHERE-id-1-FOR-UPDATE-时，InnoDB-加了什么锁？"><a href="#11、执行-SELECT-FROM-table-WHERE-id-1-FOR-UPDATE-时，InnoDB-加了什么锁？" class="headerlink" title="11、执行 SELECT * FROM table WHERE id=1 FOR UPDATE 时，InnoDB 加了什么锁？"></a>11、执行 <code>SELECT * FROM table WHERE id=1 FOR UPDATE</code> 时，InnoDB 加了什么锁？</h4><p>答：若 <code>id</code> 是唯一索引，加<strong>行锁</strong>（Record Lock）；若 <code>id</code> 无索引，加<strong>表锁</strong>。  </p>
<h4 id="12、如何避免“修改丢失”问题？"><a href="#12、如何避免“修改丢失”问题？" class="headerlink" title="12、如何避免“修改丢失”问题？"></a>12、如何避免“修改丢失”问题？</h4><p>答：用<strong>排他锁</strong>（如 <code>SELECT ... FOR UPDATE</code>）或<strong>乐观锁</strong>（版本号）：  </p>
<ul>
<li>悲观锁：<code>BEGIN; SELECT ... FOR UPDATE; UPDATE ...; COMMIT;</code>  </li>
<li>乐观锁：<code>UPDATE table SET num=num+1, version=version+1 WHERE id=1 AND version=old_version;</code></li>
</ul>
<h4 id="13、判断对错并说明理由："><a href="#13、判断对错并说明理由：" class="headerlink" title="13、判断对错并说明理由："></a>13、判断对错并说明理由：</h4><ul>
<li>（1）InnoDB 的行锁一定比表锁性能好。<code>错：行锁加锁开销大，小表全表更新时表锁更高效（如MyISAM表锁）</code></li>
<li>（2）只要使用了索引，InnoDB 就会加行锁，不会升级为表锁。<code>错：索引失效（如函数操作索引列）时，行锁会退化为表锁。</code></li>
<li>（3）MySQL 的 “可重复读（RR）” 隔离级别完全避免了幻读。<code>对：InnoDB的RR通过间隙锁/临键锁避免幻读，超出了sql标准定义的 RR 能力</code></li>
</ul>
<h4 id="14、共享锁（S-锁）和排他锁（X-锁）的兼容规则是什么？举例说明哪些-SQL-操作会自动加这两种锁。"><a href="#14、共享锁（S-锁）和排他锁（X-锁）的兼容规则是什么？举例说明哪些-SQL-操作会自动加这两种锁。" class="headerlink" title="14、共享锁（S 锁）和排他锁（X 锁）的兼容规则是什么？举例说明哪些 SQL 操作会自动加这两种锁。"></a>14、共享锁（S 锁）和排他锁（X 锁）的兼容规则是什么？举例说明哪些 SQL 操作会自动加这两种锁。</h4><ul>
<li>兼容规则：S锁 和 S 锁兼容，S 锁与 X 锁互斥，X 锁与所有锁互斥</li>
<li>示例：<ul>
<li>S 锁： select … lock in share mode (共享读锁)</li>
<li>X 锁： update&#x2F;delete（独占写锁，自动加 X 锁）</li>
</ul>
</li>
</ul>
<h4 id="15、间隙锁（Gap-Lock）和临键锁（Next-Key-Lock）的触发条件是什么？为什么-InnoDB-需要这两种锁？"><a href="#15、间隙锁（Gap-Lock）和临键锁（Next-Key-Lock）的触发条件是什么？为什么-InnoDB-需要这两种锁？" class="headerlink" title="15、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的触发条件是什么？为什么 InnoDB 需要这两种锁？"></a>15、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的触发条件是什么？为什么 InnoDB 需要这两种锁？</h4><ul>
<li>触发条件：InnoDB 在 RR 隔离级别下，对索引列的范围查询（如 &gt;、between）触发</li>
<li>作用：通过锁定索引间隙，阻止新数据插入，解决幻读问题（临键锁是<code>记录锁</code> 和 <code>间隙锁</code> 的组合）。</li>
</ul>
<h3 id="经典代码案例"><a href="#经典代码案例" class="headerlink" title="经典代码案例"></a>经典代码案例</h3><p>以下是 MySQL 数据库中经典且常用的代码案例，涵盖表设计、CRUD 操作、事务、索引、存储过程等核心场景，贴近实际开发需求：</p>
<h4 id="1、表结构设计案例"><a href="#1、表结构设计案例" class="headerlink" title="1、表结构设计案例"></a>1、表结构设计案例</h4><h5 id="1-1-基础表设计（用户表-订单表，含主键、外键、约束）"><a href="#1-1-基础表设计（用户表-订单表，含主键、外键、约束）" class="headerlink" title="1.1 基础表设计（用户表+订单表，含主键、外键、约束）"></a>1.1 基础表设计（用户表+订单表，含主键、外键、约束）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户表（基础信息）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID（主键）&#x27;</span>,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户名（唯一）&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `age` TINYINT <span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">120</span>) COMMENT <span class="string">&#x27;年龄（0-120校验）&#x27;</span>,</span><br><span class="line">  `create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  INDEX idx_phone (`phone`)  <span class="comment">-- 手机号索引（加速查询）</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT <span class="string">&#x27;用户信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单表（关联用户表，含外键）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">order</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">  `order_no` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;关联用户ID&#x27;</span>,</span><br><span class="line">  `amount` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;订单金额&#x27;</span>,</span><br><span class="line">  `status` TINYINT <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态（0-待支付，1-已支付）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  INDEX idx_user_id (`user_id`),  <span class="comment">-- 关联查询索引</span></span><br><span class="line">  <span class="comment">-- 外键约束（订单必须属于存在的用户）</span></span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2、CRUD-核心操作案例"><a href="#2、CRUD-核心操作案例" class="headerlink" title="2、CRUD 核心操作案例"></a>2、CRUD 核心操作案例</h4><h5 id="2-1-插入数据（单条-批量）"><a href="#2-1-插入数据（单条-批量）" class="headerlink" title="2.1 插入数据（单条+批量）"></a>2.1 插入数据（单条+批量）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单条插入</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>` (username, phone, age) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;13100001111&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量插入（高效，减少IO）</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">order</span>` (order_no, user_id, amount, status) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">  (<span class="string">&#x27;20231001001&#x27;</span>, <span class="number">1</span>, <span class="number">99.99</span>, <span class="number">0</span>),</span><br><span class="line">  (<span class="string">&#x27;20231001002&#x27;</span>, <span class="number">1</span>, <span class="number">199.50</span>, <span class="number">1</span>),</span><br><span class="line">  (<span class="string">&#x27;20231001003&#x27;</span>, <span class="number">2</span>, <span class="number">299.00</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h5 id="2-2-查询数据（基础-关联-聚合）"><a href="#2-2-查询数据（基础-关联-聚合）" class="headerlink" title="2.2 查询数据（基础+关联+聚合）"></a>2.2 查询数据（基础+关联+聚合）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基础查询（带条件+排序）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username, age </span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">30</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关联查询（用户+订单，统计用户总消费）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  u.id, u.username, </span><br><span class="line">  <span class="built_in">COUNT</span>(o.id) <span class="keyword">AS</span> order_count,  <span class="comment">-- 订单总数</span></span><br><span class="line">  <span class="built_in">SUM</span>(o.amount) <span class="keyword">AS</span> total_amount  <span class="comment">-- 总消费</span></span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `<span class="keyword">order</span>` o <span class="keyword">ON</span> u.id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> u.id, u.username</span><br><span class="line"><span class="keyword">HAVING</span> total_amount <span class="operator">&gt;</span> <span class="number">0</span>;  <span class="comment">-- 筛选有消费的用户</span></span><br></pre></td></tr></table></figure>



<h5 id="2-3-更新与删除（带条件-限制）"><a href="#2-3-更新与删除（带条件-限制）" class="headerlink" title="2.3 更新与删除（带条件+限制）"></a>2.3 更新与删除（带条件+限制）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新（安全更新，带WHERE条件）</span></span><br><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` </span><br><span class="line"><span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span>, amount <span class="operator">=</span> amount  <span class="number">1.05</span>  <span class="comment">-- 支付成功，金额加5%</span></span><br><span class="line"><span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;20231001001&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除（逻辑删除，而非物理删除，保留数据）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> is_delete TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否删除（0-否，1-是）&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">user</span>` <span class="keyword">SET</span> is_delete <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">-- 标记删除</span></span><br></pre></td></tr></table></figure>



<h4 id="3、事务与锁案例"><a href="#3、事务与锁案例" class="headerlink" title="3、事务与锁案例"></a>3、事务与锁案例</h4><h5 id="3-1-事务控制（转账场景，确保原子性）"><a href="#3-1-事务控制（转账场景，确保原子性）" class="headerlink" title="3.1 事务控制（转账场景，确保原子性）"></a>3.1 事务控制（转账场景，确保原子性）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账：用户1向用户2转100元（需关联账户表）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `account` (id <span class="type">INT</span>, user_id <span class="type">INT</span>, balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>), <span class="keyword">PRIMARY KEY</span>(id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;  <span class="comment">-- 开启事务</span></span><br><span class="line"><span class="comment">-- 步骤1：检查转出账户余额</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> `account` <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment">-- 加排他锁，防止并发修改</span></span><br><span class="line"><span class="comment">-- 步骤2：扣减转出账户</span></span><br><span class="line"><span class="keyword">UPDATE</span> `account` <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 步骤3：增加转入账户</span></span><br><span class="line"><span class="keyword">UPDATE</span> `account` <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 无异常则提交</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 若出错，回滚（如余额不足）</span></span><br><span class="line"><span class="comment">-- ROLLBACK;</span></span><br></pre></td></tr></table></figure>



<h4 id="4、索引与性能优化案例"><a href="#4、索引与性能优化案例" class="headerlink" title="4、索引与性能优化案例"></a>4、索引与性能优化案例</h4><h5 id="4-1-索引设计（联合索引-最左前缀原则）"><a href="#4-1-索引设计（联合索引-最左前缀原则）" class="headerlink" title="4.1 索引设计（联合索引+最左前缀原则）"></a>4.1 索引设计（联合索引+最左前缀原则）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为订单表创建联合索引（优化多条件查询）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_status <span class="keyword">ON</span> `<span class="keyword">order</span>`(user_id, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有效利用索引的查询（符合最左前缀）</span></span><br><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">FROM</span> `<span class="keyword">order</span>` </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">-- 命中联合索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引失效的查询（跳过左列）</span></span><br><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">FROM</span> `<span class="keyword">order</span>` </span><br><span class="line"><span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">-- 未使用联合索引（未匹配user_id）</span></span><br></pre></td></tr></table></figure>



<h4 id="5、存储过程与触发器案例"><a href="#5、存储过程与触发器案例" class="headerlink" title="5、存储过程与触发器案例"></a>5、存储过程与触发器案例</h4><h5 id="5-1-存储过程（批量生成测试数据）"><a href="#5-1-存储过程（批量生成测试数据）" class="headerlink" title="5.1 存储过程（批量生成测试数据）"></a>5.1 存储过程（批量生成测试数据）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入N条随机用户数据</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> batch_insert_user(<span class="keyword">IN</span> n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">-- 关闭自动提交，提升效率</span></span><br><span class="line">  WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">    <span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>` (username, phone, age)</span><br><span class="line">    <span class="keyword">VALUES</span> (</span><br><span class="line">      CONCAT(<span class="string">&#x27;user_&#x27;</span>, <span class="built_in">FLOOR</span>(RAND()<span class="number">100000</span>)),  <span class="comment">-- 随机用户名</span></span><br><span class="line">      CONCAT(<span class="string">&#x27;131&#x27;</span>, <span class="built_in">FLOOR</span>(RAND()<span class="number">10000000</span>)),  <span class="comment">-- 随机手机号</span></span><br><span class="line">      <span class="built_in">FLOOR</span>(RAND()<span class="number">80</span> <span class="operator">+</span> <span class="number">18</span>)  <span class="comment">-- 18-98岁随机年龄</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">END</span> WHILE;</span><br><span class="line">  <span class="keyword">COMMIT</span>;  <span class="comment">-- 批量提交</span></span><br><span class="line">  <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用：插入1000条测试数据</span></span><br><span class="line"><span class="keyword">CALL</span> batch_insert_user(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="5-2-触发器（数据校验-自动维护）"><a href="#5-2-触发器（数据校验-自动维护）" class="headerlink" title="5.2 触发器（数据校验+自动维护）"></a>5.2 触发器（数据校验+自动维护）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入订单时，自动校验金额必须&gt;0</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> check_order_amount </span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  IF NEW.amount <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">    SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> </span><br><span class="line">    <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;订单金额必须大于0&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h4 id="6、分页与高级查询案例"><a href="#6、分页与高级查询案例" class="headerlink" title="6、分页与高级查询案例"></a>6、分页与高级查询案例</h4><h5 id="6-1-分页查询（避免一次性加载大量数据）"><a href="#6-1-分页查询（避免一次性加载大量数据）" class="headerlink" title="6.1 分页查询（避免一次性加载大量数据）"></a>6.1 分页查询（避免一次性加载大量数据）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分页查询第3页数据（每页20条）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username, phone </span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">WHERE</span> is_delete <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">40</span>, <span class="number">20</span>;  <span class="comment">-- 偏移量=（页码-1）每页条数</span></span><br></pre></td></tr></table></figure>

<h5 id="6-2-窗口函数（排名统计，MySQL-8-0-）"><a href="#6-2-窗口函数（排名统计，MySQL-8-0-）" class="headerlink" title="6.2 窗口函数（排名统计，MySQL 8.0+）"></a>6.2 窗口函数（排名统计，MySQL 8.0+）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按用户消费金额排名（降序）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  u.username,</span><br><span class="line">  <span class="built_in">SUM</span>(o.amount) <span class="keyword">AS</span> total_amount,</span><br><span class="line">  <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(o.amount) <span class="keyword">DESC</span>) <span class="keyword">AS</span> rnk  <span class="comment">-- 排名（相同金额并列）</span></span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">JOIN</span> `<span class="keyword">order</span>` o <span class="keyword">ON</span> u.id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> u.id, u.username;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ningxiu2978.github.io">NINGXIU</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ningxiu2978.github.io/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/">https://ningxiu2978.github.io/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ningxiu2978.github.io" target="_blank">NINGXIU's 学习博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/18/Linux%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Linux面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux面试题</div></div><div class="info-2"><div class="info-item-1">理论基础1、面Linux系统比Windows系统好在哪里？其它问法： 你为什么选择学习Linux？你觉得企业为什么选择Linux系统？而不选择Windows系统？ 1234567891011Linux开源，并且大多数的发行版本免费，其中甚至包括了部分企业级的服务器版本。同时由于开源的特性，其安全问题会更透明，社区能够快速的发现并修复漏洞，整体安全性较高，在服务器场景中往往有更好的表现。另一方面，其开源特性使得有更丰富的版本选择，可以根据不同的需求进行剪裁和定制。在多用户多任务方面，Linux支持多用户同时登录并执行各自的任务，同时权限管理严格，资源分配合理。而且因为可以选择舍弃图形化界面，使得其资源占用更低。当然，Windows也不是没有优势的，其在图形化界面、办公软件的兼容性、游戏的支持上就比Linux好得多。  扩展：   我们常说的开源免费并不是同一个概念：开源：软件产品的源代码对公众开放，任何人都可以查看、使用、修改以及分发其源代码。免费：可以自由的运行程序、自由的学习并修改程序、自由的复制并向他人分发软件副本、自由的发行修改版。但是这并不意味着开源软件必须免费，如：Re...</div></div></div></a><a class="pagination-related" href="/2025/09/18/Oracle%E7%AC%94%E8%AE%B0(%E6%80%BB)/" title="Oracle笔记(总)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Oracle笔记(总)</div></div><div class="info-2"><div class="info-item-1">数据库介绍1、数据库介绍1.1 数据库英文：Database 简单的说，数据库就是一个存放数据的仓库，在日常工作中，常常需要把相关的数据放进这样的仓库，并根据管理的需要进行相应处理。 1.2 数据库规范数据库中的数据都有一定规律结构，相同类型的数据放在一起，不同类型的数据之间相互隔离 数据库由统一的规则来读写：由SQL语言专门来读写数据库，一般都是由程序来读写数据库内容 1.3 常用数据库常用的数据库有：DB2、Oracle、Mysql、SQL server、SQLite 1.4 数据库分类根据存储模型可以将数据库划分为【关系型数据库】和【非关系型数据库】 关系型数据库：是建立在关系模型基础上的数据库，简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。 标准数据查询语言SQL就是一种基于关系型数据库的语言，这种语言执行对关系型数据库中数据的检索和操作 什么是二维表：有行有列的表格，例如 Excel 关系型数据库（表与表之间有关系：体现为主外键）    分类 产品 特点    小型 access、foxbase 负载量小，用户...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%80%BB)/" title="MySQl学习笔记(总)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">MySQl学习笔记(总)</div></div><div class="info-2"><div class="info-item-1">数据库（DataBase）：数据库(简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。 数据库中存储的基本对象是数据(Data)数据库的基本特点：永久存储、有组织、可共享 数据库管理系统（DataBase Management System）：DBMS，位于用户与操作系统之间的一层数据管理软件。（是系统软件，是数据库系统的核心） 主要功能：  数据定义功能 数据组织、存储和管理 数据操纵功能（插入、删除、修改和查询） 数据库的事务管理和运行管理 数据库的建立和维护功能(实用程序) 其它功能（异构数据库之间的互访等）  数据库系统（DataBase System） 数据库系统（DBS）： 计算机系统中引入数据库后的系统构成 数据库系统的构成：由数据库、数据库管理系统、应用系统、应用开发工具、用户、应用程序员、数据库管理员（Database Administrator，DBA）等组成 。  数据库分类： 关系型数据库(RDBMS)：关系型数据库，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。  特点： 使用表存储数据，格式统一(行列），便于维护 使用SQ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">NINGXIU</div><div class="author-info-description">天生我材必有用，千金散尽还复来。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NingXIU2978"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/NingXIU2978" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/georgelester10611@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客,欢迎各位大佬莅临！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0728"><span class="toc-number">1.</span> <span class="toc-text">0728</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.数据库的分类有哪些？（谈谈你知道的数据库？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sql%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F%EF%BC%88%E5%88%86%E5%88%AB%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2.sql的分类？（分别是做什么的、关键字？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%97%E4%B8%BEmysql%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%88%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3.列举mysql常用的数据类型？（场景应用说明）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4drop%EF%BC%8Ctruncate%EF%BC%8Cdelete%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4.说说drop，truncate，delete的作用和区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%86%99%E5%87%BADDL%E5%92%8CDML%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%A2%9E%E5%88%A0%E6%94%B9%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">5、写出DDL和DML语句中增删改的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-DDL"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 DDL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-DML"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 DML</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0729"><span class="toc-number">2.</span> <span class="toc-text">0729</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8Csql-%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E6%AE%B5%E5%8F%96%E5%88%AB%E5%90%8D%EF%BC%8C"><span class="toc-number">2.1.</span> <span class="toc-text">1，sql 中如何给字段取别名，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">（有几种方式，分别在什么场景下使用？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8Cdistinct-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2，distinct 关键字的作用是什么？（如何使用？需要注意什么）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8Cwhere-%E5%AD%90%E5%8F%A5%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">3，where 子句种常见的运算符有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8Clike-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">4，like 模糊查询用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%8C%E5%88%97%E4%B8%BE%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%9F%E8%AF%B4%E5%87%BA%E6%AF%8F%E4%B8%AA%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">5，列举聚合函数？说出每个聚合函数的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%8Chaving-%E5%92%8C-where-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">6，having 和 where 的区别，使用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%EF%BC%8Corder-by-%E5%AD%90%E5%8F%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%EF%BC%9B"><span class="toc-number">2.8.</span> <span class="toc-text">7，order by 子句如何实现多字段排序；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81order-by-%E5%92%8C-group-by-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">8、order by 和 group by 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%EF%BC%8Cmysql-%E4%B8%AD%EF%BC%8Climit-%E5%AD%90%E5%8F%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9F%E8%B0%88%E8%B0%88%E5%AE%83%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.10.</span> <span class="toc-text">9，mysql 中，limit 子句如何实现分页查询？谈谈它的参数的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">SQL函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81sql-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-null-%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">1、sql 中如何处理 null 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E8%AF%B4-if-%E5%92%8C-case-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2、说说 if 和 case 函数的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%88%97%E4%B8%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3、列举常用的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E"><span class="toc-number">4.</span> <span class="toc-text">主键自增</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E"><span class="toc-number">4.1.</span> <span class="toc-text">1.MySQL中如何设置主键自增?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">5.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.1.</span> <span class="toc-text">2.数据库的约束有哪些?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.</span> <span class="toc-text">内外连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.1.</span> <span class="toc-text">3.内连接、外连接的区别有哪些?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%8C%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1、什么是视图，说一说视图的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%E5%9F%BA%E8%A1%A8%E8%A6%81%E6%BB%A1%E8%B6%B3%E4%BB%80%E4%B9%88%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2.通过视图更新基表要满足什么条件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.3.</span> <span class="toc-text">3、视图和表的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE%E5%92%8C%E6%9F%A5%E8%AF%A2%E5%9F%BA%E8%A1%A8%EF%BC%8C%E8%B0%81%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">4、查询视图和查询基表，谁的效率高，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%A7%86%E5%9B%BE%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C-INSERT%E3%80%81UPDATE-%E6%88%96-DELETE-%E6%93%8D%E4%BD%9C%EF%BC%9F%E8%87%B3%E5%B0%91%E5%88%97%E4%B8%BE-3-%E7%A7%8D"><span class="toc-number">7.5.</span> <span class="toc-text">5、哪些情况下，视图无法直接执行 INSERT、UPDATE 或 DELETE 操作？至少列举 3 种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%9F%90%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E9%A2%91%E7%B9%81%E6%9F%A5%E8%AF%A2-%E2%80%9C%E8%BF%91-30-%E5%A4%A9%E5%B7%B2%E4%BB%98%E6%AC%BE%E7%9A%84%E8%AE%A2%E5%8D%95%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%95%86%E5%93%81%E5%90%8D%E7%A7%B0%E2%80%9D%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E7%94%A8%E8%A7%86%E5%9B%BE%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">6、某电商系统需要频繁查询 “近 30 天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">1.什么是存储过程？存储过程优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">2.说一下存储过程的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E3%80%81%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">4.说一说系统变量、用户变量和局部变量的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%97%B6%EF%BC%8CBEGIN-END%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E6%9D%A1-SQL-%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">5、创建存储过程时，BEGIN...END块的作用是什么？如果存储过程只有一条 SQL 语句，是否可以省略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E5%8F%A5%EF%BC%9F%E8%8B%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%9C%89-OUT-%E5%8F%82%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%85%B6%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">6、 调用存储过程使用什么语句？若存储过程有 OUT 参数，如何获取其返回值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81MySQL-%E4%B8%AD%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%88%E5%A6%82-SQL-%E8%AF%AD%E5%8F%A5%EF%BC%89%EF%BC%9F%E8%8B%A5%E4%B8%8D%E8%83%BD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-%E2%80%9C%E4%BF%AE%E6%94%B9%E2%80%9D-%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">7、MySQL 中能否直接修改存储过程的逻辑（如 SQL 语句）？若不能，如何实现 “修改” 效果？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4%E6%88%90%E6%9C%AC%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">8.7.</span> <span class="toc-text">8、 为什么说存储过程可能增加数据库维护成本？请举例说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%9F%90%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81-%E2%80%9C%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7-ID-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E5%85%B6%E6%89%80%E6%9C%89%E8%AE%A2%E5%8D%95%E5%8F%8A%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E2%80%9D%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">9、某系统需要 “根据用户 ID 批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%A6%82BEGIN-TRANSACTION%E3%80%81COMMIT%EF%BC%89%EF%BC%9F%E8%AF%B7%E8%AF%B4%E6%98%8E%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.9.</span> <span class="toc-text">10、 存储过程中能否使用事务控制语句（如BEGIN TRANSACTION、COMMIT）？请说明原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">9.</span> <span class="toc-text">游标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87%EF%BC%8C%E8%AF%B4%E8%AF%B4%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">1. 什么是游标，说说它的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B8%B8%E6%A0%87%E5%92%8C%E6%99%AE%E9%80%9A-select-%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">2. 游标和普通 select 查询的核心区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.3.</span> <span class="toc-text">3. 使用游标的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8D%E9%80%82%E5%90%88%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">4. 什么场景适合使用游标，什么场景不适合？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-MySQL-%E4%B8%AD3%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">10.1.</span> <span class="toc-text">5. MySQL 中3种常见异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-MySQL-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">6. MySQL 中异常处理的两种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.</span> <span class="toc-text">存储函数和存储过程的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%EF%BC%9F%E5%85%B6%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">1、什么是存储函数？其核心特征是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">存储函数特性选项说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">2、存储函数为什么必须有返回值？如何指定返回值类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%9C%A8%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">3、存储函数与存储过程在参数类型上有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%9F%EF%BC%88%E5%A6%82SELECT-FROM-%E8%A1%A8%EF%BC%89%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.6.</span> <span class="toc-text">4、存储函数能否直接返回结果集？（如SELECT * FROM 表）？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BE%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E4%B8%9A%E5%8A%A1%E4%BE%8B%E5%AD%90%E3%80%82"><span class="toc-number">11.7.</span> <span class="toc-text">5、什么场景适合使用存储函数？举一个实际业务例子。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F%E8%AF%B7%E5%86%99%E5%87%BA%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">11.8.</span> <span class="toc-text">6、存储函数中如何主动抛出异常？请写出核心代码。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8CDETERMINISTIC%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.9.</span> <span class="toc-text">7、创建存储函数时，DETERMINISTIC特性的作用是什么？默认值是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">12.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9F%E5%85%B6%E2%80%9C%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E2%80%9D%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">1、什么是触发器？其“自动触发”的核心条件是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84BEFORE%E5%92%8CAFTER%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E6%9C%89%E4%BD%95%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">2、触发器的BEFORE和AFTER触发时机有何本质区别？分别适用于什么场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E4%B8%ADNEW%E5%92%8COLD%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%86%E5%88%AB%E5%9C%A8%E5%93%AA%E4%BA%9B%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%8F%AF%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">3、触发器中NEW和OLD关键字的作用是什么？分别在哪些触发事件中可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E8%83%BD%E5%90%A6%E4%BF%AE%E6%94%B9%E8%87%AA%E8%BA%AB%E5%85%B3%E8%81%94%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">4、触发器能否修改自身关联表的数据？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9F%E4%B8%BE%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E4%B8%9A%E5%8A%A1%E4%BE%8B%E5%AD%90%E3%80%82"><span class="toc-number">12.5.</span> <span class="toc-text">5、什么场景适合使用触发器？举一个实际业务例子。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">6、触发器与存储过程的核心区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%9F%90%E5%BC%A0%E8%A1%A8%E5%85%B3%E8%81%94%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">7、如何查看某张表关联的所有触发器？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88MySQL%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">定时任务（MySQL事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMySQL%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%89%EF%BC%9F%E5%85%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%90%AF%E7%94%A8MySQL%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%B4%E6%97%B6%E5%92%8C%E6%B0%B8%E4%B9%85%E6%96%B9%E5%BC%8F%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">2、启用MySQL事件调度器的临时和永久方式分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81MySQL%E4%BA%8B%E4%BB%B6%E6%94%AF%E6%8C%81%E5%93%AA%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%88%86%E5%88%AB%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">13.3.</span> <span class="toc-text">3、MySQL事件支持哪两种触发模式？分别用什么语法定义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8CON-COMPLETION-PRESERVE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.4.</span> <span class="toc-text">4、创建定时任务时，ON COMPLETION PRESERVE的作用是什么？默认行为是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%80%82%E5%90%88%E5%A4%84%E7%90%86%E5%93%AA%E4%BA%9B%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%B8%8D%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">13.5.</span> <span class="toc-text">5、定时任务适合处理哪些业务场景？不适合哪些场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%A6%82%E4%BD%95%E6%9A%82%E5%81%9C%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-number">13.6.</span> <span class="toc-text">6、如何暂停一个正在运行的定时任务？如何彻底删除？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">14.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">14.1.</span> <span class="toc-text">1、说说事务的四大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">14.2.</span> <span class="toc-text">2、说说事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F%E8%AF%B7%E7%94%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E7%B1%BB%E6%AF%94%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-number">14.3.</span> <span class="toc-text">3、什么是事务？请用生活中的例子类比事务的核心特性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%E4%B8%AD%EF%BC%8C%E2%80%9D%E5%8E%9F%E5%AD%90%E6%80%A7%E2%80%9D%E5%92%8C%E2%80%9D%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D%E5%88%86%E5%88%AB%E4%BE%9D%E8%B5%96MySQL%E7%9A%84%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%AD%EF%BC%8C%E2%80%9D%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%88RC%EF%BC%89%E2%80%9D%E5%92%8C%E2%80%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88RR%EF%BC%89%E2%80%9D%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FMySQL%E7%9A%84InnoDB%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-number">14.5.</span> <span class="toc-text">5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E8%84%8F%E8%AF%BB%E2%80%9D%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%81%BF%E5%85%8D%E8%84%8F%E8%AF%BB%EF%BC%9F"><span class="toc-number">14.6.</span> <span class="toc-text">6、什么是”脏读”？如何通过隔离级别避免脏读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">14.7.</span> <span class="toc-text">7、事务的并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E9%95%BF%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%95%BF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">14.8.</span> <span class="toc-text">8、长事务有哪些风险？如何优化长事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E2%80%9D%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%9D%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E7%9A%84%E2%80%9D%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%9D%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.9.</span> <span class="toc-text">9、事务的”一致性”与数据库三范式的”一致性”有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%EF%BC%9F%E8%AF%B7%E5%86%99%E5%87%BA%E2%80%9C%E8%BD%AC%E8%B4%A6%E2%80%9D%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E3%80%82"><span class="toc-number">14.10.</span> <span class="toc-text">10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">数据库三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">1、什么是数据库设计三范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%EF%BC%9F%E5%85%B6%E6%A0%B8%E5%BF%83%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">2、什么是数据库范式？其核心目的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E2%80%9D%E4%B8%8D%E6%BB%A1%E8%B6%B31NF%E2%80%9D%E5%92%8C%E2%80%9D%E6%BB%A1%E8%B6%B31NF%E2%80%9D%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82"><span class="toc-number">15.3.</span> <span class="toc-text">3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89%E7%9A%84%E5%89%8D%E6%8F%90%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%B6%E6%A0%B8%E5%BF%83%E8%A6%81%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.4.</span> <span class="toc-text">4、 第二范式（2NF）的前提是什么？其核心要求是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89%E7%9A%84%E5%89%8D%E6%8F%90%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%B6%E6%A0%B8%E5%BF%83%E8%A6%81%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8E2NF%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.5.</span> <span class="toc-text">5、 第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%BB%A1%E8%B6%B3%E4%B8%89%E8%8C%83%E5%BC%8F%E7%9A%84%E8%A1%A8%E4%B8%80%E5%AE%9A%E6%98%AF%E2%80%9D%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E2%80%9D%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E2%80%9D%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96%E2%80%9D%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E8%AF%B7%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E2%80%9D%E4%B8%8D%E6%BB%A1%E8%B6%B3%E4%B8%89%E8%8C%83%E5%BC%8F%E2%80%9D%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E7%9A%84%E2%80%9D%E6%9B%B4%E6%96%B0%E5%BC%82%E5%B8%B8%E2%80%9D%E3%80%82"><span class="toc-number">15.7.</span> <span class="toc-text">7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">16.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9FMySQL%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">1、什么是存储引擎？MySQL中常见的存储引擎有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81InnoDB%E5%92%8CMyISAM%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">16.2.</span> <span class="toc-text">2、InnoDB和MyISAM的核心区别是什么？（高频考点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E6%98%AFMySQL%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-number">16.3.</span> <span class="toc-text">3、为什么InnoDB是MySQL的默认存储引擎？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Memory%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">16.4.</span> <span class="toc-text">4、Memory存储引擎的特点和适用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E8%AF%B4mysql-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">16.5.</span> <span class="toc-text">5、说说mysql 体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">16.6.</span> <span class="toc-text">6、存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">17.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">1、什么是索引？索引的核心作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">17.2.</span> <span class="toc-text">2、常见的索引类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">17.3.</span> <span class="toc-text">3、B+树索引的优势是什么？（高频考点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">17.4.</span> <span class="toc-text">4、聚簇索引和非聚簇索引的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E9%80%89%E5%8F%96%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">17.5.</span> <span class="toc-text">5、聚簇索引选取的规则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%B0%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.6.</span> <span class="toc-text">6、聚簇索引和二级索引谁的查询的效率高？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">17.7.</span> <span class="toc-text">7、哪些情况会导致索引失效？（高频考点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96sql%E6%9F%A5%E8%AF%A2"><span class="toc-number">17.8.</span> <span class="toc-text">8、如何使用索引优化sql查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E2%80%9C%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E2%80%9D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.9.</span> <span class="toc-text">9、联合索引的“最左前缀原则”是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%A4%A7%E9%87%8F%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">17.10.</span> <span class="toc-text">10、为什么不建议大量创建索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%BD%9C%E4%B8%BA%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">17.11.</span> <span class="toc-text">11、InnoDB为什么推荐使用自增主键作为聚簇索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="toc-number">17.12.</span> <span class="toc-text">12、主键索引原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%AE%A1%E7%90%86-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">18.</span> <span class="toc-text">mysql管理 常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%B8%B8%E8%A7%81%E7%9A%84mysql%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">18.1.</span> <span class="toc-text">举例说明常见的mysql管理工具，并说明作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="toc-number">19.</span> <span class="toc-text">数据库锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">19.1.</span> <span class="toc-text">1、数据库锁的核心作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81MySQL-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%88%E6%8C%89%E7%B2%92%E5%BA%A6-%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">2、MySQL 中有哪些锁类型？（按粒度&#x2F;类型分类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">19.3.</span> <span class="toc-text">3、行锁和表锁的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81InnoDB-%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%8C%E9%94%81%E5%BF%85%E9%A1%BB%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">19.4.</span> <span class="toc-text">4、InnoDB 的行锁是如何实现的？为什么行锁必须基于索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Lock%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">19.5.</span> <span class="toc-text">5、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-MVCC%EF%BC%9F%E5%AE%83%E5%A6%82%E4%BD%95%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">19.6.</span> <span class="toc-text">6、什么是 MVCC？它如何与锁机制协同工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81MySQL-%E6%AD%BB%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">19.7.</span> <span class="toc-text">7、MySQL 死锁的常见原因是什么？如何排查和解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">19.8.</span> <span class="toc-text">8、如何优化数据库锁的性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E9%94%81%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-number">19.9.</span> <span class="toc-text">9、事务隔离级别如何影响锁的行为？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-InnoDB-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88RR%EF%BC%89%E8%83%BD%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">19.10.</span> <span class="toc-text">10、为什么 InnoDB 的可重复读（RR）能防止幻读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%89%A7%E8%A1%8C-SELECT-FROM-table-WHERE-id-1-FOR-UPDATE-%E6%97%B6%EF%BC%8CInnoDB-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%EF%BC%9F"><span class="toc-number">19.11.</span> <span class="toc-text">11、执行 SELECT * FROM table WHERE id&#x3D;1 FOR UPDATE 时，InnoDB 加了什么锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E2%80%9C%E4%BF%AE%E6%94%B9%E4%B8%A2%E5%A4%B1%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">19.12.</span> <span class="toc-text">12、如何避免“修改丢失”问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E5%88%A4%E6%96%AD%E5%AF%B9%E9%94%99%E5%B9%B6%E8%AF%B4%E6%98%8E%E7%90%86%E7%94%B1%EF%BC%9A"><span class="toc-number">19.13.</span> <span class="toc-text">13、判断对错并说明理由：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88S-%E9%94%81%EF%BC%89%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88X-%E9%94%81%EF%BC%89%E7%9A%84%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%93%AA%E4%BA%9B-SQL-%E6%93%8D%E4%BD%9C%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BF%99%E4%B8%A4%E7%A7%8D%E9%94%81%E3%80%82"><span class="toc-number">19.14.</span> <span class="toc-text">14、共享锁（S 锁）和排他锁（X 锁）的兼容规则是什么？举例说明哪些 SQL 操作会自动加这两种锁。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Lock%EF%BC%89%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-InnoDB-%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%A4%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="toc-number">19.15.</span> <span class="toc-text">15、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的触发条件是什么？为什么 InnoDB 需要这两种锁？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">20.</span> <span class="toc-text">经典代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">20.1.</span> <span class="toc-text">1、表结构设计案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%9F%BA%E7%A1%80%E8%A1%A8%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%94%A8%E6%88%B7%E8%A1%A8-%E8%AE%A2%E5%8D%95%E8%A1%A8%EF%BC%8C%E5%90%AB%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E7%BA%A6%E6%9D%9F%EF%BC%89"><span class="toc-number">20.1.1.</span> <span class="toc-text">1.1 基础表设计（用户表+订单表，含主键、外键、约束）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81CRUD-%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">20.2.</span> <span class="toc-text">2、CRUD 核心操作案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E6%9D%A1-%E6%89%B9%E9%87%8F%EF%BC%89"><span class="toc-number">20.2.1.</span> <span class="toc-text">2.1 插入数据（单条+批量）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%EF%BC%88%E5%9F%BA%E7%A1%80-%E5%85%B3%E8%81%94-%E8%81%9A%E5%90%88%EF%BC%89"><span class="toc-number">20.2.2.</span> <span class="toc-text">2.2 查询数据（基础+关联+聚合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4%EF%BC%88%E5%B8%A6%E6%9D%A1%E4%BB%B6-%E9%99%90%E5%88%B6%EF%BC%89"><span class="toc-number">20.2.3.</span> <span class="toc-text">2.3 更新与删除（带条件+限制）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-number">20.3.</span> <span class="toc-text">3、事务与锁案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%88%E8%BD%AC%E8%B4%A6%E5%9C%BA%E6%99%AF%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%89"><span class="toc-number">20.3.1.</span> <span class="toc-text">3.1 事务控制（转账场景，确保原子性）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B"><span class="toc-number">20.4.</span> <span class="toc-text">4、索引与性能优化案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-number">20.4.1.</span> <span class="toc-text">4.1 索引设计（联合索引+最左前缀原则）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">20.5.</span> <span class="toc-text">5、存储过程与触发器案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">20.5.1.</span> <span class="toc-text">5.1 存储过程（批量生成测试数据）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C-%E8%87%AA%E5%8A%A8%E7%BB%B4%E6%8A%A4%EF%BC%89"><span class="toc-number">20.5.2.</span> <span class="toc-text">5.2 触发器（数据校验+自动维护）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E9%A1%B5%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B"><span class="toc-number">20.6.</span> <span class="toc-text">6、分页与高级查询案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%81%BF%E5%85%8D%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">20.6.1.</span> <span class="toc-text">6.1 分页查询（避免一次性加载大量数据）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88%E6%8E%92%E5%90%8D%E7%BB%9F%E8%AE%A1%EF%BC%8CMySQL-8-0-%EF%BC%89"><span class="toc-number">20.6.2.</span> <span class="toc-text">6.2 窗口函数（排名统计，MySQL 8.0+）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/19/Git%E5%91%A8%E8%80%83%E5%A4%9A%E9%80%89&amp;%E7%AE%80%E7%AD%94_0919/" title="Git周考多选&amp;简答_0919">Git周考多选&amp;简答_0919</a><time datetime="2025-09-19T09:12:12.093Z" title="发表于 2025-09-19 17:12:12">2025-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/19/Git%E4%BD%9C%E4%B8%9A_0915/" title="Git作业_0915">Git作业_0915</a><time datetime="2025-09-19T07:58:53.222Z" title="发表于 2025-09-19 15:58:53">2025-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/" title="Web前端面试宝典">Web前端面试宝典</a><time datetime="2025-09-19T07:52:37.333Z" title="发表于 2025-09-19 15:52:37">2025-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/19/GIT%E5%9F%BA%E7%A1%80_/" title="GIT基础">GIT基础</a><time datetime="2025-09-19T06:55:30.645Z" title="发表于 2025-09-19 14:55:30">2025-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/19/%E5%8D%9A%E5%AE%A2%E6%9E%B6%E6%9E%84/" title="博客架构全景 (One-Page Cheatsheet)">博客架构全景 (One-Page Cheatsheet)</a><time datetime="2025-09-18T16:00:00.000Z" title="发表于 2025-09-19 00:00:00">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By NINGXIU</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>