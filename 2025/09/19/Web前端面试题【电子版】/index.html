<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Web前端面试宝典 | NINGXIU's 学习博客</title><meta name="author" content="NINGXIU"><meta name="copyright" content="NINGXIU"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Web前端面试宝典[TOC] resume部分1. 自我介绍一面试官好，我叫XXX，有半年前端开发实习经验。目前主要用Vue框架做项目，最近也在学React框架准备进行项目开发。在之前公司参与过3个实际的项目，其中一个让我特别有成就感—就是采用uni-app开发了一个电商app并且已经上线。 技术能力部分：日常工作中我主要做这些事：  用Vue开发页面，把重复的功能做成可复用的组件 优化项目打包速">
<meta property="og:type" content="article">
<meta property="og:title" content="Web前端面试宝典">
<meta property="og:url" content="https://ningxiu2978.github.io/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/index.html">
<meta property="og:site_name" content="NINGXIU&#39;s 学习博客">
<meta property="og:description" content="Web前端面试宝典[TOC] resume部分1. 自我介绍一面试官好，我叫XXX，有半年前端开发实习经验。目前主要用Vue框架做项目，最近也在学React框架准备进行项目开发。在之前公司参与过3个实际的项目，其中一个让我特别有成就感—就是采用uni-app开发了一个电商app并且已经上线。 技术能力部分：日常工作中我主要做这些事：  用Vue开发页面，把重复的功能做成可复用的组件 优化项目打包速">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ningxiu2978.github.io/images/default_cover7.jpg">
<meta property="article:published_time" content="2025-09-19T07:52:37.333Z">
<meta property="article:modified_time" content="2025-09-19T07:53:44.385Z">
<meta property="article:author" content="NINGXIU">
<meta property="article:tag" content="NINGXIU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ningxiu2978.github.io/images/default_cover7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Web前端面试宝典",
  "url": "https://ningxiu2978.github.io/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/",
  "image": "https://ningxiu2978.github.io/images/default_cover7.jpg",
  "datePublished": "2025-09-19T07:52:37.333Z",
  "dateModified": "2025-09-19T07:53:44.385Z",
  "author": [
    {
      "@type": "Person",
      "name": "NINGXIU",
      "url": "https://ningxiu2978.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://ningxiu2978.github.io/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":-1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Web前端面试宝典',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://pic1.imgdb.cn/item/65578a9fc458853aef80544a.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/default_cover7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">NINGXIU's 学习博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Web前端面试宝典</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Web前端面试宝典</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-19T07:52:37.333Z" title="发表于 2025-09-19 15:52:37">2025-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-19T07:53:44.385Z" title="更新于 2025-09-19 15:53:44">2025-09-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">42.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>136分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Web前端面试宝典"><a href="#Web前端面试宝典" class="headerlink" title="Web前端面试宝典"></a>Web前端面试宝典</h1><p>[TOC]</p>
<h2 id="resume部分"><a href="#resume部分" class="headerlink" title="resume部分"></a>resume部分</h2><h3 id="1-自我介绍一"><a href="#1-自我介绍一" class="headerlink" title="1. 自我介绍一"></a>1. 自我介绍一</h3><p>面试官好，我叫<code>XXX</code>，有半年前端开发实习经验。目前主要用<code>Vue</code>框架做项目，最近也在学<code>React</code>框架准备进行项目开发。在之前公司参与过<code>3</code>个实际的项目，其中一个让我特别有成就感—就是采用<code>uni-app</code>开发了一个电商<code>app</code>并且已经上线。</p>
<p><strong>技术能力部分：</strong><br>日常工作中我主要做这些事：</p>
<ol>
<li>用<code>Vue</code>开发页面，把重复的功能做成可复用的组件</li>
<li>优化项目打包速度（之前有个项目打包要<code>3</code>分钟，优化后只要<code>40</code>秒）</li>
<li>和后台同事配合调接口，处理数据展示和性能问题</li>
<li>用<code>Git</code>管理代码，每周都会写技术总结，记录遇到的问题和解决方法</li>
</ol>
<p><strong>未来规划：</strong><br>现在除了继续深耕<code>Vue</code>，我在学前端工程化相关的东西，比如自动化测试和持续集成。希望未来能参与更复杂的项目，成为既懂业务又会技术优化的全流程开发者。</p>
<h3 id="2-自我介绍二"><a href="#2-自我介绍二" class="headerlink" title="2. 自我介绍二"></a>2. 自我介绍二</h3><p>面试官好，我是计算机专业的面试者<code>XXX</code>，我此次应聘的职位是<code>web</code>前端开发工程师，这份工作不仅与我的专业对口，同时也是我的特长与兴趣所在。现在我就从以下三个方面介绍自己：</p>
<p>​	<strong>学习能力：</strong> 我具备快速将新技术落地到项目的能力，当前主要技术栈为：</p>
<p>​	核心开发：基于<code>Vue3+TypeScript</code>完成过电商管理后台开发，独立封装<code>10</code>个高复用业务组件</p>
<p>​	工程实践：在小程序开发中采用<code>uni-app</code>跨端方案，实现核心代码复用率<code>85%</code></p>
<p>​	**持续成长：**正在通过开源项目深入<code>React</code>技术栈，使用<code>React Router v6</code>实现动态路由分割，结合代码分割技术，将<code>SPA</code>应用首屏加载速度提升<code>35%</code></p>
<p>​	**实践能力：**我的专长是软件开发，我希望能从事这方面的工作经验，并且我曾经发过多个系统，如校园考试系统，电商中后台管理系统等等。</p>
<p>​	**交际能力：**我的性格沉稳，能坐得住，对<code>IT</code>行业的工作，具有非常好的适应能力，而且为人谦和，具有很强的组织和协调能力，富有的事业心和责任感使我能够面对任何困难和挑战。</p>
<p>​	从以上的简单自我介绍，我希望公司能给我一个展示自己能力的机会，让我我可以学以致用，同时我也很欣赏<code>XX</code>公司的企业文化与工作环境。我愿意成为企业一员，为企业的发展贡献自己的一份力量。我的职业生涯目标是，做一个既懂技术，又懂业务的复合型人才。</p>
<h3 id="3-自我介绍三"><a href="#3-自我介绍三" class="headerlink" title="3. 自我介绍三"></a>3. 自我介绍三</h3><p>我叫<code>XXX</code>，来自于南昌理工计算机软件工程专业。从考入大学那天起我一直努力学习，在大学生活中培养了良好的学习习惯，所学的课程包括了从计算机的基础知识到运用等许多方面。通过对这些知识的学习，我对这个领域的相关知识有了一定程度的理解和掌握。并做了大量的实践，进一步加深了对计算机的认识。在学好基础知识的同时还注重多方面全面发展，多次参加了学校的各种活动，在实习过程中将理论与实践结合起来，深受学校老师和同学的欢迎。</p>
<p>​	大学生涯中，我吸取了丰富的专业知识并锻炼了自己的能力。通过大学里的苦读，我掌握了<code>c</code>语言，汇编语言，编译原理，<code>powerbuilder</code>，数据库原理， 并对<code>c++v</code>，<code>c++</code>，<code>windows</code> 编程等有一定了解。课外我还自学了<code>delphi</code>编程，<code>asp</code>动态网页及<code>flash</code>动画，并在大二下学期获得“数据库”考试证书。</p>
<p>​	随着知识经济的诞生，社会将更加需要“专业突出，素质全面”的复合性 人才 。因此，课外我还积极投身于各种班级、学院及社交活动。从不同层次、不同角度锻炼自己，自己的组织、管理能力及团队合作精神有很大提高。</p>
<p>​	回顾大学几年来，我学到的最有用的知识是：自信与自学！体会最深的一句话就是：天下无难事，只怕有心人!</p>
<h3 id="4-自我介绍四"><a href="#4-自我介绍四" class="headerlink" title="4. 自我介绍四"></a>4. 自我介绍四</h3><p>​	你好，我叫<code>XXX</code>，我的上一家公司是做<code>XXX</code>。所以我们公司做的项目都是和<code>XXX</code>相关的。</p>
<p>​	刚进公司的那时候，什么交互啊，项目需求，测试，代码编写，优化，我都有是积极的参与，因为是新人，所以好好把握住每个学习的机会，我的本职工作，前端这块，我都是认真负责完成。那时候虽然很忙，压力很大，但真的是学到了不少东西，后期项目都不断的在完善，我也不断的在参与。</p>
<p>​	在上一家公司中，我最的收获不单单是技术方面，主要还有业务能力，自学能力和同事的沟通能力，这都是我学到的，而且我认为很重要的.。</p>
<p>​	技术方面我一直从事于<code>web</code>方面的工作，掌握的前端技术有<code>html5 &amp; css3</code>、<code>js</code>、<code>vue</code>、<code>小程序</code>等，同时我也了解<code>java</code>语言和数据库表结构这块，跟后台人员能更有效的沟通。</p>
<p>​	我的性格方面不算外向，也不算内向，跟朋友，同事相处，比较外向，在工作中，代码开发时，我是比较内向的，我喜欢全心全意的投入工作中。我也喜欢交朋友，偶尔跟朋友聚聚，聊聊。对于工作我总是抱着认真负责，有责任心，吃苦耐劳的态度工作。</p>
<p>​	谢谢，以上是我的自我介绍。</p>
<h3 id="5-自我介绍五"><a href="#5-自我介绍五" class="headerlink" title="5. 自我介绍五"></a>5. 自我介绍五</h3><p>​	面试官：</p>
<p>​	您好！</p>
<p>​	我叫<code>XXX</code>，您可能会联想起琼瑶小说，字的确就是那两个字，差别就是人没有那么美丽，呵呵。其实，我的同学更都喜爱称呼我的英文名字，叫<code>june</code>，六月的意思，是君的谐音。</p>
<p>　　我来自广东的市，可能您没有去过，是一个很小的县级市，这几年刚刚开发了温泉业，我想将来会有更多的.人了解这个小城市。</p>
<p>　　在<code>20xx</code>年我以恩平市全市第一名的成果考上了中山高校，学的是计算机科学专业。不过，在中大，我没法再像高中一样总是名列前茅了，到目前为止，我的综合学分排名是<code>40%</code>左右。在专业课程方面，我<code>c++</code>的编程力量比较强，一年以前就开头自学<code>java</code>，在班级里是最早开头学<code>java</code>的。</p>
<p>　　我参加过我们老师领导的一个项目，叫做lan谈天室，我负责开发了其中的准时通信系统的编写。在我们班，老师只选择了我一个女生参加这个项目，主要是我写程序的效率比较高，态度也特别仔细。(点评：假如你的编程力量不如男生强，至少你要告知面试官，我比多数女生要强。假如贵公司考虑选择一名女生，那么，选择我吧!)</p>
<p>　　除了学习和项目实习以外，我在同学会工作了两年，第一年做干事，其次年被提升为秘书长。大家对我的评价是考虑问题很周全，令人放心。</p>
<p>　　在我的求职清单上，<code>ibm</code>是我的首选单位，缘由和您面试过的许多同学都一样，出于对大品牌的信任。究竟，大品牌公司意味着许多我们需要的东西，比如培训和薪资，能和优秀的高素养的人在一起工作等等。</p>
<p>　　技术支持工程师也刚好是我的首选职位，由于我有技术背景，也有作为女性和和客户沟通的自然 优势。还有，我不担忧频繁出差，由于我身体素养很好，我已经坚持晨跑两年多了。在<code>ibm</code>专业技术方面，我信任公司的培训体系和我自己的快速学习力量!盼望能有机会加入<code>ibm</code>团队</p>
<p>　　感谢!</p>
<h3 id="6-自我介绍六"><a href="#6-自我介绍六" class="headerlink" title="6.  自我介绍六"></a>6.  自我介绍六</h3><p>考官好，我是计算机专业的面试者XX，我此次应聘的职位是IT行业的软件工程师，这份工作不仅与我的专业对口，同时也是我的特长与爱好所在。现在我就从以下三个方面介绍自己：</p>
<p>​	**学习力量：**我有较强的科研力量，能娴熟的进行<code>LINUX</code>操作，并能使用<code>VB</code>，<code>DELPHI</code>等语言编程。能运用网页三剑客<code>Photoshop</code>软件进行相关工作。</p>
<p>​	**实践力量：**我的专长是软件开发，我盼望能从事这方面的工作阅历，并且我曾经发过多个系统，如人事档案管理系统，工资管理系统等等。</p>
<p>​	**交际力量：**我的性格沉稳，能坐得住，对IT行业的工作，具有特别好的&#96;适应力量，而且为人谦和，具有很强的组织和协调力量，富有的事业心和责任感使我能够面对任何困难和挑战。</p>
<p>​	从以上的简洁自我介绍，我盼望公司能给我一个展现自己力量的机会，让我我可以学以致用，同时我也很观赏<code>XX</code>公司的企业文化与工作环境。我情愿成为企业一员，为企业的进展贡献自己的一份力气。我的职业生涯目标是，做一个既懂技术，又懂业务的复合型人才。</p>
<h3 id="7-自我介绍七"><a href="#7-自我介绍七" class="headerlink" title="7. 自我介绍七"></a>7. 自我介绍七</h3><p>​	在这四年里，我在学习上比较仔细，成果也比较好，每年都能拿到学校的奖学金，在班里也始终能保持在前五名。特殊是在专业课方面，尽量做到学好用好。乐观参与各种广告方面的竞赛，并且获得过全国高校生广告艺术大赛江苏赛区三等奖。无论是平常的作业，还是论文，还是考试，都能仔细对待，盼望做到最好。假如要说这四年在学习上最大的圆满是什么，那就是英语，以前在高中时我的英语成果还，但是进了高校以后，我对英语怠慢了，没有花太多的时间去学，导致现在要毕业了还没有考过六级。</p>
<p>​	在社会实践方面，我觉得我的阅历还是蛮丰富的。<code>20xx</code>年下半年，我在一家广告公司做实习策划的工作，尽管刚开头什么都不会，很辛苦，很累，但是当我作为一个歌迷见面会的策划者和执行者在舞台后和花儿乐队沟通的时候，当我撰写的伊奈陶瓷公司广告效果测评报告获得客户认可的时候，当我看到自己策划的奠基仪式、开业典礼胜利实施的时候，当我设计的<code>logo</code>被企业采纳的时候，当我在路演现场独挡一面的时候，我是快乐的。我靠着自己的努力完成了一项项任务。在广告公司的实习，让我学到了许多书本上学不到的东西，接触了各行各业的客户，同时，也在工作中对印刷业、媒体、礼仪服务机构等有了肯定的了解，为以后能够很快适应工作岗位奠定了基础。</p>
<p>​	回顾自己高校四年的工作学习生活，感受很深，但觉的收获还是颇丰的。把握了专业学问，培育了自己各方面的力量，这些对今后的工作都将产生重要的关心。除此之外，也应当看到我的一些缺点，如有时候做事情比较急于求成，在工作中实际阅历不足等等。但“金无足赤，人无完人”每个人都不行避开的存在他的缺点，有缺点并不行怕，关键的是如何看待自己的缺点，只有正视它的存在，通过不断的努力学习才能改正自己的缺点。今后我将更严格要求自己，努力工作，刻苦学习，发扬优点，改正缺点，开拓前进。</p>
<p>​	曾担当院同学会成员、副班长等职，现任计算机系团总支组织部部长。多次组织系部、班级联欢会、春游等活动，受到老师、同学们的全都好评。思想修养上，我品质优秀，思想进步，笃守诚、信、礼、智的做人原则。</p>
<p>​	这次我选择这个职位除了专业对口以外，我觉的我也非常喜爱这个职位，信任它能让我充分实现我的社会抱负和体现自身的价值。我认为我有力量也有信念做好这份工作盼望大家能够认可我，给我这个机会！</p>
<h3 id="8-自我介绍八"><a href="#8-自我介绍八" class="headerlink" title="8. 自我介绍八"></a>8. 自我介绍八</h3><p>　　各位领导好，我叫<code>XXX</code>，我的老家在是河南省，父母都健在身体都很健康，我还有一个 姐姐在武汉工作。我是<code>12</code>年大学毕业的，所学的专业也是计算机Javar软件技术。记得当时还没毕业就来上海找工作了，当时就在xx公司实习，半年后 就转正到卫生服务事业部，从事于医疗卫生项目方面的程序员开发工作。大概一共是待了一年半吧，就辞职了。原因大概是当时的工作氛围让我觉得没什么意思再加 上当时还自我感觉良好就跳到一家日企里上班，正好那时候公司在过<code>CMMI3</code>，做的项目都严格按照CMMI流程走的，什么文档、<code>Coding</code>、测试的我都有 参与。那时候真的是让学到不少项目上的东西，可能正好是金融危机吧，公司原先承诺的工资没有兑现然后我就走了。去的’是上海XX信息公司，从刚开始的项目主 力开发到项目组长，在上农信近三年的工作中我最大的收获就是公司放手让我在项目独挡一面跟客户面对面自由的沟通好需求，项目后期给客户提供项目培训然后通 过客户的反馈知道项目的得与失。可能是我不太适应公司的人事变化吧，然后就提出离职走了。</p>
<p>​	技术方面我一直都是从事于<code>J2ee Web</code>方面的工作，一般开源的框架<code>Struts1</code>、<code>Struts2</code>、<code>Hibernate</code>、<code>Ibatis</code>、<code>Spring</code>都有项目开发使用。掌握前端<code>Ajax</code>、<code>Jquery</code>、<code>Dwr</code>、包括<code>CSS</code>、<code>HTML</code>。</p>
<p>​	数据库方面能写复杂的<code>SQL</code>查询统计包括视图、存储过程的开发，有<code>postgre</code>，<code>Oracle</code>，<code>Sql Server</code>项目开发经验。</p>
<p>​	我的性格方面不算外向好像也不内向，喜欢交朋友，也喜欢有挑战性的。闲暇时间打打羽毛球，下象棋。</p>
<p>​	**性格缺点：**说话太直，做事情缺少魄力想的太多会犹豫不决。</p>
<p>​	**性格优点：**工作方面自我感觉做事比较认真、负责，能吃苦耐劳。</p>
<h3 id="9-自我介绍九"><a href="#9-自我介绍九" class="headerlink" title="9. 自我介绍九"></a>9. 自我介绍九</h3><p>我喜欢篮球和羽毛球，曾担任大学校篮球队队员。在篮球队中深刻体会到在大家共同努力下击败对手的成就感!</p>
<p>​	对于计算机有着狂热的喜爱，虽掌握软件众多，但对编程情有独钟!在每一次解决了问题后都有一种成就感!我喜欢这种感觉，让我能沉迷于我的代码的世界中!</p>
<p>​	爱好前端等程序设计，喜欢开发自已小型产品，追求技术上的满足感;稳固的架构，健壮的代码，团结的合作，是我的不懈追求。</p>
<p>​	有良好的编程习惯，以及程序错误控制和解决能力，我爱程序员这个岗位，当每天敲着代码，听着音乐，是很快乐的</p>
<p>​	用心工作，用心生活!我可能不是最好的&#96;，最合适的，我觉得我是最有潜力的!</p>
<h3 id="10-自我介绍十"><a href="#10-自我介绍十" class="headerlink" title="10. 自我介绍十"></a>10. 自我介绍十</h3><p>各位考官：</p>
<p>​	大家好！</p>
<p>​	我叫<code>xxx</code>，今年<code>x</code>岁，是<code>x</code>高校<code>x</code>专业<code>20x</code>届应届毕业生，应聘的职位是<code>xx</code>。</p>
<p>​	我曾先后在<code>xx</code>有限公司、<code>x</code>公司、<code>xx</code>有限公司调研或实习，了解<code>x</code>业务流程、<code>xx</code>操作及生产管理等。</p>
<p>​	正直和努力是我做人的原则，镇静和冷静是我遇事的态度，钻研和尽职是我从业的要求。回顾高校四年的学习生活，感受很深、收获颇丰，把握了专业学问，培育了自己各方面的素养和力量。我也存在一些不足之处，但我正视缺点和不足，不断的努力，使自己得到更大提高。</p>
<p>​	这次我选择这个职位除了专业对口以外，我觉的我也非常喜爱这个职位，信任它能让我充分实现我的社会抱负和体现自身的价值，我也认为我有力量有信念做好这份工作。</p>
<p>​	特别感谢<code>xx</code>赐予我这次面试学习的机会。感谢！</p>
<h3 id="11-自我介绍十一"><a href="#11-自我介绍十一" class="headerlink" title="11. 自我介绍十一"></a>11. 自我介绍十一</h3><p>​	回首三年的高校校内生活生涯和社会实践生活，有渴望、有追求、有胜利也有失败，我孜孜不倦，不断地挑战自我，充实自己，为实现人生的价值打下坚实的基础。 在思想品德上，本人有良好道德修养。本人遵纪守法、爱惜公共财产、关怀和关心他人，并以务实求真的精神热心参加学校的公益宣扬和爱国活动。</p>
<p>​	在学习上，我喜爱自己的专业，还利用课余时间专修计算机专业学问，使我能轻松操作各种网络和办公软件。曾多次获得学金，在书法和体育运动都获得好成果。英语、电脑、一般话等方面的等级考试已达标。除了在专业学问方面精益求精外，平常我还涉猎了大量网络编程、网络管理与维护、网页设计等学问。并且信任在以后理论与实际结合当中，能有更大提高。</p>
<p>​	在工作上，对工作热忱，任劳任怨，责任心强，具有良好的组织交际力量，和同学团结全都，注意协作其他同学干部精彩完成各项工作，得到了大家的全都好评。</p>
<p>​	在生活上，我最大的特点是诚恳守信，热心待人，勇于挑战自我，时间观念强，有着良好的生活习惯和正派作风。由于平易近人待人友好，所以始终以来与人相处甚是融洽，连续担当了分院的.乒协的秘书长一职。有广泛爱好的我特殊擅长于网页设计和网站管理与维护方面。曾独立完成一个中型网站的设计，以及大型综合网站的策划与修改工作。</p>
<p>​	身为平面设计专业的同学，我在修好学业的同时也注意于社会实践。本着学以致用，实践结合理论发挥。暑假期间我到Xx网吧等大型网吧里工作，管理阅历与软硬件维护得到了极大的积累。</p>
<p>​	三年的高校生活，使自己的学问水平、思想境界、工作力量等方面都迈上了一个新的台阶。在这即将挥手告辞美妙高校生活、踏上社会征途的时候，我整军待发，将以饱满的热忱、坚决的信念、高度的责任感去迎接新的挑战，攀登新的高峰。</p>
<h3 id="12-自我介绍十二"><a href="#12-自我介绍十二" class="headerlink" title="12. 自我介绍十二"></a>12. 自我介绍十二</h3><p>你好，我叫<code>xxx</code>，我上一家公司是做<code>XXX</code>。所以我们公司做的项目都是和XXX相关的。</p>
<p>​	刚进公司的那时候，什么交互啊，项目需求，测试，代码编写，优化，我都有积极的参与，因为是新人，所以好好把握住每个学习的机会，我的本职工作，前端这块，我都是认真负责完成。那时候虽然很忙，压力很大，但真的&#96;是学到了不少东西，后期项目都不断的在完善，我也不断的在参与。</p>
<p>​	在上一家公司中，我的收获不单单是技术方面，主要还有业务能力，自学能力和同事的沟通能力，这都是我学到的，而且是我认为很重要的。</p>
<p>​	技术方面我一直从事于web方面的工作，掌握的前端技术有ajax，js，vue，html，css，我也了解java语言和数据库表结构这块，与后台人员能更有效的沟通。</p>
<p>​	我的性格方面不算外向，也不算内向，跟朋友，同事相处，比较外向，在工作中，代码开发时，我是比较内向的，我喜欢全心全意的投入工作中。我也喜欢交朋友，偶尔跟朋友聚聚，聊聊。对于工作我总是抱着认真负责，有责任心，吃苦耐劳的态度工作。</p>
<p>​	谢谢，以上是我的自我介绍。</p>
<h2 id="git部分"><a href="#git部分" class="headerlink" title="git部分"></a>git部分</h2><h3 id="1-如何创建git仓库并提交版本？（-高-）"><a href="#1-如何创建git仓库并提交版本？（-高-）" class="headerlink" title="1. 如何创建git仓库并提交版本？（ 高 ）"></a>1. 如何创建git仓库并提交版本？（ 高 ）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到暂存盘</span></span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交一个版本</span></span><br><span class="line">git commit -m <span class="string">&quot;版本描述&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-如何解决合并冲突？（-中-）"><a href="#2-如何解决合并冲突？（-中-）" class="headerlink" title="2.如何解决合并冲突？（ 中 ）"></a>2.如何解决合并冲突？（ 中 ）</h3><p>合并冲突发生在合并分支时，当两个分支的相同部分产生了不同的更改时，解决合并冲突一般步骤如下：</p>
<p>使用<code>git status</code>命令查看冲突的文件。<br>打开冲突文件，手动解决冲突并选择要保留的更改。<br>使用<code>git add</code>命令将解决冲突后的文件标记为已解决。<br>使用<code>git commit</code>命令提交解决冲突的结果。</p>
<h3 id="3-如何恢复还原到上一个版本？（-低-）"><a href="#3-如何恢复还原到上一个版本？（-低-）" class="headerlink" title="3. 如何恢复还原到上一个版本？（ 低 ）"></a>3. 如何恢复还原到上一个版本？（ 低 ）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退到上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到指定的版本</span></span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>



<h3 id="4-请介绍推送本地仓库到远程的过程？（-高-）"><a href="#4-请介绍推送本地仓库到远程的过程？（-高-）" class="headerlink" title="4. 请介绍推送本地仓库到远程的过程？（ 高 ）"></a>4. 请介绍推送本地仓库到远程的过程？（ 高 ）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加暂存盘</span></span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交一个版本</span></span><br><span class="line">git commit  -m “描述文字”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库别名</span></span><br><span class="line">git remote add origin 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h3 id="5-请介绍git多人远程协作的流程？（-高-）"><a href="#5-请介绍git多人远程协作的流程？（-高-）" class="headerlink" title="5. 请介绍git多人远程协作的流程？（ 高 ）"></a>5. 请介绍git多人远程协作的流程？（ 高 ）</h3><p><strong>1. 克隆远程仓库</strong></p>
<p>首先，每个开发者需要将远程仓库克隆到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;远程仓库URL&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建分支</strong></p>
<p>为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p><strong>3. 开发与提交</strong></p>
<p>在本地分支上进行开发，完成后提交更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 推送分支</strong></p>
<p>将本地分支推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>5. 创建 Pull Request (PR)</strong></p>
<p>在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。</p>
<p><strong>6. 代码审查</strong></p>
<p>团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。</p>
<p><strong>7. 合并 Pull Request (PR)</strong></p>
<p>审查通过后，将 PR 合并到主分支。</p>
<p><strong>8. 同步主分支</strong></p>
<p>合并后，开发者应拉取最新的主分支到本地，保持同步：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p><strong>9. 删除已合并的分支</strong></p>
<p>合并完成后，可以删除远程和本地的已合并分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;分支名&gt;</span><br><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>10. 处理冲突</strong></p>
<p>如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;冲突文件&gt;</span><br><span class="line">git commit -m <span class="string">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>11. 持续集成</strong></p>
<p>许多团队使用 CI&#x2F;CD 工具（如 <code>Jenkins</code>、<code>GitHub Actions</code>）自动测试和部署代码，确保每次合并后的代码质量。</p>
<p><strong>12. 定期同步</strong></p>
<p>开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。</p>
<p><strong>总结</strong></p>
<p>多人协作的关键在于：</p>
<ul>
<li><p>使用分支隔离开发</p>
</li>
<li><p>通过 PR 进行代码审查</p>
</li>
<li><p>定期同步主分支</p>
</li>
<li><p>及时解决冲突</p>
</li>
</ul>
<p>这些步骤能有效提升团队协作效率，减少代码冲突。</p>
<p>开启新对话</p>
<h3 id="6-git-和-svn的区别？（-低-）"><a href="#6-git-和-svn的区别？（-低-）" class="headerlink" title="6. git 和 svn的区别？（ 低 ）"></a>6. git 和 svn的区别？（ 低 ）</h3><ul>
<li><code>git</code> 是分布式的，<code>svn</code>是集中式</li>
<li><code>git</code> 把内容按元数据方式存储，而 <code>svn</code>是按文件存储</li>
<li><code>git</code> 分支和<code>svn</code>的分支不同</li>
<li><code>git</code> 没有一个全局的版本号，而<code>svn</code>有全局版本</li>
<li><code>git</code> 的内容完整性要优于<code>svn</code></li>
</ul>
<h3 id="7-git-rebase-和-git-merge的区别？（-中-）"><a href="#7-git-rebase-和-git-merge的区别？（-中-）" class="headerlink" title="7.  git rebase 和 git merge的区别？（ 中 ）"></a>7.  git rebase 和 git merge的区别？（ 中 ）</h3><p> <strong>git merge</strong><br><strong>作用：</strong></p>
<p>将两个分支的代码合并，生成一个新的合并提交，保留两个分支的历史记录。</p>
<p><strong>特点：</strong></p>
<p>保留分支的完整历史（包括分叉和合并的上下文）。</p>
<p>会产生一个额外的合并提交（<code>Merge Commit</code>）。</p>
<p>适合在团队协作中合并公共分支（如 <code>main/develop</code>）。</p>
<p> <strong>git rebase</strong><br>作用：将当前分支的提交“移动”到目标分支的最新提交之后，形成一条线性的历史。</p>
<p><strong>特点：</strong></p>
<p>重写提交历史，使历史记录更清晰（无分叉）。</p>
<p>不会生成合并提交，但会修改原提交的哈希值（历史被改写）。</p>
<p>适合在本地整理提交记录，不推荐用于已推送到远程的分支。</p>
<p><strong>如何选择？</strong></p>
<p>如果分支是本地的，且想保持历史线性 → 用 <code>rebase</code>。</p>
<p>如果分支是公共的（已推送到远程）→ 用 <code>merge</code>。</p>
<p>推荐工作流：本地开发时用 <code>rebase</code> 保持整洁，合并到主分支时用 <code>merge</code>。</p>
<p><strong>一句话总结</strong></p>
<p><code>git merge</code>：保留历史，适合协作。</p>
<p><code>git rebase</code>：线性历史，适合本地优化。</p>
<h3 id="8-如何解决提交版本产生冲突？（-高-）"><a href="#8-如何解决提交版本产生冲突？（-高-）" class="headerlink" title="8. 如何解决提交版本产生冲突？（ 高 ）"></a>8. 如何解决提交版本产生冲突？（ 高 ）</h3><p>**发现冲突：**合并或变基时，<code>Git</code> 提示 <code>CONFLICT</code>。</p>
<p>**手动修改文件：**打开冲突文件，删除冲突标记（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），保留需要的代码。</p>
<p>**标记解决：**执行 <code>git add &lt;file&gt;</code> 告诉 Git 冲突已处理。</p>
<p><strong>完成操作：</strong></p>
<ol>
<li><p>合并用 &#96;git commit	。</p>
</li>
<li><p>变基用 <code>git rebase --continue</code>。</p>
</li>
</ol>
<p><strong>关键区别：</strong></p>
<p><code>git merge：</code>保留分支历史，适合公共分支（如团队协作）。</p>
<p><code>git rebase:</code> 线性历史，适合本地分支整理（别对已推送的分支用！）。</p>
<h2 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h2><h3 id="1-html5新增什么新特性？（-高-）"><a href="#1-html5新增什么新特性？（-高-）" class="headerlink" title="1. html5新增什么新特性？（ 高 ）"></a>1. html5新增什么新特性？（ 高 ）</h3><p>新元素：比如新增了表单标签、音视频标签、绘图标签、语义化标签<br>新属性：比如有<code>autocomplete</code> 自动完成、<code>required</code> 必填、<code>pattern</code> 正则表达式和 <code>placeholder</code> 提示占位文字<br>完全支持<code>CSS3</code>：比如新增了CSS圆角、盒阴影、文字阴影、颜色 <code>hsl</code> 和 <code>rgba</code>、媒体查询、<code>webfont</code>和<code>CSS</code>动画等<br>本地应用：本地数据存储、本地<code>SQL</code>数据、离线存储、<code>worker</code>多线程和<code>xmlHttpRequest 2</code></p>
<h3 id="2-主流浏览器以及引擎有那些？（-中-）"><a href="#2-主流浏览器以及引擎有那些？（-中-）" class="headerlink" title="2. 主流浏览器以及引擎有那些？（ 中 ）"></a>2. 主流浏览器以及引擎有那些？（ 中 ）</h3><p><code>chrome</code> 谷歌 , 引擎以前是<code>Webkit</code>，现在是<code>Blink</code>内核<br><code>firefox</code> 火狐，引擎是 <code>Gecko</code> 内核<br><code>ie</code> 微软（测试兼容性 <code>IE9-</code>），引擎是<code>Trident</code>内核（<code>IE</code>、<code>360</code>、搜狗）<br><code>opera</code> 欧鹏，引擎以前是<code>Presto</code>内核，后来是<code>Webkit</code>内核，现在是<code>Blink</code>内核<br><code>safari</code> 苹果，引擎是 <code>Webkit</code>内核<br><code>360</code> 安全，引擎是<code>IE+Chrome</code>双内核，<code>Trident</code>（兼容模式），<code>+Webkit</code>（高速模式）</p>
<h3 id="3-SEO优化有那些方面？（-中-）"><a href="#3-SEO优化有那些方面？（-中-）" class="headerlink" title="3. SEO优化有那些方面？（ 中 ）"></a>3. SEO优化有那些方面？（ 中 ）</h3><ul>
<li>设置窗口标题</li>
<li>设置<code>meta</code>描述</li>
<li>设置<code>meta</code>关键字，多个关键字用英文逗号分割</li>
<li>一个页面只用一个<code>h1</code>，要合理的使用标题级别</li>
<li>内链和外链优化</li>
<li>软文推广，就是写一篇看似很有营养的文章，这些文章被大流量网站收录，文章里面植入了你网站链接，属于外链优化</li>
<li>代码要语义化和代码结构简练</li>
<li>少用图片、视频、音频，因为搜索引擎无法采集图片、视频等富媒体上的内容</li>
</ul>
<h3 id="4-块级、行级和行块级的区别？（-中-）"><a href="#4-块级、行级和行块级的区别？（-中-）" class="headerlink" title="4. 块级、行级和行块级的区别？（ 中 ）"></a>4. 块级、行级和行块级的区别？（ 中 ）</h3><p><strong>块级标签特点：</strong><br>独占一行<br>宽度是自适应的<br>具有盒子属性（宽、高、边框、边距、填充）</p>
<p><strong>内联（行级）标签特点：</strong><br>内联标签之间可以并排<br>可以设置边框、外边距（仅支持左和右）内填充支持，但是渲染有问题，由此可见内 联再盒子默写渲染方案存在问题，不准确。</p>
<p><strong>行块级标签特点：</strong><br>具有块级标签的特点，比如可以很好的渲染盒子属性，又具有内联标签的特点，比如并排。<br>行块之间有间隙</p>
<h3 id="5-BFC是什么有什么用？（-低-）"><a href="#5-BFC是什么有什么用？（-低-）" class="headerlink" title="5. BFC是什么有什么用？（ 低 ）"></a>5. BFC是什么有什么用？（ 低 ）</h3><p><code>BFC</code>（<code>Block Formatting Context</code>，块级格式化上下文） 是 <code>CSS</code> 中一个重要的布局概念，它决定了元素如何对其子元素进行布局，以及子元素如何与外部元素交互。<code>BFC</code> 可以看作是一个独立的渲染区域，内部元素的布局不会影响到外部元素。</p>
<p><strong>BFC 的触发条件：</strong></p>
<p>满足以下任一条件即可创建 <code>BFC</code>：</p>
<ol>
<li><strong>根元素</strong>（<code>&lt;html&gt;</code> 标签）。</li>
<li><code>float</code> 不为 <code>none</code>。</li>
<li><code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>。</li>
<li><code>display</code> 为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>、<code>grid</code> 等。</li>
<li><code>overflow</code> 不为 <code>visible</code>（如 <code>hidden</code>、<code>auto</code>、<code>scroll</code>）。</li>
<li><code>contain</code> 值为 <code>layout</code>、<code>content</code> 或 <code>strict</code>。</li>
</ol>
<p><strong>BFC 的核心作用：</strong></p>
<p>防止外边距合并</p>
<ul>
<li><p>**问题：**垂直相邻块级元素的外边距会合并（取最大值）。</p>
</li>
<li><p>**解决：**将其中一个元素包裹在 BFC 容器中，阻止外边距合并。</p>
</li>
</ul>
<p>清除浮动</p>
<ul>
<li><strong>问题</strong>：父元素高度塌陷（子元素浮动后，父元素高度为 <code>0</code>）。</li>
<li><strong>解决</strong>：父元素触发 <code>BFC</code>，包裹浮动子元素。</li>
</ul>
<p>阻止元素被浮动覆盖</p>
<ul>
<li><strong>问题</strong>：非浮动元素可能被浮动元素覆盖。</li>
<li><strong>解决</strong>：非浮动元素触发 <code>BFC</code>，形成独立区域。</li>
</ul>
<p>隔离布局，避免外部干扰</p>
<ul>
<li>BFC 内部元素的布局（如浮动、定位）不会影响外部元素。</li>
</ul>
<h3 id="6-语义化有什么用？（-中-）"><a href="#6-语义化有什么用？（-中-）" class="headerlink" title="6. 语义化有什么用？（ 中 ）"></a>6. 语义化有什么用？（ 中 ）</h3><p>结构更清晰，<code>html</code>语义化让页面的内容结构化，便于对浏览器、搜索引擎解析。<br>方便<code>SEO</code>优化，搜索引擎的爬虫也依赖于<code>HTML</code>标记来确定上下文和各个关键字的权重。<br>便于阅读维护理解，使阅读源代码的人对网站更容易将网站分块。</p>
<h3 id="7-html5新增什么语义化标签？（-中-）"><a href="#7-html5新增什么语义化标签？（-中-）" class="headerlink" title="7. html5新增什么语义化标签？（ 中 ）"></a>7. html5新增什么语义化标签？（ 中 ）</h3><p><code>header</code> 头部</p>
<p> <code>footer</code> 脚部 </p>
<p><code>main</code> 主体 </p>
<p><code>section</code> 区块 </p>
<p><code>aside</code> 侧边栏 </p>
<p><code>article</code> 文章</p>
<p><code>details</code> 详细 </p>
<p><code>figure</code> 图文 </p>
<p><code>nav</code> 导航 </p>
<p><code>menu</code> 菜单</p>
<h3 id="8-块级、行级和行块级有哪些？（-中-）"><a href="#8-块级、行级和行块级有哪些？（-中-）" class="headerlink" title="8. 块级、行级和行块级有哪些？（ 中 ）"></a>8. 块级、行级和行块级有哪些？（ 中 ）</h3><p><strong>块级标签：</strong></p>
<ol>
<li><code>div</code>  布局</li>
<li><code>p</code> 段落</li>
<li><code>form</code> 表单</li>
<li><code>h1-h6</code> 标题</li>
<li><code>pre</code> 预处理</li>
<li><code>ul</code>、<code>ol </code>、<code>dl</code> 项目列表</li>
</ol>
<p><strong>行级标签：</strong></p>
<ol>
<li><code>span</code> 文本</li>
<li><code>a</code> 超级链接</li>
<li><code>img</code> 图像</li>
<li><code>b</code> 加粗</li>
<li><code>i</code> 倾斜</li>
<li><code>u</code> 下划线</li>
</ol>
<p><strong>行块级标签：</strong></p>
<ol>
<li><p><code>input</code> 输入框</p>
</li>
<li><p><code>select</code> 下拉列表框</p>
</li>
<li><p><code>textarea</code> 多行输入框</p>
</li>
<li><p><code>button</code> 按钮</p>
</li>
</ol>
<h3 id="9-从输入URL到显示页面经历了什么？（-高-）"><a href="#9-从输入URL到显示页面经历了什么？（-高-）" class="headerlink" title="9. 从输入URL到显示页面经历了什么？（ 高 ）"></a>9. 从输入URL到显示页面经历了什么？（ 高 ）</h3><p>输入URL发生以下步骤：</p>
<ol>
<li><p><code>DNS</code> 域名解析（域名解析成<code>IP</code>地址，走<code>UTP</code>协议，因此不会有握手过程），浏览器将 <code>URL</code> 解<br>析出相对应的服务器的 <code>IP</code> 地址，具体搜索过程如下：</p>
<p>1.1 本地浏览器的 <code>DNS</code> 缓存中查找 </p>
<p>1.2 再向系统<code>DNS</code>缓存发送查询请求</p>
<p>1.3 再向路由器<code>DNS</code>缓存 </p>
<p>1.4 网络运营商<code>DNS</code>缓存 </p>
<p>1.5 递归搜索</p>
<p>1.6 并从 <code>URL</code> 中解析出端口号</p>
</li>
<li><p>浏览器与目标服务器建立一条 <code>TCP</code> 连接（三次握手）</p>
</li>
<li><p>浏览器向服务器发送一条 <code>HTTP</code> 请求报文</p>
</li>
<li><p>服务器返回给浏览器一条 <code>HTTP</code> 响应报文</p>
</li>
<li><p>浏览器进行渲染</p>
</li>
<li><p>关闭 <code>TCP</code> 连接（四次挥手）</p>
</li>
</ol>
<h3 id="10-title与alt属性的区别是什么？（-中-）"><a href="#10-title与alt属性的区别是什么？（-中-）" class="headerlink" title="10. title与alt属性的区别是什么？（ 中 ）"></a>10. title与alt属性的区别是什么？（ 中 ）</h3><p><code>alt</code>是给搜索引擎识别，在图像无法显示时的替代文本<br><code>title</code>是关于元素的注释信息，主要是给用户解读</p>
<h3 id="11-get和post的区别是？（-高-）"><a href="#11-get和post的区别是？（-高-）" class="headerlink" title="11. get和post的区别是？（ 高 ）"></a>11. get和post的区别是？（ 高 ）</h3><p><code>GET</code>是不安全的，因为在传输过程，数据被放在请求的<code>URL</code>中，而<code>POST</code>的所有操作对用户来说都是不可见的。<br><code>GET</code>传送的数据量较小，这主要是因为受<code>URL</code>长度限制，而<code>POST</code>传送的数据量较大，一般被默认为不受限制。<br><code>GET</code>限制表单数据集的值必须为<code>ASCII</code>字符，而<code>POST</code>支持整个<code>ISO10646</code>字符集。<br><code>GET</code>执行效率却比<code>POST</code>方法好，<code>GET</code>是表单提交的默认方法。</p>
<p><code>GET</code>默认有缓存，解决缓存可以再<code>URL</code>挂载一个时间戳或者随机数作为参数。</p>
<h3 id="12-canvas-和-svg的区别？（-中-）"><a href="#12-canvas-和-svg的区别？（-中-）" class="headerlink" title="12. canvas 和 svg的区别？（ 中 ）"></a>12. canvas 和 svg的区别？（ 中 ）</h3><p><code>canvas</code>是通过<code>JavaScript</code>代码来绘制2d图形的<br><code>svg</code>是通过XML来描述<code>2d</code>图形的<br><code>svg</code>是矢量图，放大不失真，而<code>canvas</code>是位图，放大失真出现锯齿效果<br><code>svg</code>里面的每个节点都可以单独添加事件，而<code>canvas</code>只可以给画布添加事件<br><code>svg</code>渲染速度慢；而<code>canvas</code>渲染速度快，适合游戏场景制作</p>
<h3 id="13-jpg、png、gif、svg和webp的区别？（-高-）"><a href="#13-jpg、png、gif、svg和webp的区别？（-高-）" class="headerlink" title="13. jpg、png、gif、svg和webp的区别？（ 高 ）"></a>13. jpg、png、gif、svg和webp的区别？（ 高 ）</h3><p><code>jpg</code>：有损压缩格式图片，是位图，通常用于产品、风景、人物等色彩丰富的图片。<br><code>png</code>：无损格式图片，图片画质清晰，支持<code>alpha</code>通道透明，通常用于小图标、或者产品图片。<br><code>gif</code>：以<code>8</code>位色重现真色彩的图像，所以一般用于图标，或者颜色单一的图片，其次它可以做动图。<br><code>svg</code>：<code>svg</code>是矢量图片，支持<code>js</code>事件，同事支持图片动画。<br><code>webp</code>：这是谷歌发明的一款优于<code>jpg</code>的图片压缩格式，压缩率只有<code>jpg</code>的<code>2/3</code>。</p>
<h3 id="14-行块之间存在间隙，是什么造成的？如何解决？（-中-）"><a href="#14-行块之间存在间隙，是什么造成的？如何解决？（-中-）" class="headerlink" title="14. 行块之间存在间隙，是什么造成的？如何解决？（ 中 ）"></a>14. 行块之间存在间隙，是什么造成的？如何解决？（ 中 ）</h3><p>间隙是元素之间存在空格造成的，解决方法有两种：</p>
<p>将父容器设置<code>font-size：0</code>，这样可以将空格间距去掉，兼容性一般，代码易读<br>将元素首尾紧密相连不要有任何间隙，兼容性最好，代码不易读</p>
<h3 id="15-请描述下SEO中的TDK？（-中-）"><a href="#15-请描述下SEO中的TDK？（-中-）" class="headerlink" title="15. 请描述下SEO中的TDK？（ 中 ）"></a>15. 请描述下SEO中的TDK？（ 中 ）</h3><p>在<code>SEO</code>中，所谓的<code>TDK</code>其实就是<code>title</code>、<code>description</code>和<code>keywords</code>这三个标签，这三个标签在网站的优化过程中<code>title</code>标题标签，<code>description</code>描述标签，<code>keywords</code>关键词标签。</p>
<h2 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h2><h3 id="1-什么是盒子模型？它的区别？（-高-）"><a href="#1-什么是盒子模型？它的区别？（-高-）" class="headerlink" title="1. 什么是盒子模型？它的区别？（ 高 ）"></a>1. 什么是盒子模型？它的区别？（ 高 ）</h3><p>CSS盒子模型主要有两种：标准盒子模型和替代（IE）盒子模型。</p>
<p><strong>标准盒子模型（W3C Box Model）</strong><br><strong>组成：</strong> 内容（<code>content</code>）、内边距（<code>padding</code>）、边框（<code>border</code>）、外边距（<code>margin</code>）。<br><strong>宽度和高度计算：</strong> 仅包含内容的宽度和高度，内边距、边框和外边距不包含在内。<br><strong>设置方式：</strong> 默认情况下，浏览器使用标准盒子模型。</p>
<p><strong>IE盒子模型（IE Box Model）</strong><br><strong>组成：</strong> 内容（<code>content</code>）、内边距（<code>padding</code>）、边框（<code>border</code>）、外边距（<code>margin</code>）。<br><strong>宽度和高度计算：</strong> 包含内容、内边距和边框的宽度和高度，外边距不包含在内。<br><strong>设置方式：</strong> 通过<code> box-sizing: border-box</code> 启用。</p>
<p><strong>区别</strong><br><strong>宽度和高度计算：</strong><br><strong>标准盒子模型：</strong> <code>width</code> 和 <code>height</code> 仅指内容区域。<br><strong>IE盒子模型：</strong> <code>width</code> 和 <code>height</code> 包含内容、内边距和边框。<br><strong>布局影响：</strong> <code>IE</code>盒子模型更直观，尤其在处理内边距和边框时，布局更易控制。</p>
<p><strong>总结</strong><br><strong>标准盒子模型：</strong> 宽度和高度仅指内容区域。<br><strong>替代盒子模型：</strong> 宽度和高度包含内容、内边距和边框。</p>
<p>通过 <code>box-sizing</code> 属性可以切换盒子模型类型。</p>
<h3 id="2-CSS有哪些选择器？（-高-）"><a href="#2-CSS有哪些选择器？（-高-）" class="headerlink" title="2. CSS有哪些选择器？（ 高 ）"></a>2. CSS有哪些选择器？（ 高 ）</h3><ol>
<li>标签选择器（如：<code>div</code>, <code>p</code>）</li>
<li>类选择器（如：<code>class=&quot;logo&quot;</code>）</li>
<li>ID选择器（如：<code>id=&quot;box&quot;</code> ）</li>
<li>通配符选择器（如：星号）</li>
<li>组合选择器（如：空格、大于号、加号、反折号）</li>
<li>属性选择器（如：<code>[name=&quot;box&quot;]</code>）</li>
<li>伪类选择器（如：<code>:active</code>、<code>:hover</code>、<code>:first-child</code>等）</li>
<li>伪元素选择器（如：<code>::before</code>、<code>::after</code>）</li>
</ol>
<h3 id="3-CSS的权重优先级是什么？（-高-）"><a href="#3-CSS的权重优先级是什么？（-高-）" class="headerlink" title="3. CSS的权重优先级是什么？（ 高 ）"></a>3. CSS的权重优先级是什么？（ 高 ）</h3><p><code>!important</code> &gt; 行内样式 &gt; <code>id</code>样式 &gt; （<code>class</code> &#x3D; 属性 &#x3D; 伪类） &gt;  标签  &gt;  默认</p>
<p><strong>按大小顺序排序是：</strong></p>
<ol>
<li><code>!important</code> 权重为<code>10000</code>，<code>!important</code>会带来性能开销</li>
<li><code>style</code>行内样式，权重为<code>1000</code></li>
<li><code>id</code>选择器，权重为<code>100</code></li>
<li>类选择器 <code>=</code> 属性选择器<code>=</code>伪类选择器，权重为<code>10</code></li>
<li>伪元素选择器<code>=</code>标签选择器，权重为<code>1</code></li>
<li>通配符选择器，权重为<code>0</code></li>
<li>默认样式，权重为<code>0</code></li>
</ol>
<h3 id="4-px、em和rem单位的区别？（-高-）"><a href="#4-px、em和rem单位的区别？（-高-）" class="headerlink" title="4. px、em和rem单位的区别？（ 高 ）"></a>4. px、em和rem单位的区别？（ 高 ）</h3><p><code>px</code> 相对长度单位，像素<code>px</code>是相对于显示器屏幕分辨率而言的。<br><code>em</code> 相对长度单位，会继承父级元素的字体大小，若父元素字体大小为<code>14px</code>。<br><code>rem</code> 是相对于根元素<code>html</code>字体大小的单位。</p>
<h3 id="5-相对、绝对和固定定位的区别？（-高-）"><a href="#5-相对、绝对和固定定位的区别？（-高-）" class="headerlink" title="5. 相对、绝对和固定定位的区别？（ 高 ）"></a>5. 相对、绝对和固定定位的区别？（ 高 ）</h3><p><code>relative</code>、<code>fixed</code> 和 <code>absolute</code> 是 <code>CSS</code> 中的三种定位方式，主要区别如下：</p>
<p><strong>relative（相对定位）：</strong></p>
<ol>
<li>相对于元素自身在文档流中的原始位置进行偏移。</li>
<li>不影响其他元素的布局，原始空间仍保留。</li>
</ol>
<p><strong>fixed（固定定位）：</strong></p>
<ol>
<li>相对于浏览器视口定位，不随页面滚动而移动。</li>
<li>脱离文档流，不保留原始空间。</li>
</ol>
<p><strong>absolute（绝对定位）：</strong></p>
<ol>
<li>相对于最近的已定位（非 <code>static</code>）祖先元素定位，若无则相对于视口。</li>
<li>脱离文档流，不保留原始空间。</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li><p><code>relative：</code>相对自身偏移，保留空间。</p>
</li>
<li><p><code>fixed：</code>相对视口定位，不随滚动移动。</p>
</li>
<li><p><code>absolute：</code>相对最近已定位祖先元素定位，脱离文档流。</p>
</li>
</ul>
<h3 id="6-CSS3的新特性有哪些？（-低-）"><a href="#6-CSS3的新特性有哪些？（-低-）" class="headerlink" title="6. CSS3的新特性有哪些？（ 低 ）"></a>6. CSS3的新特性有哪些？（ 低 ）</h3><ol>
<li><p>新增伪类伪元素选择器 <code>::before</code></p>
</li>
<li><p>弹性盒模型 <code>display: flex</code></p>
</li>
<li><p>媒体查询 <code>media screen</code></p>
</li>
<li><p>个性化字体 <code>webfont</code></p>
</li>
<li><p>颜色透明度 <code>rgba</code></p>
</li>
<li><p>圆角、渐变、阴影、文字溢出、背景效果、边框效果和变形</p>
</li>
<li><p>动画（过渡和自定义动画）</p>
</li>
</ol>
<h3 id="7-用代码画三角形有几种方式？（-中-）"><a href="#7-用代码画三角形有几种方式？（-中-）" class="headerlink" title="7. 用代码画三角形有几种方式？（ 中 ）"></a>7. 用代码画三角形有几种方式？（ 中 ）</h3><p><strong>1. CSS Border 方式</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.  CSS Clip-path 裁剪</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.  SVG 绘制</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M50 0 L100 100 L0 100 Z&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>4.  Canvas 绘图</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M50 0 L100 100 L0 100 Z&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>一句话总结</strong></p>
<p>主要方式：<strong>CSS 边框法</strong>（兼容性好）、<strong>Clip-path</strong>（灵活）、<strong>SVG</strong>（矢量无损）、<strong>Canvas</strong>（动态绘制）。</p>
<h3 id="8-左边固定200px，右边自适应，有几种方法-（-高-）"><a href="#8-左边固定200px，右边自适应，有几种方法-（-高-）" class="headerlink" title="8. 左边固定200px，右边自适应，有几种方法?（ 高 ）"></a>8. 左边固定200px，右边自适应，有几种方法?（ 高 ）</h3><p><strong>1. Flex 布局</strong></p>
<p><strong>原理</strong>：父容器设为 <code>flex</code>，右侧设置 <code>flex:1</code> 自动填充剩余空间。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 自适应 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Grid 布局</strong></p>
<p><strong>原理</strong>：父容器用 <code>grid-template-columns</code> 定义两列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr; <span class="comment">/* 1fr 表示剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浮动布局</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 右侧自适应 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 绝对定位</strong></p>
<p><strong>原理</strong>：左侧绝对定位，右侧通过 <code>margin-left</code> 留出空间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 右侧自适应 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-块水平垂直居中有多少种方法？（-高-）"><a href="#9-块水平垂直居中有多少种方法？（-高-）" class="headerlink" title="9. 块水平垂直居中有多少种方法？（ 高 ）"></a>9. 块水平垂直居中有多少种方法？（ 高 ）</h3><p>以下是实现块元素水平垂直居中的常见方法，分为 <code>已知元素尺寸</code> 和 <code>未知元素尺寸</code> 两类：</p>
<p><strong>一、已知元素宽高</strong></p>
<p><strong>1. 绝对定位 + Margin 偏移</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>; <span class="comment">/* 宽度的一半 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;   <span class="comment">/* 高度的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>二、未知元素宽高</strong></p>
<p><strong>1. Flex 布局</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;     <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Grid 布局</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">place-items</span>: center; <span class="comment">/* 同时水平和垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 绝对定位 + Transform</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>); <span class="comment">/* 自动计算偏移 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 绝对定位 + Margin Auto</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto; <span class="comment">/* 自动分配外边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>推荐方案</strong>：优先使用 <code>Flex</code> 或 <code>Grid</code>（代码简洁，无需计算尺寸）。</li>
<li><strong>兼容旧浏览器</strong>：选择 <code>绝对定位 + Transform</code> 或 <code>绝对定位 + Margin Auto</code>。</li>
<li><strong>核心思路</strong>：通过定位、弹性布局或网格布局调整元素的位置关系。</li>
</ul>
<h3 id="10-伪类和伪元素有哪些？（-低-）"><a href="#10-伪类和伪元素有哪些？（-低-）" class="headerlink" title="10. 伪类和伪元素有哪些？（ 低 ）"></a>10. 伪类和伪元素有哪些？（ 低 ）</h3><p><strong>伪类：</strong></p>
<p><code>:first-child</code> 第一个<br><code>:not</code> 匹配除了谁（不包含于）<br><code>:target</code> 锚点<br><code>:hover</code> 划过<br><code>:nth-child(n) </code>根据索引值选择标签<br><code>:checked</code> 匹配选中标签（单选框和复选框）</p>
<p><strong>伪元素：</strong></p>
<p><code>::before</code> 在元素内部的前面创建<br><code>::after</code> 在元素内部不的后面创建<br><code>::first-letter </code>首字母<br><code>::first-line</code> 首行第一行<br><code>::selection</code> 选区<br><code>::placeholder</code> 占位提示文字<br><code>::webkit-scrollbar</code> 滚动条</p>
<h3 id="11-哪些属性可以继承？哪些不能继承？（-中-）"><a href="#11-哪些属性可以继承？哪些不能继承？（-中-）" class="headerlink" title="11. 哪些属性可以继承？哪些不能继承？（ 中 ）"></a>11. 哪些属性可以继承？哪些不能继承？（ 中 ）</h3><p><strong>可继承的样式：</strong></p>
<ol>
<li><code>font-size</code>  字体大小</li>
<li><code>font-family</code>  字体</li>
<li><code>color</code> 字体颜色</li>
<li><code>text-align</code> 水平对齐</li>
<li><code>line-height</code> 行高</li>
<li><code>text-indent</code> 缩进</li>
</ol>
<p><strong>不可继承的样式：</strong></p>
<ol>
<li><code>width</code> 宽度</li>
<li><code>height</code> 高度</li>
<li><code>margin</code> 边距</li>
<li><code>padding</code> 填充</li>
<li><code>border</code> 边框</li>
<li><code>box-sizing</code> 盒型</li>
<li><code>display</code> 显示</li>
<li><code>background</code> 背景相关</li>
</ol>
<h3 id="12-rem自适应布局？如何实现？（-低-）"><a href="#12-rem自适应布局？如何实现？（-低-）" class="headerlink" title="12. rem自适应布局？如何实现？（ 低 ）"></a>12. rem自适应布局？如何实现？（ 低 ）</h3><p><strong>核心原理</strong></p>
<ul>
<li><strong>Rem 单位</strong>：<code>1rem = 根元素（html）的字体大小</code>。</li>
<li><strong>动态调整</strong>：根据屏幕宽度动态修改根元素的 <code>font-size</code>，使所有使用 <code>rem</code> 的元素等比缩放。</li>
</ul>
<p><strong>实现步骤</strong></p>
<p> <strong>1. 设置 viewport 标签</strong></p>
<p>确保页面根据设备宽度渲染：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>2.动态计算根元素字体大小</strong></p>
<p>通过 <code>JavaScript</code> 监听窗口变化，动态设置 <code>html</code> 的 <code>font-size</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设设计稿宽度为 750px（移动端常见尺寸）</span></span><br><span class="line"><span class="keyword">const</span> designWidth = <span class="number">750</span>; </span><br><span class="line"><span class="keyword">const</span> baseFontSize = <span class="number">100</span>; <span class="comment">// 1rem = 100px（方便换算）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setRem</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> screenWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> fontSize = (screenWidth / designWidth) * baseFontSize;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = fontSize + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 + 窗口变化时更新</span></span><br><span class="line"><span class="title function_">setRem</span>();</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, setRem);</span><br></pre></td></tr></table></figure>


<p><strong>3. CSS 中使用 Rem 单位</strong></p>
<p>根据设计稿尺寸直接转换（如设计稿中 <code>100px</code> → <code>1rem</code>）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">3.2rem</span>;  <span class="comment">/* 设计稿中 320px → 320/100=3.2rem */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>优点</strong></p>
<ul>
<li><strong>等比缩放</strong>：适配不同屏幕分辨率。</li>
<li><strong>维护方便</strong>：只需调整根字体大小即可全局控制布局。</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>Rem 布局 &#x3D; 动态设置 <code>html.fontSize</code> + 全站使用 <code>rem</code> 单位</strong>，适合移动端响应式开发！</p>
<h3 id="13-transition和animation动画的区别？（-中-）"><a href="#13-transition和animation动画的区别？（-中-）" class="headerlink" title="13. transition和animation动画的区别？（ 中 ）"></a>13. transition和animation动画的区别？（ 中 ）</h3><ol>
<li><code>transition</code> 需要触发事件，比如点击事件、鼠标移入事件；而 animation可以配合关键帧 可以不触发事件就触发这个动画</li>
<li><code>transition</code> 触发一次播放一次；而 <code>animation</code> 则是可以设置很多的属性，比如循环次数，动画结束的状态等等；</li>
<li><code>transition</code>关注的是样式属性的变化，而<code>animation</code>作用于元素本身使用关键帧的概念，实现更自由的动画效果；</li>
<li><code>transition</code>动画比<code>animation</code>性能开销要低，不会引起页面重排。</li>
</ol>
<h3 id="14-项目中使用less或者scss吗？（-中-）"><a href="#14-项目中使用less或者scss吗？（-中-）" class="headerlink" title="14. 项目中使用less或者scss吗？（ 中 ）"></a>14. 项目中使用less或者scss吗？（ 中 ）</h3><p>使用过<code>less</code>框架，它们的区别是：</p>
<p>他们是动态的样式语言，是<code>css</code>预处理器，<code>css</code>上的一种抽象层，浏览器并不直接支持解析。他们是一种特殊的语法&#x2F;语言而编译成<code>css</code>。</p>
<p><strong>区别：</strong><br>变量符不一样，<code>less</code>是<code>@</code>，而<code>Sass</code>是<code>$</code>;<br><code>scss</code>支持条件语句，可以使用<code>if&#123;&#125;else&#123;&#125;</code>,<code>for&#123;&#125;</code>循环等等。而<code>Less</code>不支持;<br><code>scss</code>是基于<code>Ruby</code>的，是在服务端处理的，而<code>Less</code>是需要引入<code>less.js</code>来处理<code>Less</code>代码输出<code>css</code>到浏览器</p>
<h3 id="15-介绍一下CSS-Sprites（雪碧图）？（-中-）"><a href="#15-介绍一下CSS-Sprites（雪碧图）？（-中-）" class="headerlink" title="15. 介绍一下CSS Sprites（雪碧图）？（ 中 ）"></a>15. 介绍一下CSS Sprites（雪碧图）？（ 中 ）</h3><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用<code>CSS</code>的 <code>background-image</code>，<code>background- repeat</code>，<code>background-position</code>的组合进行背景定位。</p>
<p>优点是利用<code>CSS Sprites</code>能很好地减少网页的<code>http</code>请求，从而大大的提高页面的性能。</p>
<p>缺点是后期修改维护起来非常的不方便，其次也不是矢量图，不清晰。</p>
<h3 id="16-谈谈你对弹性布局的理解？（-高-）"><a href="#16-谈谈你对弹性布局的理解？（-高-）" class="headerlink" title="16. 谈谈你对弹性布局的理解？（ 高 ）"></a>16. 谈谈你对弹性布局的理解？（ 高 ）</h3><p><code>flex</code> 是一种一维布局模型（行或列），通过控制容器和内部项目的排列方式，解决传统布局的痛点，比如居中、对齐、动态分配空间等。</p>
<p>核心属性我常用的是容器上的<code> justify-content</code>（主轴对齐）、<code>align-items</code>（交叉轴对齐），以及项目的 <code>flex-grow</code>和<code>flex-shrink</code>（控制伸缩比例）。比如实现一个水平垂直居中，只需要给父容器设置 <code>display: flex </code>加上<code> justify-content: center</code>和 <code>align-items: center</code>，完全不需要计算尺寸，非常高效。</p>
<p>实际项目中，<code>flex</code> 帮我解决过很多问题。比如最近开发的一个移动端页面，顶部导航栏需要左侧图标、中间标题、右侧按钮自适应排列，直接用 <code>display: flex</code> 配合 <code>justify-content: space-between</code>，<code>10</code> 行代码就实现了，而且适配不同屏幕尺寸。</p>
<p>不过 flex 也有局限性，比如它是一维布局，复杂网格结构可能需要结合 <code>grid</code> 布局。但总体来说，<code>flex</code> 在管理单行或单列布局时，绝对是开发效率的利器。</p>
<h3 id="17-弹性布局主轴和交叉轴的区别？（-中-）"><a href="#17-弹性布局主轴和交叉轴的区别？（-中-）" class="headerlink" title="17. 弹性布局主轴和交叉轴的区别？（ 中 ）"></a>17. 弹性布局主轴和交叉轴的区别？（ 中 ）</h3><p>可以这么理解：主轴方向由 <code>flex-direction</code> 定义，默认是水平方向（从左到右），交叉轴就是它的垂直方向。对齐时，<code>justify-content</code> 管主轴，<code>align-items</code> 管交叉轴。比如设置 <code>flex-direction: column</code>，主轴就变成垂直方向，交叉轴自然变成水平方向。</p>
<h3 id="18-弹性布局的实现水平垂直居中？（-高-）"><a href="#18-弹性布局的实现水平垂直居中？（-高-）" class="headerlink" title="18. 弹性布局的实现水平垂直居中？（ 高 ）"></a>18. 弹性布局的实现水平垂直居中？（ 高 ）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;     <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-单行省略和多行省略？（-中-）"><a href="#19-单行省略和多行省略？（-中-）" class="headerlink" title="19. 单行省略和多行省略？（ 中 ）"></a>19. 单行省略和多行省略？（ 中 ）</h3><p><strong>单行溢出省略</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line1</span>&#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多行溢出省略</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line2</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-<span class="selector-tag">line</span>-clamp: <span class="number">2</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-rgba-和-opacity-设置透明的区别？（-低-）"><a href="#20-rgba-和-opacity-设置透明的区别？（-低-）" class="headerlink" title="20. rgba 和 opacity 设置透明的区别？（ 低 ）"></a>20. rgba 和 opacity 设置透明的区别？（ 低 ）</h3><p>子元素<code>opacity</code>会继承父元素的 <code>opacity</code> 属性，后代元素的颜色都变透明。<br><code>rgba</code>设置的元素的后代元素不会继承不透明属性，只让当前元素的颜色变透明。</p>
<h3 id="21-移动端怎么开发？（-中-）"><a href="#21-移动端怎么开发？（-中-）" class="headerlink" title="21. 移动端怎么开发？（ 中 ）"></a>21. 移动端怎么开发？（ 中 ）</h3><p>移动端我分为 <code>跨平台</code> 和 <code>原生开发</code> 两种场景：</p>
<ol>
<li><strong>跨平台方案</strong>：比如用 <code>React Native</code> 或 <code>Flutter</code> 开发，优点是代码复用率高、热更新灵活。之前做过一个电商 <code>App</code>，用 <code>RN</code> 实现核心功能，通过 <code>Native Modules</code> 对接原生相机模块，兼顾效率与性能。</li>
<li><strong>原生开发</strong>：针对高性能需求场景，比如用 <code>Swift</code> 开发 <code>iOS</code> 应用，或 <code>Kotlin</code> 写 <code>Android</code> 模块。不过现在更多会结合混合<code>Hybrid</code> 模式，比如 <code>WebView</code> 嵌套 <code>H5</code> 实现动态化。</li>
</ol>
<p>移动端特别注意 屏幕适配（如 <code>Flex</code> 布局、<code>Rem</code> 方案）、手势交互优化，以及 离线缓存策略（提升弱网体验）。</p>
<h2 id="es5部分"><a href="#es5部分" class="headerlink" title="es5部分"></a>es5部分</h2><h3 id="1-JS有哪些数据类型？（-高-）"><a href="#1-JS有哪些数据类型？（-高-）" class="headerlink" title="1. JS有哪些数据类型？（ 高 ）"></a>1. JS有哪些数据类型？（ 高 ）</h3><p><strong>基本数据类型：</strong><code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>symbol</code>、<code>BigInt</code></p>
<p><strong>引用数据类型：</strong><code>object</code>、<code>array</code>、<code>function</code></p>
<h3 id="2-堆和栈的区别？（-中-）"><a href="#2-堆和栈的区别？（-中-）" class="headerlink" title="2. 堆和栈的区别？（ 中 ）"></a>2. 堆和栈的区别？（ 中 ）</h3><p>**栈：**由系统自动分配和释放，存放函数参数、局部变量等，内存连续且高效，但容量有限；</p>
<p><strong>堆：</strong> 需手动申请和释放（如 <code>new</code>），存储动态数据（如对象、数组），空间更大但容易碎片化。举例来说，函数调用时局部变量入栈，执行完自动弹出；而 <code>new</code> 创建的数组存于堆中，需手动释放。</p>
<p>理解二者区别对优化内存和避免泄漏至关重要。</p>
<h3 id="3-typeof能检测哪些类型？（-高-）"><a href="#3-typeof能检测哪些类型？（-高-）" class="headerlink" title="3. typeof能检测哪些类型？（ 高 ）"></a>3. typeof能检测哪些类型？（ 高 ）</h3><ol>
<li><code>string</code> 字符串类型</li>
<li><code>number</code> 数字类型，包括<code>NaN</code></li>
<li><code>boolean</code> 布尔类型</li>
<li><code>undefined</code> 未定义类型</li>
<li><code>function</code> 函数类型</li>
<li><code>object</code> 对象类型，包括<code>null</code></li>
<li><code>symbol</code> 符号类型</li>
</ol>
<h3 id="4-JS检测数据类型有哪些方式？（-高-）"><a href="#4-JS检测数据类型有哪些方式？（-高-）" class="headerlink" title="4. JS检测数据类型有哪些方式？（ 高 ）"></a>4. JS检测数据类型有哪些方式？（ 高 ）</h3><ol>
<li><p><code>typeof</code>：检查基本数据类型</p>
</li>
<li><p><code>instanceof</code>：检查引用数据类型</p>
</li>
<li><p><code>Object.prototype.toString.call()</code>：检查基本数据类型和引用数据类型</p>
</li>
</ol>
<h3 id="5-检测数组和对象有几种方式？（-高-）"><a href="#5-检测数组和对象有几种方式？（-高-）" class="headerlink" title="5. 检测数组和对象有几种方式？（ 高 ）"></a>5. 检测数组和对象有几种方式？（ 高 ）</h3><ol>
<li><code>Array.isArray</code> 方法</li>
<li><code>instanceof</code> 关键字</li>
<li><code>Object.prototype.toString</code> 方法</li>
</ol>
<h3 id="6-谈谈你对闭包的理解？（-高-）"><a href="#6-谈谈你对闭包的理解？（-高-）" class="headerlink" title="6. 谈谈你对闭包的理解？（ 高 ）"></a>6. 谈谈你对闭包的理解？（ 高 ）</h3><p>闭包简单来说就是 <strong>函数与其词法环境的结合</strong>。当一个内部函数引用了外部函数的变量，即使外部函数执行完毕，这些变量依然会被保留在内存中，不会被销毁，这种机制就是闭包。</p>
<p>闭包的优点是可以 维持变量状态 和 实现封装，但要注意滥用可能导致内存泄漏，比如在循环中意外保留不需要的变量。实际项目中，像防抖、节流、柯里化等场景都会用到闭包，但需要合理管理生命周期。</p>
<h3 id="7-闭包的应用有哪些？（-高-）"><a href="#7-闭包的应用有哪些？（-高-）" class="headerlink" title="7. 闭包的应用有哪些？（ 高 ）"></a>7. 闭包的应用有哪些？（ 高 ）</h3><p>闭包的应用非常广泛，尤其在需要 <strong>封装状态</strong> 或 <strong>延迟执行</strong> 的场景中。举几个实际例子：</p>
<p><strong>1. 防抖（Debounce）与节流（Throttle）</strong>：<br>通过闭包保存定时器状态，控制高频事件（如滚动、输入）的触发频率。</p>
<p><strong>2. 模块化与私有变量</strong>：</p>
<p>用闭包模拟私有方法，避免全局污染（如早期模块化方案）。</p>
<p><strong>3. 函数柯里化（Currying）</strong></p>
<p><strong>总结</strong>：</p>
<p>闭包的核心是 <strong>保留上下文状态</strong>，但需注意合理释放引用（如手动置空 <code>timer = null</code>），避免内存泄漏。</p>
<h3 id="8-谈谈你对原型对象、原型链的理解？（-中-）"><a href="#8-谈谈你对原型对象、原型链的理解？（-中-）" class="headerlink" title="8. 谈谈你对原型对象、原型链的理解？（ 中 ）"></a>8. 谈谈你对原型对象、原型链的理解？（ 中 ）</h3><p>原型对象和原型链是 JavaScript 实现继承的核心机制。我理解它们的核心关系是：<strong>每个对象都有一个原型（<code>__proto__</code>），而每个函数都有一个 <code>prototype</code> 属性，原型链通过 <code>__proto__</code> 串联起来，形成属性的查找链</strong>。</p>
<p>举个例子，当我们创建一个构造函数 <code>Person</code> 时，它的 <code>prototype</code> 属性会指向一个原型对象。通过 <code>new Person()</code> 生成的实例，其 <code>__proto__</code> 会指向 <code>Person.prototype</code>。如果实例访问某个属性（如 <code>toString</code>），但自身没有定义，就会沿着原型链向上查找，直到 <code>Object.prototype</code>（原型链顶端，其 <code>__proto__</code> 为 <code>null</code>）。</p>
<p>在<strong>实际应用</strong>中，原型链常用来实现继承。</p>
<h3 id="9-JS强制和隐式类型转换？（-高-）"><a href="#9-JS强制和隐式类型转换？（-高-）" class="headerlink" title="9. JS强制和隐式类型转换？（ 高 ）"></a>9. JS强制和隐式类型转换？（ 高 ）</h3><p><strong>强制类型转换：</strong></p>
<ol>
<li><code>parseInt</code> 强制转换为整型</li>
<li><code>Number</code>强制转换为数值型</li>
<li><code>parseFloat</code>强制转换为浮点型</li>
<li><code>Boolean</code> 强制转换为布尔</li>
<li><code>String</code> 强制转换为字符串</li>
</ol>
<p><strong>隐式类型转换：</strong></p>
<ol>
<li><code>true+true</code> 输出 2</li>
<li><code>1+&#39;1&#39;</code> 输出 11</li>
<li><code>null == undefined</code> 输出 true</li>
<li><code>&#39;2&#39;&gt;1</code> 输出 true</li>
<li><code>!&#39;ab&#39;</code> 输出 false</li>
</ol>
<h3 id="10-JS的事件机制是什么？（-中-）"><a href="#10-JS的事件机制是什么？（-中-）" class="headerlink" title="10. JS的事件机制是什么？（ 中 ）"></a>10. JS的事件机制是什么？（ 中 ）</h3><p>JavaScript 的事件机制基于 <code>事件循环（Event Loop）</code> 和 <code>事件驱动模型</code>，核心是 <code>事件冒泡与捕获</code>、<code>事件代理</code> 和 <code>异步回调</code>。</p>
<p><strong>事件流</strong>：</p>
<ol>
<li><strong>捕获阶段</strong>：事件从 <code>window</code> 向下传播到目标元素。</li>
<li><strong>目标阶段</strong>：事件到达目标元素。</li>
<li><strong>冒泡阶段</strong>：事件从目标元素向上冒泡到 <code>window</code>。<br>通过 <code>addEventListener</code> 的第三个参数控制监听阶段（<code>true</code> 为捕获，默认 <code>false</code> 为冒泡）。</li>
</ol>
<p><strong>事件代理（委托）</strong>：</p>
<p>利用冒泡机制，在父元素统一处理子元素事件，适合动态内容或批量元素。</p>
<p><strong>事件对象</strong>：</p>
<ol>
<li><code>e.target</code>：触发事件的元素。</li>
<li><code>e.currentTarget</code>：绑定事件的元素。</li>
<li><code>e.stopPropagation()</code>：阻止事件传播。</li>
<li><code>e.preventDefault()</code>：阻止默认行为（如链接跳转）。</li>
</ol>
<p><strong>异步事件处理</strong>：<br>用户交互（如点击、输入）或异步操作（如 <code>setTimeout</code>）会生成事件任务，进入事件队列，由事件循环按顺序执行。</p>
<p><strong>总结</strong>：事件机制通过冒泡&#x2F;捕获实现层级响应，利用代理优化性能，结合异步模型实现非阻塞交互。理解这一机制对开发高性能应用和排查事件问题非常关键</p>
<h3 id="11-JS事件代理的原理？（-高-）"><a href="#11-JS事件代理的原理？（-高-）" class="headerlink" title="11. JS事件代理的原理？（ 高 ）"></a>11. JS事件代理的原理？（ 高 ）</h3><p>**事件代理的原理是：**利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>具体来说，就是利用事件冒泡，在父元素上绑定事件，当子元素触发事件时，会向上冒泡，父元素的事件处理程序就会处理该事件。</p>
<p>这样，父元素只需要管理一次事件，就可以管理子元素的所有事件。</p>
<h3 id="12-0-1-0-2-为什么不等-0-3-？（-高-）"><a href="#12-0-1-0-2-为什么不等-0-3-？（-高-）" class="headerlink" title="12. 0.1 + 0.2 为什么不等 0.3 ？（ 高 ）"></a>12. 0.1 + 0.2 为什么不等 0.3 ？（ 高 ）</h3><p>这是因为 JavaScript 使用 <code>IEEE 754 双精度浮点数</code> 存储数值，而某些十进制小数（如 <code>0.1</code>、<code>0.2</code>）在二进制中是无限循环的，导致精度丢失。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>使用整数运算代替小数（如以分为单位计算金额）。</li>
<li>使用 <code>toFixed(n)</code> 四舍五入（但返回字符串）。</li>
<li>引入精确计算库（如 <code>decimal.js</code>）。</li>
</ol>
<p><strong>总结</strong>：</p>
<p>这是计算机浮点数运算的通用问题，并非 JavaScript 独有，理解它对处理金融等精度敏感场景至关重要。</p>
<h3 id="13-call、bind和apply的区别？（-高-）"><a href="#13-call、bind和apply的区别？（-高-）" class="headerlink" title="13. call、bind和apply的区别？（ 高 ）"></a>13. call、bind和apply的区别？（ 高 ）</h3><p><code>call</code>、<code>apply</code>、<code>bind</code>都是改变<code>this</code>指向的方法<br><code>call</code>和<code>apply</code>第2个参数不同，<code>call</code>是函数参数序列，而<code>apply</code>是数组形式<br><code>bind</code>返回对应函数, 便于稍后调用，<code>apply</code>和 <code>call</code>则是立即调用。<br>在 <code>ES6</code> 的箭头函数下, <code>call</code> 和 <code>apply</code> 将失效</p>
<h3 id="14-this有几种指向？（-高-）"><a href="#14-this有几种指向？（-高-）" class="headerlink" title="14. this有几种指向？（ 高 ）"></a>14. this有几种指向？（ 高 ）</h3><ol>
<li>作为函数调用时，<code>this</code>指向全局对象<code>window</code></li>
<li>作为方法调用时，<code>this</code>指向调用它的那个对象</li>
<li>作为构造函数调用时，<code>this</code>指向新创建的对象</li>
<li>作为<code>apply</code>、<code>call</code>、<code>bind</code>调用时，<code>this</code>指向指定的对象</li>
<li>箭头函数没有自己的<code>this</code>，它的<code>this</code>继承自外层作用域的<code>this</code></li>
</ol>
<h3 id="15-localStorage、sessionStorage和cookie的区别？（-高-）"><a href="#15-localStorage、sessionStorage和cookie的区别？（-高-）" class="headerlink" title="15. localStorage、sessionStorage和cookie的区别？（ 高 ）"></a>15. localStorage、sessionStorage和cookie的区别？（ 高 ）</h3><p><strong>存储位置</strong></p>
<p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。<br><code>cookie</code>数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
<p><strong>存储大小</strong></p>
<p><code>cookie</code>数据大小不能超过4k。<br><code>sessionStorage</code>和<code>localStorage</code> 虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到<code>5M</code>或更大。</p>
<p><strong>生命周期</strong></p>
<p><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除。<br><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h3 id="16-阻止默认动作和阻止冒泡是什么？（-高-）"><a href="#16-阻止默认动作和阻止冒泡是什么？（-高-）" class="headerlink" title="16. 阻止默认动作和阻止冒泡是什么？（ 高 ）"></a>16. 阻止默认动作和阻止冒泡是什么？（ 高 ）</h3><p><strong>阻止默认动作：</strong></p>
<ol>
<li><code>w3c</code>的方法是<code>e.preventDefault()</code></li>
<li><code>IE</code>则是使用<code>e.returnValue = false</code></li>
</ol>
<p><strong>阻止冒泡：</strong></p>
<ol>
<li><code>w3c</code>的方法是&#96;e.stopPropagation()&#96;&#96;</li>
<li><code>IE</code>则是使用<code>e.cancelBubble = true</code></li>
</ol>
<h3 id="17-前端性能有优化有哪些？-（-高-）"><a href="#17-前端性能有优化有哪些？-（-高-）" class="headerlink" title="17. 前端性能有优化有哪些？ （ 高 ）"></a>17. 前端性能有优化有哪些？ （ 高 ）</h3><p>前端性能优化我主要从 <code>加载速度</code> 和 <code>运行效率</code> 两方面入手：</p>
<ol>
<li><strong>加载优化</strong>：<ul>
<li><strong>压缩资源</strong>：<code>CSS/JS</code> 用 <code>Webpack</code> 压缩，图片转 <code>WebP</code>、懒加载。</li>
<li><strong>减少请求</strong>：合并文件、雪碧图、<code>HTTP/2</code> 多路复用。</li>
<li><strong>缓存策略</strong>：强缓存（<code>Cache-Control</code>）、协商缓存（<code>ETag</code>）。</li>
<li><strong>CDN 加速</strong>：静态资源分发，减少延迟。</li>
</ul>
</li>
<li><strong>渲染优化</strong>：<ul>
<li><strong>防抖&#x2F;节流</strong>：减少高频事件触发（如滚动、输入）。</li>
<li><strong>减少重排</strong>：避免频繁操作 <code>DOM</code>，用 <code>transform</code> 做动画。</li>
<li><strong>代码分割</strong>：Webpack 动态加载，首屏只加载必要代码。</li>
</ul>
</li>
<li><strong>工具辅助</strong>：<ul>
<li><strong>Lighthouse</strong> 分析性能瓶颈，针对性优化。</li>
<li><strong>SSR&#x2F;SSG</strong>：提升首屏速度（如 <code>Next.js</code>）。</li>
</ul>
</li>
</ol>
<p>比如最近项目中，通过图片懒加载和路由级代码分割，首屏加载时间减少了 <code>35%</code>。</p>
<h3 id="18-http状态码有哪些？（-高-）"><a href="#18-http状态码有哪些？（-高-）" class="headerlink" title="18. http状态码有哪些？（ 高 ）"></a>18. http状态码有哪些？（ 高 ）</h3><p>HTTP状态码分为<code>5</code>类，常见的包括：</p>
<ol>
<li><strong>1xx（信息响应）</strong>：<ul>
<li><code>100 Continue</code>：客户端应继续请求（多用于大文件上传）。</li>
</ul>
</li>
<li><strong>2xx（成功）</strong>：<ul>
<li><code>200 OK</code>：请求成功（最常用）。</li>
<li><code>201 Created</code>：资源创建成功（如POST请求）。</li>
<li><code>204 No Content</code>：成功但无返回内容（如DELETE请求）。</li>
</ul>
</li>
<li><strong>3xx（重定向）</strong>：<ul>
<li><code>301 Moved Permanently</code>：资源永久重定向（SEO权重转移）。</li>
<li><code>302 Found</code>：资源临时重定向（如登录跳转）。</li>
<li><code>304 Not Modified</code>：缓存未过期，使用本地缓存。</li>
</ul>
</li>
<li><strong>4xx（客户端错误）</strong>：<ul>
<li><code>400 Bad Request</code>：请求格式错误（如参数缺失）。</li>
<li><code>401 Unauthorized</code>：未认证（如未登录）。</li>
<li><code>403 Forbidden</code>：无权限访问（如权限不足）。</li>
<li><code>404 Not Found</code>：资源不存在。</li>
</ul>
</li>
<li><strong>5xx（服务端错误）</strong>：<ul>
<li><code>500 Internal Server Error</code>：服务器内部错误（代码异常）。</li>
<li><code>502 Bad Gateway</code>：网关错误（如反向代理问题）。</li>
<li><code>503 Service Unavailable</code>：服务不可用（如服务器过载）。</li>
</ul>
</li>
</ol>
<p><strong>重点掌握</strong>：<code>200</code>、<code>304</code>、<code>401</code>、<code>404</code>、<code>500</code>，这些在开发调试中最常见，能快速定位问题类型（客户端&#x2F;服务端）。</p>
<h3 id="19-JS浅拷贝和深拷贝？（-高-）"><a href="#19-JS浅拷贝和深拷贝？（-高-）" class="headerlink" title="19. JS浅拷贝和深拷贝？（ 高 ）"></a>19. JS浅拷贝和深拷贝？（ 高 ）</h3><p>浅拷贝和深拷贝的区别在于 <code>对引用类型数据的复制深度</code>：</p>
<p><strong>1. 浅拷贝</strong>：</p>
<ul>
<li><p><strong>定义</strong>：只复制对象的第一层属性，若属性是引用类型（如对象、数组），新旧对象会共享同一内存地址。</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);  </span><br><span class="line"><span class="comment">// 或  </span></span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问题</strong>：修改嵌套的引用属性会影响原对象。</p>
</li>
</ul>
<p><strong>2. 深拷贝</strong>：</p>
<ul>
<li><p><strong>定义</strong>：递归复制所有层级，新旧对象完全独立。</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：JSON（无法处理函数、循环引用）  </span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：手动递归或使用库（如 lodash.cloneDeep）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关键区别</strong>：</p>
<ul>
<li>浅拷贝：<code>obj.a === copy.a</code>（引用相同）</li>
<li>深拷贝：<code>obj.a !== copy.a</code>（引用不同）</li>
</ul>
<h3 id="20-new关键字做了什么？（-低-）"><a href="#20-new关键字做了什么？（-低-）" class="headerlink" title="20. new关键字做了什么？（ 低 ）"></a>20. new关键字做了什么？（ 低 ）</h3><p><code>new</code> 共经历了五个过程。<br>1.创建一个空对象，作为将要返回的对象实例<br>2.将这个空对象的原型，指向构造函数的<code>prototype</code>属性<br>3.将这个空对象赋值给函数内部的<code>this</code>关键字<br>4.开始执行构造函数内部的代码。<br>5.如果返回来的是对象则输出这个对象，否则输出上面的空对象</p>
<h3 id="21-ajax的原理是什么？（-低-）"><a href="#21-ajax的原理是什么？（-低-）" class="headerlink" title="21. ajax的原理是什么？（ 低 ）"></a>21. ajax的原理是什么？（ 低 ）</h3><p><code>ajax</code>基于<code>XMLHttpRequest</code>对象与<code>Web</code>服务器端进行异步数据通信。<br>首先基于这个对象的open方法创建一个浏览器跟服务器端连接，通过<code>send</code>方法从浏览器向服务器端发送请求。我们可以通过这个对象的<code>onreadystatechange</code>事件来监听请求的状态，当请求成功之后的话，我可以获取到这个对象<code>responseText</code>等方法获取到请求过来的数据，然后通过<code>js</code>对这些数据进行解析。</p>
<h3 id="22-同步和异步的区别？（-高-）"><a href="#22-同步和异步的区别？（-高-）" class="headerlink" title="22. 同步和异步的区别？（ 高 ）"></a>22. 同步和异步的区别？（ 高 ）</h3><p>同步和异步的核心区别在于 <code>任务执行模式</code>：</p>
<p><strong>同步（Synchronous）</strong>：</p>
<ol>
<li><strong>顺序执行</strong>：代码逐行执行，前一个任务未完成时，后续任务会被阻塞。</li>
<li><strong>场景</strong>：简单逻辑（如计算、变量赋值）。</li>
<li><strong>代码特征</strong>：无回调或 <code>await</code>，直观但可能阻塞主线程。</li>
</ol>
<p><strong>异步（Asynchronous）</strong>：</p>
<ol>
<li><strong>非阻塞执行</strong>：任务发起后不等待结果，继续执行后续代码，通过回调、<code>Promise</code> 或事件通知结果。</li>
<li><strong>场景</strong>：耗时操作（如网络请求、文件读写）。</li>
<li><strong>代码特征</strong>：常见 <code>setTimeout</code>、<code>fetch</code>、<code>async/await</code>。</li>
</ol>
<h3 id="23-跨域有几种方式？（-高-）"><a href="#23-跨域有几种方式？（-高-）" class="headerlink" title="23. 跨域有几种方式？（ 高 ）"></a>23. 跨域有几种方式？（ 高 ）</h3><p>跨域问题的本质是浏览器<strong>同源策略</strong>的限制，常用解决方案有：</p>
<ol>
<li><strong>CORS</strong>（主流方案）：<br>服务端设置响应头（如 <code>Access-Control-Allow-Origin: *</code>），允许指定域名的请求。</li>
<li><strong>JSONP</strong>（仅限 GET）：<br>通过 <code>&lt;script&gt;</code> 标签跨域请求，利用回调函数接收数据（如 <code>?callback=handleData</code>）。</li>
<li><strong>代理服务器</strong>（开发常用）：<br>前端配置代理（如 <code>Webpack</code>、<code>Nginx</code>），将请求转发到同源的服务端，再由服务端请求目标接口。</li>
<li><strong>WebSocket</strong>：<br>协议本身支持跨域通信（如实时聊天场景）。</li>
<li><strong>postMessage</strong>：<br>跨窗口通信（如 iframe 与父页面）。</li>
</ol>
<p><strong>实际应用</strong>：</p>
<ul>
<li>开发环境用代理（如 <code>vite.config.js</code> 配置 <code>proxy</code>）。</li>
<li>生产环境用 <strong>CORS</strong>，精细控制允许的域名和请求方法。</li>
<li>老旧系统可能用 JSONP（但安全性低）。</li>
</ul>
<p>其他方案如 <code>document.domain</code>（同主域不同子域）、<code>Nginx 反向代理</code> 也常见，但需结合场景选择。</p>
<h3 id="24-web安全防护有几种？（-中-）"><a href="#24-web安全防护有几种？（-中-）" class="headerlink" title="24. web安全防护有几种？（ 中 ）"></a>24. web安全防护有几种？（ 中 ）</h3><p>Web安全防护主要围绕防御常见攻击展开，核心手段包括：</p>
<ol>
<li><strong>XSS（跨站脚本）防御</strong>：<ul>
<li><strong>转义用户输入</strong>：对 <code>&lt;</code>, <code>&gt;</code> 等特殊字符编码。</li>
<li><strong>CSP（内容安全策略）</strong>：通过HTTP头限制资源加载源（如 <code>Content-Security-Policy</code>）。</li>
<li><strong>HttpOnly Cookie</strong>：防止脚本窃取敏感<code>Cookie</code>。</li>
</ul>
</li>
<li><strong>CSRF（跨站请求伪造）防御</strong>：<ul>
<li><strong>Token验证</strong>：请求携带服务端生成的<code>Token</code>（如<code>JWT</code>）。</li>
<li><strong>SameSite Cookie</strong>：设置 <code>SameSite=Strict</code> 限制跨域携带Cookie。</li>
</ul>
</li>
<li><strong>SQL注入防御</strong>：<ul>
<li><strong>参数化查询</strong>：使用ORM或预处理语句（如MySQL的 <code>prepare</code>）。</li>
<li><strong>最小化数据库权限</strong>：避免使用高权限账号连接数据库。</li>
</ul>
</li>
<li><strong>点击劫持防御</strong>：<ul>
<li><strong>设置HTTP头</strong>：<code>X-Frame-Options: DENY</code> 禁止页面被嵌入iframe。</li>
</ul>
</li>
<li><strong>安全传输</strong>：<ul>
<li><strong>HTTPS</strong>：加密通信，防止中间人攻击。</li>
<li><strong>HSTS</strong>：强制浏览器使用HTTPS（<code>Strict-Transport-Security</code>）。</li>
</ul>
</li>
</ol>
<p><strong>其他实践</strong>：</p>
<ul>
<li>输入验证：前端+后端双重校验（如正则表达式）。</li>
<li>依赖安全：定期更新第三方库（如 <code>npm audit</code>）。</li>
<li>日志监控：记录异常请求，及时告警。</li>
</ul>
<h3 id="25-es5如何实现继承？（-低-）"><a href="#25-es5如何实现继承？（-低-）" class="headerlink" title="25. es5如何实现继承？（ 低 ）"></a>25. es5如何实现继承？（ 低 ）</h3><p>在 ES5 中，常用 <strong>组合继承</strong>（构造函数继承 + 原型链继承）实现继承，步骤如下：</p>
<ol>
<li><p><strong>构造函数继承属性</strong>：<br>在子类构造函数中调用父类构造函数，继承实例属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承父类属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原型链继承方法</strong>：<br>将子类原型指向父类实例，继承原型方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修正构造函数指向</strong>：<br>确保子类实例的 <code>constructor</code> 正确指向自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>问题</strong>：组合继承会调用两次父类构造函数（<code>Parent.call</code> 和 <code>new Parent()</code>），导致原型链冗余。</p>
<p><strong>优化方案—寄生组合继承</strong>（推荐)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建父类原型副本</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 修正构造函数</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值给子类原型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用  </span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);  </span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ul>
<li><strong>组合继承</strong>：简单直观，但有性能开销。</li>
<li><strong>寄生组合继承</strong>：高效解决重复调用问题，是 <code>ES5</code> 继承的最佳实践。</li>
</ul>
<h3 id="26-数组find和filter的区别？（-中-）"><a href="#26-数组find和filter的区别？（-中-）" class="headerlink" title="26.  数组find和filter的区别？（ 中 ）"></a>26.  数组find和filter的区别？（ 中 ）</h3><p><code>find</code> 和 <code>filter</code> 都是用于筛选数组的方法，核心区别在于 <strong>返回值和用途</strong>：</p>
<p><strong><code>find</code></strong>：</p>
<ol>
<li><strong>返回第一个匹配项</strong>：找到符合条件的元素后立即停止遍历。</li>
<li><strong>返回值</strong>：元素本身，找不到返回 <code>undefined</code>。</li>
<li><strong>场景</strong>：查找唯一项（如通过 <code>id</code> 获取对象）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;];  </span><br><span class="line"><span class="keyword">const</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">id</span> === <span class="number">2</span>); <span class="comment">// &#123;id: 2&#125;  </span></span><br></pre></td></tr></table></figure>

<p><strong><code>filter</code></strong>：</p>
<ol>
<li><strong>返回所有匹配项</strong>：遍历整个数组，收集所有符合条件的元素。</li>
<li><strong>返回值</strong>：新数组（即使空或无匹配）。</li>
<li><strong>场景</strong>：筛选多个元素（如过滤状态为“完成”的任务）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> evens = nums.<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// [2, 4]  </span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ul>
<li><code>find</code>：找单个，效率高。</li>
<li><code>filter</code>：找多个，返回数组。</li>
</ul>
<h3 id="27-数组slice和splice的区别？（-低-）"><a href="#27-数组slice和splice的区别？（-低-）" class="headerlink" title="27. 数组slice和splice的区别？（ 低 ）"></a>27. 数组slice和splice的区别？（ 低 ）</h3><p><code>slice</code> 和 <code>splice</code> 都是操作数组的方法，核心区别在于 <strong>是否修改原数组</strong> 和 <strong>用途</strong>：</p>
<p><strong><code>slice</code></strong>：</p>
<ol>
<li><p><strong>作用</strong>：截取数组的一部分，返回新数组（浅拷贝）。</p>
</li>
<li><p><strong>参数</strong>：<code>slice(startIndex, endIndex)</code>（包前不包后）。</p>
</li>
<li><p><strong>不修改原数组</strong>：原数组保持不变。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> sub = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [2, 3]  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3, 4]（原数组未变）  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>splice</code></strong>：</p>
<ol>
<li><strong>作用</strong>：删除、替换或插入元素，直接修改原数组。</li>
<li><strong>参数</strong>：<code>splice(startIndex, deleteCount, items...)</code>。</li>
<li><strong>修改原数组</strong>：返回被删除的元素组成的数组。</li>
<li><strong>示例</strong>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  </span><br><span class="line"><span class="keyword">const</span> deleted = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 删除2个元素（2和3），插入5  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deleted); <span class="comment">// [2, 3]  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 5, 4]（原数组被修改）  </span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ul>
<li><code>slice</code>：<strong>不修改原数组</strong>，用于截取片段。</li>
<li><code>splice</code>：<strong>修改原数组</strong>，用于增删改元素。</li>
</ul>
<h3 id="28-数组reduce干什么？（-低-）"><a href="#28-数组reduce干什么？（-低-）" class="headerlink" title="28. 数组reduce干什么？（ 低 ）"></a>28. 数组reduce干什么？（ 低 ）</h3><p><code>reduce</code> 是数组的聚合方法，<strong>遍历每个元素并通过回调函数逐步累积为单个值</strong>，接收一个回调（参数：累计值、当前元素等）和初始值。常用于求和、数组转对象、扁平化等场景，例如 <code>[1,2,3].reduce((acc, num) =&gt; acc + num, 0)</code> 输出 6。注意需合理设置初始值，避免空数组报错。</p>
<h3 id="29-substr和slice方法的区别？（-低-）"><a href="#29-substr和slice方法的区别？（-低-）" class="headerlink" title="29. substr和slice方法的区别？（ 低 ）"></a>29. substr和slice方法的区别？（ 低 ）</h3><p><code>substr</code> 和 <code>slice</code> 都是截取字符串的方法，但参数规则不同：</p>
<ul>
<li><strong><code>substr(start, length)</code></strong>：从 <code>start</code> 索引开始截取指定长度的子串（<code>length</code> 为负时视为 <code>0</code>）。</li>
<li><strong><code>slice(start, end)</code></strong>：截取从 <code>start</code> 到 <code>end</code>（不包含 <code>end</code>）的子串，支持负数索引（从末尾算起）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello World&quot;</span>;  </span><br><span class="line">str.<span class="title function_">substr</span>(<span class="number">6</span>, <span class="number">5</span>);   <span class="comment">// &quot;World&quot;（第6位开始，取5字符）  </span></span><br><span class="line">str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">11</span>);   <span class="comment">// &quot;World&quot;（截取6到10位）  </span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：优先用 <code>slice</code>（参数更直观），<code>substr</code> 逐渐被废弃。</p>
<h3 id="30-什么宏任务和微任务？执行顺序是什么？（-中-）"><a href="#30-什么宏任务和微任务？执行顺序是什么？（-中-）" class="headerlink" title="30. 什么宏任务和微任务？执行顺序是什么？（ 中 ）"></a>30. 什么宏任务和微任务？执行顺序是什么？（ 中 ）</h3><p>宏任务（Macro Task）和微任务（<code>Micro Task</code>）是 JavaScript 事件循环（<code>Event Loop</code>）中处理异步任务的两种机制，它们的执行顺序直接影响代码的运行逻辑。</p>
<p><strong>1. 宏任务（Macro Task）</strong></p>
<p><strong>定义</strong>：宏任务是 JavaScript 引擎在每一轮事件循环中处理的主要任务。<br><strong>常见宏任务</strong>：</p>
<ul>
<li><code>setTimeout</code> &#x2F; <code>setInterval</code></li>
<li>DOM 事件回调（如点击事件）</li>
<li><code>requestAnimationFrame</code>（浏览器端）</li>
<li>I&#x2F;O 操作（如文件读取、网络请求）</li>
<li>UI 渲染（浏览器端）</li>
<li>整体脚本代码（<code>&lt;script&gt;</code> 标签内的代码本身是一个宏任务）</li>
</ul>
<p><strong>2. 微任务（Micro Task）</strong></p>
<p><strong>定义</strong>：微任务是在当前宏任务执行完成后、下一个宏任务开始前立即执行的任务，优先级高于宏任务。<br><strong>常见微任务</strong>：</p>
<ul>
<li><p><code>Promise.then()</code>  &#x2F;  <code>Promise.catch()</code>  &#x2F;  <code>Promise.finally()</code></p>
</li>
<li><p><code>MutationObserver</code>（浏览器端）</p>
</li>
<li><p><code>queueMicrotask()</code></p>
</li>
<li><p><code>process.nextTick()</code>（Node.js 环境，优先级高于其他微任务）</p>
</li>
</ul>
<p><strong>3. 执行顺序</strong></p>
<p>事件循环的执行规则如下：</p>
<ol>
<li><strong>执行一个宏任务</strong>（如整体脚本或 <code>setTimeout</code> 回调）。</li>
<li><strong>执行所有微任务</strong>：当前宏任务结束后，立即清空微任务队列。</li>
<li><strong>更新渲染</strong>（浏览器可能在此处进行 UI 渲染）。</li>
<li><strong>重复循环</strong>：从宏任务队列中取下一个宏任务执行。</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>微任务优先级高于宏任务</strong>：同一事件循环中，微任务会在下一个宏任务之前全部执行完毕。</li>
<li><strong>微任务队列必须清空</strong>：即使微任务中又产生了新的微任务，也会被立即执行，直到队列为空。</li>
</ul>
<h3 id="31-什么事件循环？（-中-）"><a href="#31-什么事件循环？（-中-）" class="headerlink" title="31. 什么事件循环？（ 中 ）"></a>31. 什么事件循环？（ 中 ）</h3><p>JavaScript 是单线程语言，<strong>事件循环（<code>Event Loop</code>）</strong> 是实现异步非阻塞的核心机制。它的工作原理可以概括为：</p>
<ol>
<li><p><strong>同步代码</strong>立即执行，形成“调用栈”。</p>
</li>
<li><p>异步操作</p>
<p>（如<code>setTimeout</code>、<code>Promise</code>）会被挂起，完成后将回调推入对应的任务队列：</p>
<ul>
<li><strong>宏任务队列</strong>（MacroTask Queue）：如 <code>setTimeout</code>、DOM 事件、I&#x2F;O 操作。</li>
<li><strong>微任务队列</strong>（MicroTask Queue）：如 <code>Promise.then()</code>、<code>MutationObserver</code>。</li>
</ul>
</li>
<li><p>事件循环的流程</p>
<ul>
<li>执行完调用栈中的同步代码（即当前宏任务）。</li>
<li>清空所有微任务队列中的回调（优先级高）。</li>
<li>若有需要，更新 UI 渲染（浏览器）。</li>
<li>从宏任务队列中取下一个任务，开启新一轮循环。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>微任务在<strong>本轮事件循环末尾</strong>立即执行，宏任务在<strong>下一轮循环</strong>执行。</li>
<li>异步代码的执行顺序受任务类型（宏&#x2F;微）和队列机制控制。</li>
</ul>
<h3 id="32-setTimeout能保证执行时间准确吗？（-中-）"><a href="#32-setTimeout能保证执行时间准确吗？（-中-）" class="headerlink" title="32. setTimeout能保证执行时间准确吗？（ 中 ）"></a>32. setTimeout能保证执行时间准确吗？（ 中 ）</h3><p>**不能保证，因为JS 是单线程的，若主线程被同步代码（如复杂计算）长时间占用，<code>setTimeout</code> 回调必须等待，导致延迟执行。</p>
<p><code>setTimeout</code> <strong>仅保证回调在指定时间后加入队列，不保证准时执行</strong>。高精度定时需求可用 <code>requestAnimationFrame</code>实现。</p>
<h3 id="33-什么是柯里化函数？（-低-）"><a href="#33-什么是柯里化函数？（-低-）" class="headerlink" title="33. 什么是柯里化函数？（ 低 ）"></a>33. 什么是柯里化函数？（ 低 ）</h3><ul>
<li><strong>普通函数</strong>：<code>func(a, b, c)</code> → 一次性传入所有参数。</li>
<li><strong>柯里化函数</strong>：<code>func(a)(b)(c)</code> → 每次传入一个参数，返回新函数，直到参数齐全后执行。</li>
</ul>
<p><strong>柯里化的核心作用</strong></p>
<ol>
<li><p><strong>参数复用</strong>：固定部分参数，生成更专用的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add5 = <span class="title function_">curriedAdd</span>(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 固定前两个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">5</span>)); <span class="comment">// 2+3+5=10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>延迟执行</strong>：参数未齐全时，返回中间函数，灵活组合。</p>
</li>
<li><p><strong>函数组合</strong>：便于组合流水线式操作（如 <code>compose(func1, func2)</code>）。</p>
</li>
</ol>
<h3 id="34-创建、删除、复制、替换、插入和查找节点？（-低-）"><a href="#34-创建、删除、复制、替换、插入和查找节点？（-低-）" class="headerlink" title="34. 创建、删除、复制、替换、插入和查找节点？（ 低 ）"></a>34. 创建、删除、复制、替换、插入和查找节点？（ 低 ）</h3><p><strong>1. 创建新节点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createElement</span>() <span class="comment">//创建一个具体的元素</span></span><br><span class="line"><span class="title function_">createTextNode</span>() <span class="comment">//创建一个文本节点</span></span><br><span class="line"><span class="title function_">createDocumentFragment</span>() <span class="comment">//创建一个DOM片段</span></span><br></pre></td></tr></table></figure>


<p><strong>2.添加、移除、替换、之前插入、之后插入、复制节点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>() <span class="comment">//内部后面追加节点</span></span><br><span class="line"><span class="title function_">removeChild</span>() <span class="comment">//删除子节点</span></span><br><span class="line"><span class="title function_">replaceChild</span>() <span class="comment">//替换子节点</span></span><br><span class="line"><span class="title function_">insertBefore</span>() <span class="comment">//在已有的子节点前插入一个新的子节点</span></span><br><span class="line"><span class="title function_">insertAfter</span>() <span class="comment">//方法在被选元素后插入 `HTML` 元素。</span></span><br><span class="line"><span class="title function_">cloneNode</span>() <span class="comment">//复制节点</span></span><br></pre></td></tr></table></figure>

<p><strong>3.查找节点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 通过标签名称</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);  <span class="comment">// 通过元素的Name属性的值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;gender&#x27;</span>); <span class="comment">// 通过元素Id，唯一性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// 通过类查找</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">//通过css类型查找</span></span><br></pre></td></tr></table></figure>



<h3 id="35-JS异步加载有哪些？（-低-）"><a href="#35-JS异步加载有哪些？（-低-）" class="headerlink" title="35. JS异步加载有哪些？（ 低 ）"></a>35. JS异步加载有哪些？（ 低 ）</h3><ol>
<li><code>script</code> 标签的 <code>async</code> 属性，兼容性<code>IE9+</code></li>
<li><code>script</code> 的 <code>defer</code> 属性，兼容所有的浏览器</li>
<li>动态创建<code>script</code>标签，兼容所有的浏览器</li>
<li><code>ajax</code>加载脚本内容，兼容所有的浏览器</li>
<li><code>iframe</code>方式，兼容所有的浏览器</li>
</ol>
<h3 id="36-如何封装axios？（-高-）"><a href="#36-如何封装axios？（-高-）" class="headerlink" title="36. 如何封装axios？（ 高 ）"></a>36. 如何封装axios？（ 高 ）</h3><p><strong>1. 实例化与全局配置</strong></p>
<ul>
<li>创建一个 <code>Axios</code> 实例，集中配置 <code>baseURL</code>、超时时间、默认请求头等公共参数，避免每个请求重复编写。</li>
<li>通过环境变量区分不同环境的 <code>API</code> 地址（如开发、测试、生产环境）。</li>
</ul>
<p><strong>2. 拦截器设计</strong></p>
<ul>
<li><strong>请求拦截器：</strong><ul>
<li><strong>身份认证</strong>：在请求头自动注入 <code>Token</code>（如从<code> localStorage</code> 或<code>Vuex</code> 读取）。</li>
<li><strong>数据预处理</strong>：根据需求转换请求数据格式（如序列化表单数据）。</li>
<li><strong>特殊逻辑</strong>：针对特定接口动态修改配置（如单独设置 <code>Content-Type</code> 为 <code>multipart/form-data</code> 上传文件）。</li>
</ul>
</li>
<li><strong>响应拦截器</strong>：<ul>
<li><strong>统一错误处理</strong>：拦截 HTTP 状态码（如 <code>401</code> 跳转登录页、<code>500</code> 提示服务异常）和业务自定义错误码（如后端返回的 <code>code ≠ 200</code>）。</li>
<li><strong>数据过滤</strong>：剥离 <code>Axios</code> 响应结构，直接返回业务核心数据（如 <code>response.data.data</code>）。</li>
<li><strong>异常提示</strong>：结合 UI 库（如 <code>Element UI</code> 的 <code>Message</code>）全局提示错误信息，避免每个请求单独处理。</li>
</ul>
</li>
</ul>
<p><strong>3. 封装请求方法</strong></p>
<ul>
<li>将常用的 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等方法二次封装，暴露语义化的 <code>API</code>（如 <code>get(url, params)</code>、<code>post(url, data)</code>）。</li>
<li>保留 <code>Axios</code> 的配置灵活性，允许调用时覆盖默认配置（如某个接口单独设置超时时间）。</li>
</ul>
<h3 id="37-get请求默认是有缓存的，如何让它不缓存？（-低-）"><a href="#37-get请求默认是有缓存的，如何让它不缓存？（-低-）" class="headerlink" title="37. get请求默认是有缓存的，如何让它不缓存？（ 低 ）"></a>37. get请求默认是有缓存的，如何让它不缓存？（ 低 ）</h3><p>浏览器根据完整 <code>URL</code> 判断是否缓存。若每次请求的 <code>URL</code> 不同，则强制不缓存。</p>
<p>在 URL 后添加随机参数（如时间戳或随机数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：每次请求附加时间戳</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/data?_t=&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br></pre></td></tr></table></figure>



<h3 id="38-谈谈js的单例模式？（-中-）"><a href="#38-谈谈js的单例模式？（-中-）" class="headerlink" title="38. 谈谈js的单例模式？（ 中 ）"></a>38. 谈谈js的单例模式？（ 中 ）</h3><p>单例模式确保一个类<strong>只有一个实例</strong>，并提供全局访问点，适用于需要共享资源或控制唯一性的场景（如全局状态管理、日志服务）。</p>
<p><strong>实现方式（ES6为例）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;  </span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="variable language_">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 使用  </span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b); <span class="comment">// true  </span></span><br></pre></td></tr></table></figure>

<p><strong>闭包实现（兼容ES5）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Singleton</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> instance;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;  </span><br><span class="line">      instance = &#123; <span class="comment">/* 单例对象 */</span> &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;)();  </span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>延迟初始化</strong>：首次调用时创建实例。</li>
<li><strong>全局访问</strong>：通过固定入口（如静态方法）获取实例。</li>
</ul>
<h3 id="39-谈谈js的订阅发布者模式？（-中-）"><a href="#39-谈谈js的订阅发布者模式？（-中-）" class="headerlink" title="39. 谈谈js的订阅发布者模式？（ 中 ）"></a>39. 谈谈js的订阅发布者模式？（ 中 ）</h3><p>发布-订阅模式（<code>Pub</code>&#x2F;<code>Sub</code>）是一种<strong>解耦通信机制</strong>，核心是 <strong>事件中心</strong> 管理事件的订阅与发布。</p>
<p><strong>核心流程</strong>：</p>
<ol>
<li><strong>订阅者</strong>通过 <code>on</code> 方法注册事件和回调函数。</li>
<li><strong>发布者</strong>通过 <code>emit</code> 方法触发事件，通知所有订阅者。</li>
<li><strong>事件中心</strong>负责维护事件与回调的映射关系。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;  </span><br><span class="line">    (<span class="variable language_">this</span>.<span class="property">events</span>[event] || (<span class="variable language_">this</span>.<span class="property">events</span>[event] = [])).<span class="title function_">push</span>(callback);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, data</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event]?.<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(data));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, callback</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = <span class="variable language_">this</span>.<span class="property">events</span>[event]?.<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用  </span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();  </span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));  </span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Hello!&#x27;</span>); <span class="comment">// 输出 Hello!  </span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：</p>
<ul>
<li>跨组件通信（如 <code>Vue</code> 的 <code>EventBus</code>）。</li>
<li>异步任务解耦（如消息通知、日志系统）。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>解耦</strong>：发布者和订阅者无需直接依赖。</li>
<li><strong>灵活扩展</strong>：支持多对多通信。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>事件追踪难</strong>：过度使用可能导致逻辑分散。</li>
<li><strong>内存泄漏</strong>：需及时取消订阅（<code>off</code>）。</li>
</ul>
<p><strong>总结</strong>：通过事件中心实现松耦合通信，适合复杂系统中的消息传递，但需谨慎管理订阅关系。</p>
<h3 id="40-函数防抖节流的原理？（-高-）"><a href="#40-函数防抖节流的原理？（-高-）" class="headerlink" title="40. 函数防抖节流的原理？（ 高 ）"></a>40. 函数防抖节流的原理？（ 高 ）</h3><p><strong>定义</strong><br>**函数防抖：**在事件被触发 <code>n</code> 秒后再执行回调，如果在这 <code>n</code> 秒内又被触发，则重新计时。<br>**函数节流：**在一个单位时间内，只允许一个函数执行，如果这个单位时间内触发多次函数，则只执行一次。</p>
<p><strong>实现</strong><br>函数防抖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数节流：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p><strong>函数防抖：</strong></p>
<p>页面滚动，防止短时间内多次触发回调函数，导致页面卡顿。<br>表单输入，防止用户输入过快，导致服务器压力过大。</p>
<p><strong>函数节流：</strong></p>
<p>页面动画，控制动画的执行频率，减少页面的抖动。<br>节约系统资源，比如在高频事件中执行函数，可以减少系统资源的消耗。</p>
<h3 id="41-HTTP-与-HTTPS-的区别？（-中-）"><a href="#41-HTTP-与-HTTPS-的区别？（-中-）" class="headerlink" title="41. HTTP 与 HTTPS 的区别？（ 中 ）"></a>41. HTTP 与 HTTPS 的区别？（ 中 ）</h3><p><code>HTTPS</code>协议是<code>HTTP</code>协议的安全版，即<code>HTTP</code>下加入<code>SSL</code>层，<code>HTTPS</code>的安全基础是<code>SSL/TLS</code>协议。<br><code>HTTPS</code>协议需要到<code>CA</code>申请证书，一般免费证书较少，因而费用较高。<br><code>HTTPS</code>协议可提供身份认证、保密性、完整性、可靠性。<br><code>HTTPS</code>协议是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。<br><code>HTTP</code>协议的端口号是<code>80</code>，<code>HTTPS</code>的端口号是<code>443</code>。</p>
<h3 id="42-网络7层架构？（-中-）"><a href="#42-网络7层架构？（-中-）" class="headerlink" title="42. 网络7层架构？（ 中 ）"></a>42. 网络7层架构？（ 中 ）</h3><p><strong>网络七层架构（OSI模型）</strong>：</p>
<ol>
<li><strong>物理层</strong>（<code>Physical</code>）<ul>
<li>传输原始比特流（<code>0/1</code>），定义物理介质（电缆、光纤、无线）。</li>
<li>协议示例：<code>RJ45</code>、<code>Wi-Fi</code>（<code>IEEE 802.11</code>）。</li>
</ul>
</li>
<li><strong>数据链路层</strong>（<code>Data Link</code>）<ul>
<li>将比特封装成帧，通过MAC地址实现设备间直接通信。</li>
<li>协议示例：以太网（<code>Ethernet</code>）、<code>ARP</code>、交换机。</li>
</ul>
</li>
<li><strong>网络层</strong>（<code>Network</code>）<ul>
<li>通过IP地址路由数据包，实现跨网络通信。</li>
<li>协议示例：<code>IP</code>、<code>ICMP</code>、路由器。</li>
</ul>
</li>
<li><strong>传输层</strong>（<code>Transport</code>）<ul>
<li>提供端到端可靠&#x2F;不可靠传输（<code>TCP/UDP</code>），处理流量控制和错误校验。</li>
<li>协议示例：<code>TCP</code>（三次握手）、<code>UDP</code>。</li>
</ul>
</li>
<li><strong>会话层</strong>（<code>Session</code>）<ul>
<li>建立、管理、终止会话（如连接保持、断点续传）。</li>
<li>示例：<code>RPC</code>（远程过程调用）、<code>NetBIOS</code>。</li>
</ul>
</li>
<li><strong>表示层</strong>（<code>Presentation</code>）<ul>
<li>数据格式转换（加密&#x2F;解密、压缩&#x2F;解压、编码）。</li>
<li>示例：<code>SSL/TLS</code>加密、<code>JPEG</code>&#x2F;<code>MPEG</code>编码。</li>
</ul>
</li>
<li><strong>应用层</strong>（<code>Application</code>）<ul>
<li>提供用户接口和网络服务（HTTP访问网页、SMTP发邮件）。</li>
<li>协议示例：<code>HTTP</code>、<code>FTP</code>、<code>DNS</code>、<code>SMTP</code>。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结</strong>：<br>底层（<code>1-4</code>层）管数据传输，高层（<code>5-7</code>层）管数据处理，分工明确，标准化网络通信流程。</p>
<h3 id="43-TCP与UDP的区别？（-低-）"><a href="#43-TCP与UDP的区别？（-低-）" class="headerlink" title="43. TCP与UDP的区别？（ 低 ）"></a>43. TCP与UDP的区别？（ 低 ）</h3><ol>
<li>连接方式：<code>TCP</code>是面向连接的，<code>UDP</code>是无连接的。</li>
<li>传输方式：<code>TCP</code>是可靠的，<code>UDP</code>是不可靠的。</li>
<li>传输速度：<code>TCP</code>传输速度慢，<code>UDP</code>传输速度快。</li>
<li>适用场景：<code>TCP</code>适用于可靠连接，如文件传输；<code>UDP</code>适用于实时通信，如语音、视频、直播。</li>
</ol>
<h3 id="44-什么是A类地址和B类地址？（-低-）"><a href="#44-什么是A类地址和B类地址？（-低-）" class="headerlink" title="44. 什么是A类地址和B类地址？（ 低 ）"></a>44. 什么是A类地址和B类地址？（ 低 ）</h3><p><strong>A类地址</strong>：</p>
<ul>
<li><strong>范围</strong>：<code>1.0.0.0</code> ~ <code>126.255.255.255</code></li>
<li><strong>子网掩码</strong>：<code>255.0.0.0</code>（&#x2F;8）</li>
<li><strong>用途</strong>：大型网络（如跨国企业），支持约 <strong>1677 万台主机</strong>（2²⁴ - 2）。</li>
</ul>
<p><strong>B类地址</strong>：</p>
<ul>
<li><strong>范围</strong>：<code>128.0.0.0</code> ~ <code>191.255.255.255</code></li>
<li><strong>子网掩码</strong>：<code>255.255.0.0</code>（&#x2F;16）</li>
<li><strong>用途</strong>：中型网络（如大学、企业），支持约 <strong>6.5 万台主机</strong>（2¹⁶ - 2）。</li>
</ul>
<p><strong>关键区别</strong>：</p>
<ul>
<li>A类：<strong>首字节为网络号</strong>，后三字节为主机号。</li>
<li>B类：<strong>前两字节为网络号</strong>，后两字节为主机号。</li>
<li>私有地址范围<ul>
<li>A类：<code>10.0.0.0/8</code></li>
<li>B类：<code>172.16.0.0/12</code>（<code>172.16.0.0</code> ~ <code>172.31.255.255</code>）。</li>
</ul>
</li>
</ul>
<h2 id="es6部分"><a href="#es6部分" class="headerlink" title="es6部分"></a>es6部分</h2><h3 id="1-箭头函数和普通函数的区别？（-高-）"><a href="#1-箭头函数和普通函数的区别？（-高-）" class="headerlink" title="1. 箭头函数和普通函数的区别？（ 高 ）"></a>1. 箭头函数和普通函数的区别？（ 高 ）</h3><p>相比普通函数更简洁的语法<br>不能使用<code>new</code><br>不绑定<code>arguments</code>，用<code>rest</code>参数<code>...</code>解决<br>箭头函数没有<code>this</code>，继承其所在上下文的 <code>this</code> 作为自己的 <code>this</code> 值</p>
<h3 id="2-es6新增什么特性？（-高-）"><a href="#2-es6新增什么特性？（-高-）" class="headerlink" title="2. es6新增什么特性？（ 高 ）"></a>2. es6新增什么特性？（ 高 ）</h3><p><code>ES6</code> 核心新增特性包括：</p>
<ol>
<li><strong>变量声明</strong>：<code>let</code>&#x2F;<code>const</code>（块级作用域，替代 <code>var</code>）。</li>
<li><strong>箭头函数</strong>：简化写法，<code>this</code> 指向外层（如 <code>() =&gt; &#123;&#125;</code>）。</li>
<li><strong>模板字符串</strong>：反引号包裹，支持插值和换行（如 <code>Hello $&#123;name&#125;</code>）。</li>
<li><strong>解构赋值</strong>：从数组&#x2F;对象中提取值（如 <code>const &#123; a, b &#125; = obj</code>）。</li>
<li><strong>默认参数</strong>：函数参数默认值（<code>function(a = 1) &#123;&#125;</code>）。</li>
<li><strong>模块化</strong>：<code>import</code>&#x2F;<code>export</code> 管理代码依赖。</li>
<li><strong>Promise</strong>：解决回调地狱，链式处理异步。</li>
<li><strong>Class</strong>：语法糖，基于原型的面向对象。</li>
<li><strong>Symbol</strong>：唯一值，避免属性名冲突。</li>
<li><strong>Set&#x2F;Map</strong>：新数据结构（去重集合、键值对）。</li>
<li><strong>扩展运算符</strong>：展开数组&#x2F;对象（<code>...arr</code>）。</li>
</ol>
<p><strong>典型应用</strong>：</p>
<ul>
<li>异步用 <code>Promise</code> 或 <code>async/await</code>，数据用 <code>Set/Map</code>，模块化组织代码。</li>
</ul>
<h3 id="3-谈谈你对promise的理解？（-高-）"><a href="#3-谈谈你对promise的理解？（-高-）" class="headerlink" title="3. 谈谈你对promise的理解？（ 高 ）"></a>3. 谈谈你对promise的理解？（ 高 ）</h3><p><code>Promise</code> 是 <code>ES6</code> 引入的 <strong>异步编程解决方案</strong>，核心是 <strong>状态管理</strong> 和 <strong>链式调用</strong>，解决了回调地狱问题。</p>
<ol>
<li><p><strong>三种状态</strong>：</p>
<ul>
<li><code>pending</code>（进行中） → <code>fulfilled</code>（成功）或 <code>rejected</code>（失败）。</li>
<li>状态一旦改变不可逆，结果通过 <code>.then</code> 或 <code>.catch</code> 传递。</li>
</ul>
</li>
<li><p><strong>链式调用</strong>：<br>通过 <code>.then</code> 串联多个异步操作，代码更扁平：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetchData</span>()  </span><br><span class="line">  .<span class="title function_">then</span>(processData)  </span><br><span class="line">  .<span class="title function_">then</span>(saveData)  </span><br><span class="line">  .<span class="title function_">catch</span>(handleError);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li><code>Promise.all([p1, p2])</code>：等全部成功，返回结果数组；任一失败立即终止。</li>
<li><code>Promise.race([p1, p2])</code>：取第一个完成的结果（无论成败）。</li>
<li><code>Promise.allSettled([p1, p2])</code>：等全部完成，返回状态和结果。</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li>用 <code>.catch</code> 统一捕获链中错误，或用 <code>try/catch</code> 配合 <code>async/await</code>。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>代码可读性</strong>：链式调用替代嵌套回调。</li>
<li><strong>错误集中处理</strong>：避免遗漏异常。</li>
<li><strong>并发控制</strong>：通过 <code>all</code>&#x2F;<code>race</code> 管理多个异步任务。</li>
</ul>
<p><strong>示例场景</strong>：</p>
<ul>
<li><code>API</code> 请求顺序依赖（如先登录后获取数据）。</li>
<li>多接口并行请求（如同时加载用户信息和配置）。</li>
</ul>
<p><strong>注意点</strong>：</p>
<ul>
<li><code>Promise</code> 创建后立即执行，无法取消。</li>
<li>需处理未捕获的拒绝（如监听 <code>unhandledrejection</code> 事件）。</li>
</ul>
<p><strong>总结</strong>：<code>Promise</code> 通过状态机机制，让异步代码更直观、易维护，是现代异步编程的基石。</p>
<h3 id="4-async-await和promise有什么关系？（-中-）"><a href="#4-async-await和promise有什么关系？（-中-）" class="headerlink" title="4. async&amp;await和promise有什么关系？（ 中 ）"></a>4. async&amp;await和promise有什么关系？（ 中 ）</h3><p><code>async/await</code> 是 <strong>基于 Promise 的语法糖</strong>，本质是将 <code>Promise</code> 的链式调用转化为更同步的写法，提升代码可读性。</p>
<p><strong>核心关系</strong>：</p>
<ol>
<li><p><strong>async 函数返回 Promise</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;  </span><br><span class="line"><span class="title function_">foo</span>() <span class="keyword">instanceof</span> <span class="title class_">Promise</span>; <span class="comment">// true  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>await 等待 Promise 结果</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">fetchData</span>(); <span class="comment">// 等待 Promise 完成  </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="title function_">fetchData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优势对比</strong>：</p>
<ul>
<li><strong>可读性</strong>：<code>async/await</code> 消除嵌套，代码更扁平。</li>
<li><strong>错误处理</strong>：用 <code>try/catch</code> 替代 <code>.then().catch()</code>，更直观。</li>
<li><strong>调试友好</strong>：断点可逐行执行，类似同步代码。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>本质仍是 Promise</strong>：需理解 <code>Promise</code> 原理（如状态、链式调用）。</li>
<li><strong>并行优化</strong>：结合 <code>Promise.all()</code> 处理多个异步任务。</li>
</ul>
<p><strong>总结</strong>：<code>async/await</code> 是 <code>Promise</code> 的升级写法，底层依赖 <code>Promise</code>，二者互补而非替代。</p>
<h3 id="5-async会阻塞吗？（-中-）"><a href="#5-async会阻塞吗？（-中-）" class="headerlink" title="5. async会阻塞吗？（ 中 ）"></a>5. async会阻塞吗？（ 中 ）</h3><p>‌<code>async</code>函数本身不会阻塞代码的执行‌。<code>async</code>函数被调用时，会立即返回一个<code>Promise</code>对象，不会阻塞外部代码的执行‌。</p>
<p>在<code>async</code>函数内部，使用<code>await</code>时，当前函数的后续代码会暂停执行，直到等待的<code>Promise</code>状态变为<code>resolve</code>或<code>rejected</code>，但这种暂停仅限于当前函数内部，不会阻塞其他外部代码或事件循环‌。</p>
<h3 id="6-async函数的工作原理？（-低-）"><a href="#6-async函数的工作原理？（-低-）" class="headerlink" title="6. async函数的工作原理？（ 低 ）"></a>6. async函数的工作原理？（ 低 ）</h3><p><code>async</code>函数在执行时，会立即返回一个<code>Promise</code>对象。如果<code>async</code>函数中有异步操作，这些操作会在内部异步执行，不会阻塞当前线程。当使用<code>await</code>时，它会等待异步操作完成后再继续执行后续代码‌。</p>
<h3 id="7-async函数如何捕获错误？（-中-）"><a href="#7-async函数如何捕获错误？（-中-）" class="headerlink" title="7. async函数如何捕获错误？（ 中 ）"></a>7. async函数如何捕获错误？（ 中 ）</h3><ul>
<li><strong>try&#x2F;catch</strong>：在 async 函数内用 <code>try/catch</code> 包裹 <code>await</code> 表达式。</li>
<li><strong>Promise.catch()</strong>：调用 async 函数后链式调用 <code>.catch()</code> 处理异常。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">asyncTask</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;try/catch捕获:&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;.catch捕获:&quot;</span>, err));</span><br></pre></td></tr></table></figure>



<h3 id="8-JS数组去重有几种办法？（-中-）"><a href="#8-JS数组去重有几种办法？（-中-）" class="headerlink" title="8. JS数组去重有几种办法？（ 中 ）"></a>8. JS数组去重有几种办法？（ 中 ）</h3><p>JS数组去重常见方法有：</p>
<ol>
<li><p><strong>Set 去重</strong>（ES6）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>filter + indexOf</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === index);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reduce 遍历</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.<span class="title function_">includes</span>(cur) ? acc : [...acc, cur], []);  </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象键值法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;  </span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> obj[item] = <span class="literal">true</span>);  </span><br><span class="line"><span class="keyword">const</span> unique = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>NaN 处理</strong>：<code>indexOf</code> 无法识别 <code>NaN</code>，需单独处理。</li>
<li><strong>对象法类型丢失</strong>：键值会转为字符串（如 <code>1</code> 和 <code>&#39;1&#39;</code> 视为相同）。</li>
</ul>
<p><strong>推荐方案</strong>：</p>
<ul>
<li>简单场景用 <strong>Set</strong>，兼容性要求用 <strong>filter + indexOf</strong>。</li>
<li>大数据量时 <strong>Set 性能更优</strong>。</li>
</ul>
<h2 id="vue部分"><a href="#vue部分" class="headerlink" title="vue部分"></a>vue部分</h2><h3 id="1-vue的生命周期有哪些？（-高）"><a href="#1-vue的生命周期有哪些？（-高）" class="headerlink" title="1. vue的生命周期有哪些？（ 高）"></a>1. vue的生命周期有哪些？（ 高）</h3><p><code>vue</code>生命周期是指<code>vue</code>实例从创建到销毁所经历的一系列过程，这些过程中会触发不同的生命周期钩子函数，允许开发者在特定的时间点插入自己的代码以执行特定的逻辑。</p>
<p><strong>vue2生命周期</strong></p>
<ul>
<li><code>beforeCreate</code>：实例被创建，数据观测(<code>data observer)和事件配置(</code>event<code>/</code>watcher setup&#96;)都未开始。</li>
<li><code>created</code>：实例创建完成，数据观测(<code>data observer</code>)和事件配置(<code>event</code>&#x2F;<code>watcher setup</code>)完成。</li>
<li><code>beforeMount</code>：实例开始挂载，编译模板，但未渲染页面。</li>
<li><code>mounted</code>：实例挂载完成，编译模板，并渲染页面完成。</li>
<li><code>beforeUpdate</code>：数据更新时调用，发生在虚拟<code>DOM</code>重新渲染和打补丁之前。</li>
<li><code>updated</code>：数据更新完成，虚拟<code>DOM</code>重新渲染和打补丁之后。</li>
<li><code>beforeDestroy</code>：实例销毁之前调用。</li>
<li><code>destroyed</code>：实例销毁完成。</li>
</ul>
<p><strong>vue3生命周期</strong></p>
<ul>
<li><code>setup</code>：在<code>beforeCreate</code>和<code>created</code>之间，在实例初始化时执行一次，用于创建数据、监听器等。</li>
<li><code>beforeCreate</code>：实例被创建，数据观测(<code>data observer</code>)和事件配置(<code>event/watcher setup</code>)都未开始。</li>
<li><code>created</code>：实例创建完成，数据观测(<code>data observer</code>)和事件配置(<code>event/watcher setup</code>)完成。</li>
<li><code>beforeMount</code>：实例开始挂载，编译模板，但未渲染页面。</li>
<li><code>mounted</code>：实例挂载完成，编译模板，并渲染页面完成。</li>
<li><code>beforeUpdate</code>：数据更新时调用，发生在虚拟<code>DOM</code>重新渲染和打补丁之前。</li>
<li><code>updated</code>：数据更新完成，虚拟<code>DOM</code>重新渲染和打补丁之后。</li>
<li><code>beforeUnmount</code>：实例销毁之前调用。</li>
<li><code>unmounted</code>：实例销毁完成。</li>
</ul>
<h3 id="2-vue2-0和vue3-0有什么区别-（-中）"><a href="#2-vue2-0和vue3-0有什么区别-（-中）" class="headerlink" title="2. vue2.0和vue3.0有什么区别?（ 中）"></a>2. vue2.0和vue3.0有什么区别?（ 中）</h3><ol>
<li><strong>响应式原理</strong><ul>
<li><strong>Vue2</strong>：基于 <code>Object.defineProperty</code> 实现，无法监听新增&#x2F;删除属性，需通过 <code>Vue.set</code>&#x2F;<code>Vue.delete</code>。</li>
<li><strong>Vue3</strong>：改用 <code>Proxy</code> 代理对象，支持动态增删属性，性能更高，无需额外 API。</li>
</ul>
</li>
<li><strong>组合式 API</strong><ul>
<li><strong>Vue2</strong>：选项式开发，逻辑分散。</li>
<li><strong>Vue3</strong>：组合式开发，逻辑复用更灵活，代码更集中。</li>
</ul>
</li>
<li><strong>性能优化</strong><ul>
<li><strong>虚拟 DOM</strong>：<code>Vue3</code> 优化<code> Diff</code> 算法，静态节点标记提升，减少对比次数。</li>
<li><strong>Tree-shaking</strong>：摇树功能，按需引入 <code>API</code>，打包体积更小。</li>
</ul>
</li>
<li><strong>TypeScript 支持</strong><ul>
<li><strong>Vue2</strong>：TS 支持较弱。</li>
<li><strong>Vue3</strong>：全面拥抱 <code>TS</code>，源码用<code>TS</code> 重写，类型推断更友好。</li>
</ul>
</li>
<li><strong>生命周期</strong><ul>
<li><strong>Vue3</strong>：移除 <code>beforeCreate</code>&#x2F;<code>created</code>（由 <code>setup</code> 替代），其他钩子名加 <code>on</code> 前缀（如 <code>onMounted</code>）。</li>
</ul>
</li>
<li><strong>其他</strong><ul>
<li><strong>Fragment</strong>：<code>Vue3</code> 支持多根节点模板。</li>
<li><strong>Teleport</strong>：新增 <code>&lt;Teleport&gt;</code> 组件实现“传送”功能。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：<br>Vue3 在 <strong>性能、开发体验、扩展性</strong> 上全面升级，推荐新项目优先使用 <code>Vue3</code>，旧项目逐步迁移。</p>
<h3 id="3-vue的优点？核心思想？（-中）"><a href="#3-vue的优点？核心思想？（-中）" class="headerlink" title="3. vue的优点？核心思想？（ 中）"></a>3. vue的优点？核心思想？（ 中）</h3><p><strong>Vue 优点：</strong></p>
<ol>
<li><strong>易用性强</strong>：<code>API</code> 简洁，文档清晰，学习曲线平缓。</li>
<li><strong>渐进式框架</strong>：可逐步集成（视图层 → 路由&#x2F;状态管理 → 构建工具），适配不同项目需求。</li>
<li><strong>响应式数据绑定</strong>：数据变化自动更新视图，开发者无需手动操作 <code>DOM</code>。</li>
<li><strong>组件化开发</strong>：高复用性，单文件组件（<code>*.vue</code>）实现模板、逻辑、样式封装。</li>
<li><strong>高性能</strong>：虚拟 <code>DOM + Diff</code> 算法优化，减少直接 <code>DOM</code> 操作开销。</li>
</ol>
<p><strong>核心思想：</strong></p>
<ol>
<li><strong>数据驱动视图</strong>：通过数据描述 UI，避免直接操作 <code>DOM</code>（声明式编程）。</li>
<li><strong>组件化</strong>：以组件为单元构建应用，提升可维护性和复用性。</li>
<li><strong>响应式系统</strong>：基于依赖追踪（<code>Vue3</code> 使用 <code>Proxy</code>），实现数据与视图的自动同步。</li>
<li><strong>渐进式设计</strong>：不强制全家桶，允许按需选择功能模块（如<code> Vuex</code>、<code>Vue Router</code>）。</li>
</ol>
<p><strong>总结</strong>：<br><code>Vue</code> 以 <strong>“简单高效”</strong> 为核心，通过数据驱动和组件化降低开发复杂度，同时保持灵活性和高性能。</p>
<h3 id="4-vue组件之间有哪些通讯？（-高）"><a href="#4-vue组件之间有哪些通讯？（-高）" class="headerlink" title="4. vue组件之间有哪些通讯？（ 高）"></a>4. vue组件之间有哪些通讯？（ 高）</h3><ol>
<li><strong>父子组件</strong><ul>
<li><strong>父 → 子</strong>：通过 <code>props</code> 传递数据。</li>
<li><strong>子 → 父</strong>：子组件通过 <code>$emit</code> 触发自定义事件，父组件监听并处理。</li>
</ul>
</li>
<li><strong>兄弟组件</strong><ul>
<li><strong>共同父组件中转</strong>：通过父组件作为桥梁，结合 <code>props</code> 和 <code>$emit</code>。</li>
<li><strong>全局事件总线</strong>（<code>Vue2</code>）：利用空的 Vue 实例 (<code>EventBus</code>) 通过 <code>$on</code>&#x2F;<code>$emit</code> 通信（<code>Vue3</code> 中不推荐）。</li>
<li><strong>状态管理</strong>：使用 <strong>Vuex（Vue2）</strong> 或 <strong>Pinia（Vue3推荐）</strong> 集中管理状态。</li>
</ul>
</li>
<li><strong>跨层级组件</strong><ul>
<li><strong>provide&#x2F;inject</strong>：祖先组件通过 <code>provide</code> 提供数据，后代组件通过 <code>inject</code> 注入（适合单向传递配置&#x2F;主题）。</li>
<li><strong>状态管理库</strong>：通过全局状态（如 <code>Vuex</code>&#x2F;<code>Pinia</code>）实现任意组件间通信。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>简单场景</strong>：优先用 <code>props</code>&#x2F;<code>$emit</code>。</li>
<li><strong>复杂场景</strong>：跨层级用 <code>provide/inject</code>，全局状态用 <strong>Pinia</strong>。</li>
<li><strong>Vue3 推荐</strong>：组合式 <code>API + Pinia</code>，替代 <code>Vue2</code> 的 <code>EventBus</code> 和 <code>Vuex</code>。</li>
</ul>
<h3 id="5-v-show和v-if的区别？（-高）"><a href="#5-v-show和v-if的区别？（-高）" class="headerlink" title="5. v-show和v-if的区别？（ 高）"></a>5. v-show和v-if的区别？（ 高）</h3><p><code>v-if</code>是通过控制<code>dom</code>节点的存在与否来控制元素的显隐；<br><code>v-show</code>是通过设置<code>DOM</code>元素的<code>display</code>样式，<code>block</code>为显示，<code>none</code>为隐藏。<br><code>v-if</code>判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销。<br><code>v-show</code>调整<code>DOM</code>元素的<code>CSS</code>的<code>dispaly</code>属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h3 id="6-key的作用？（-高）"><a href="#6-key的作用？（-高）" class="headerlink" title="6. key的作用？（ 高）"></a>6. key的作用？（ 高）</h3><ol>
<li><strong>唯一标识元素</strong>：<br>在虚拟 <code>DOM</code> 的 <code>Diff</code> 算法中，<code>key</code> 用于 <strong>精准追踪节点身份</strong>。当数据变化时，<code>Vue</code> 通过 <code>key</code> 判断元素是“就地复用”还是“重新渲染”，确保更新高效且准确。</li>
<li><strong>避免状态错乱</strong>：<br>在列表渲染（如 <code>v-for</code>）时，若元素包含临时状态（如输入框内容），无 <code>key</code> 会导致元素复用后状态残留。<strong><code>key</code> 强制元素独立绑定数据，防止状态错位</strong>。</li>
<li><strong>优化性能</strong>：<br>合理使用 <code>key</code> 可减少不必要的 <code>DOM</code> 操作（如删除&#x2F;重建节点），通过复用已有元素提升渲染效率。</li>
</ol>
<p><strong>使用场景与注意事项：</strong></p>
<ul>
<li><strong>必须用 <code>key</code></strong>：动态列表（<code>v-for</code>）且元素可能顺序变化时（如排序、增删）。</li>
<li><strong>避免用 <code>index</code> 作为 <code>key</code></strong>：若列表会变，<code>index</code> 无法稳定标识元素，可能导致渲染错误或性能问题。</li>
<li><strong>推荐使用唯一值</strong>：如数据中的 <code>id</code>、哈希值等唯一标识字段。</li>
</ul>
<p><strong>总结</strong>：<br><code>key</code> 是 <code>Vue</code> 高效更新虚拟 <code>DOM</code> 的核心机制，确保元素 <strong>正确复用</strong> 或 <strong>精准更新</strong>，避免因数据变动导致的渲染异常或性能损耗。</p>
<h3 id="7-推荐用索引值作为key吗？（-高）"><a href="#7-推荐用索引值作为key吗？（-高）" class="headerlink" title="7. 推荐用索引值作为key吗？（ 高）"></a>7. 推荐用索引值作为key吗？（ 高）</h3><p><strong>不推荐使用索引（index）作为 <code>key</code></strong>，除非同时满足以下两个条件：</p>
<ol>
<li><strong>列表是静态的</strong>（不会增删、排序等顺序变化）。</li>
<li><strong>列表项没有内部状态</strong>（如表单输入、勾选框等需维持状态的元素）。</li>
</ol>
<p><strong>为什么不推荐？</strong></p>
<p><strong>1. 状态错乱</strong>：<br>当列表动态变化时（如删除中间项），索引会重新排列，导致 <code>Vue</code> 复用错误的 <code>DOM</code> 节点，引发组件状态残留（如输入框内容错位）。</p>
<p><strong>2. 性能下降</strong>：<br>索引无法稳定标识元素，<code>Vue</code> 会频繁触发不必要的 <code>DOM</code> 更新（如节点重新创建而非复用），降低渲染效率。</p>
<p><strong>什么情况下可用索引？</strong></p>
<ul>
<li><strong>纯展示列表</strong>：列表仅渲染文本&#x2F;图片，无交互状态。</li>
<li><strong>列表绝对静态</strong>：数据永不变化（极少见）。</li>
</ul>
<p><strong>最佳实践</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使用唯一标识符作为 key（如 id、哈希值等）：--&gt;</span><br><span class="line">&lt;div v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：<br>索引作为 <code>key</code> 可能导致 <strong>状态错乱</strong> 和 <strong>性能浪费</strong>，除非静态且无状态，否则应优先使用唯一值。</p>
<h3 id="8-v-if和v-for的优先级？推荐写同行吗？（-高）"><a href="#8-v-if和v-for的优先级？推荐写同行吗？（-高）" class="headerlink" title="8. v-if和v-for的优先级？推荐写同行吗？（ 高）"></a>8. v-if和v-for的优先级？推荐写同行吗？（ 高）</h3><p><strong>1. 优先级规则</strong></p>
<ul>
<li><strong>Vue 2</strong>：<code>v-for</code> 的优先级高于 <code>v-if</code>。<ul>
<li>同一元素上同时使用时，会先执行循环（<code>v-for</code>），再对每个迭代项进行条件判断（<code>v-if</code>）。</li>
<li><strong>问题</strong>：即使某些项最终不渲染，仍会被遍历，导致性能浪费。</li>
</ul>
</li>
<li><strong>Vue 3</strong>：<code>v-if</code> 的优先级高于 <code>v-for</code>。<ul>
<li>同一元素上同时使用时，会先判断条件（<code>v-if</code>），但此时可能无法访问 <code>v-for</code> 的迭代变量，导致逻辑错误。</li>
<li><strong>问题</strong>：<code>v-if</code> 的条件中若依赖循环变量（如 <code>item.id</code>），会因作用域问题抛出未定义错误。</li>
</ul>
</li>
</ul>
<p><strong>2. 为什么不推荐同行写？</strong></p>
<p><strong>性能问题</strong></p>
<ul>
<li><strong>Vue 2</strong>：即使大部分项不满足 <code>v-if</code> 条件，仍需完整遍历整个列表，造成不必要的计算开销。</li>
<li><strong>Vue 3</strong>：条件判断优先，但若 <code>v-if</code> 依赖循环变量，会导致逻辑错误</li>
</ul>
<p><strong>代码可读性差</strong></p>
<ul>
<li>混合使用会让模板逻辑变得复杂，难以快速理解意图。</li>
</ul>
<p><strong>作用域冲突</strong></p>
<ul>
<li>在 Vue 3 中，<code>v-if</code> 优先于 <code>v-for</code>，导致 <code>v-if</code> 的条件中无法访问迭代变量（如 <code>item</code>），引发运行时错误。</li>
</ul>
<p><strong>3. 正确做法</strong></p>
<p><strong>使用计算属性过滤数据</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预先过滤数据，避免模板中混合逻辑</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">filteredList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">isActive</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 模板中仅用 v-for --&gt;</span><br><span class="line">&lt;div v-for=&quot;item in filteredList&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>用 <code>&lt;template&gt;</code> 包裹分离逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-for=&quot;item in list&quot;&gt;</span><br><span class="line">  &lt;div v-if=&quot;item.isActive&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>Vue 2</strong>：<code>v-for</code> 优先，但同行写会导致性能浪费。</li>
<li><strong>Vue 3</strong>：<code>v-if</code> 优先，但会导致作用域错误。</li>
<li><strong>统一建议</strong>：避免混用，用计算属性或 <code>&lt;template&gt;</code> 分离逻辑，提升性能与可维护性。</li>
</ul>
<h3 id="9-双向绑定的原理？（-高）"><a href="#9-双向绑定的原理？（-高）" class="headerlink" title="9.  双向绑定的原理？（ 高）"></a>9.  双向绑定的原理？（ 高）</h3><p><code>vue</code>数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现。<br>数据劫持<code>vue2</code>通过<code>Object.defineProperty()</code>来实现，<code>vue3</code>是通过<code>proxy</code>代理器实现的。<br>发布者-订阅模式双向数据绑定。</p>
<p>步骤如下：</p>
<p>实现一个监听器<code>Observer</code>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。<br>实现一个订阅者<code>Watcher</code>，可以收到属性的变化通知并执行相应的函数，从而更新视图。<br>实现一个解析器<code>Compile</code>，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p>
<h3 id="10-vue常见的指令有哪些？（-高）"><a href="#10-vue常见的指令有哪些？（-高）" class="headerlink" title="10. vue常见的指令有哪些？（ 高）"></a>10. vue常见的指令有哪些？（ 高）</h3><ol>
<li><code>v-if</code>：条件渲染指令，根据表达式的值决定是否渲染元素。</li>
<li><code>v-show</code>：条件渲染指令，根据表达式的值决定是否展示元素，与<code>v-if</code>不同的是，<code>v-show</code>不管初始条件是什么，都会渲染元素，只是简单地切换元素的<code>display</code>属性。</li>
<li><code>v-for</code>：循环渲染指令，可以遍历数组或对象，并根据数据渲染元素。</li>
<li><code>v-text</code>：更新元素的纯文本内容。</li>
<li><code>v-html</code>：更新元素的<code>html</code>内容。</li>
<li><code>v-on</code>：绑定事件监听器。</li>
<li><code>v-bind</code>：单向绑定元素属性。</li>
<li><code>v-model</code>：实现表单输入和应用状态之间的双向绑定。</li>
<li><code>v-once</code>：只渲染元素和组件一次。</li>
</ol>
<h3 id="11-diff算法的原理？（-低）"><a href="#11-diff算法的原理？（-低）" class="headerlink" title="11. diff算法的原理？（ 低）"></a>11. diff算法的原理？（ 低）</h3><ol>
<li><strong>同级比，不跨层</strong>——新旧<code>DOM</code>树逐层比对。</li>
<li><strong>类型不同，直接换</strong>——节点类型变，整颗子树替换。</li>
<li><strong>类型相同改属性</strong>——复用<code>DOM</code>元素，只更新变化的属性。</li>
<li>子节点对比用双端 + <code>Key</code><ul>
<li><strong>双端比较</strong>：头尾指针交叉比对，优先复用相同节点；</li>
<li><strong>Key标识</strong>：通过唯一<code>Key</code>精准定位节点，减少移动（如列表倒序时直接挪位置而非重建）。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结</strong>：<br><code>Diff</code>算法通过<strong>层级比对、类型判断、Key复用</strong>，最小化<code>DOM</code>操作，实现高效更新。</p>
<h3 id="12-什么MVVM思想？（-低）"><a href="#12-什么MVVM思想？（-低）" class="headerlink" title="12. 什么MVVM思想？（ 低）"></a>12. 什么MVVM思想？（ 低）</h3><p><code>MVVM</code>核心：</p>
<p>数据驱动——<code>Model</code>模型数据改变，<code>View</code>视图自动更新（无需操作<code>DOM</code>）。<br>双向绑定——<code>View</code>视图层的表单输入等直接修改模型数据<code>Model</code>（如<code>v-model</code>）。<br><code>ViewModel</code>桥接——封装逻辑，监听数据与事件，解耦视图<code>View</code>和模型<code>Model</code>。</p>
<p><strong>一句话：</strong> 数据变 → 视图自动变，<code>UI</code>事件 → 自动更新数据，开发者专注业务。</p>
<h3 id="13-为什么data是一个函数-（-中）"><a href="#13-为什么data是一个函数-（-中）" class="headerlink" title="13. 为什么data是一个函数?（ 中）"></a>13. 为什么data是一个函数?（ 中）</h3><p>组件复用需<strong>独立数据副本</strong>。若<code>data</code>为对象，所有实例共享同一数据（污染）；函数每次返回<strong>新对象</strong>，确保数据隔离。</p>
<p><strong>一句话</strong>：避免多个组件实例间数据互相干扰。</p>
<h3 id="14-如何开发vue组件？（-中）"><a href="#14-如何开发vue组件？（-中）" class="headerlink" title="14. 如何开发vue组件？（ 中）"></a>14. 如何开发vue组件？（ 中）</h3><ol>
<li><strong>明确职责</strong>——单一功能，输入（<code>props</code>）&#x2F;输出（事件）清晰。</li>
<li><strong>设计API</strong>——定义<code>props</code>、事件、插槽，预留扩展性（如支持<code>v-model</code>）。</li>
<li><strong>内部实现</strong>——用插槽定制内容，样式局部化（<code>scoped CSS</code>），逻辑高内聚。</li>
<li><strong>可维护性</strong>——单一职责，复杂组件拆分子组件，类型提示（<code>TypeScript</code>）。</li>
<li><strong>测试验证</strong>——测试验证组件各项功能。</li>
</ol>
<p><strong>一句话</strong>：定义接口 → 实现细节 → 确保复用性和健壮性。</p>
<h3 id="15-vue插槽有哪些？（-中）"><a href="#15-vue插槽有哪些？（-中）" class="headerlink" title="15. vue插槽有哪些？（ 中）"></a>15. vue插槽有哪些？（ 中）</h3><p><strong>vue插槽3种</strong>：</p>
<ol>
<li><strong>默认插槽</strong>——匿名内容分发（<code>&lt;slot&gt;</code>默认位置）。</li>
<li><strong>具名插槽</strong>——多内容分区（<code>&lt;slot name=&quot;header&quot;&gt;</code> + <code>v-slot:header</code>）。</li>
<li><strong>作用域插槽</strong>——子传数据给父（<code>&lt;slot :data=&quot;data&quot;&gt;</code> + <code>v-slot=&quot;props&quot;</code>）。</li>
</ol>
<h3 id="16-计算属性和方法的区别？（-高）"><a href="#16-计算属性和方法的区别？（-高）" class="headerlink" title="16. 计算属性和方法的区别？（ 高）"></a>16. 计算属性和方法的区别？（ 高）</h3><p><strong>计算属性 vs 方法</strong>：</p>
<ol>
<li><strong>缓存机制</strong><ul>
<li>计算属性：依赖不变时<strong>缓存结果</strong>，仅重新计算。</li>
<li>方法：<strong>无缓存</strong>，每次调用必执行。</li>
</ul>
</li>
<li><strong>调用方式</strong><ul>
<li>计算属性：模板中<strong>直接引用</strong>（如<code>&#123;&#123; total &#125;&#125;</code>）。</li>
<li>方法：模板中<strong>需加括号调用</strong>（如<code>&#123;&#123; getTotal() &#125;&#125;</code>）。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>计算属性：依赖多数据<strong>同步计算</strong>（如复杂过滤）。</li>
<li>方法：需<strong>参数</strong>或<strong>主动触发</strong>（如事件处理）。</li>
</ul>
</li>
</ol>
<p><strong>一句话</strong>：<br>计算属性优化重复计算，方法处理动态逻辑。</p>
<h3 id="17-计算属性和侦听器的区别？（-高）"><a href="#17-计算属性和侦听器的区别？（-高）" class="headerlink" title="17. 计算属性和侦听器的区别？（ 高）"></a>17. 计算属性和侦听器的区别？（ 高）</h3><p><strong>计算属性 vs 侦听器</strong>：</p>
<ol>
<li><strong>用途不同</strong><ul>
<li>计算属性：<strong>声明依赖关系</strong>，返回计算结果（适合模板直接使用）。</li>
<li>侦听器：监听数据变化，<strong>执行副作用</strong>（如异步请求、复杂逻辑）。</li>
</ul>
</li>
<li><strong>缓存机制</strong><ul>
<li>计算属性：依赖未变时<strong>结果复用</strong>（高效）。</li>
<li>侦听器：每次数据变化<strong>强制触发</strong>（无缓存）。</li>
</ul>
</li>
<li><strong>语法差异</strong><ul>
<li>计算属性：<code>computed: &#123; fullName() &#123; ... &#125; &#125;</code>。</li>
<li>侦听器：<code>watch: &#123; value(newVal) &#123; ... &#125; &#125;</code>。</li>
</ul>
</li>
</ol>
<p><strong>一句话</strong>：<br>计算属性用于<strong>依赖计算</strong>，侦听器用于<strong>响应变化</strong>。</p>
<h3 id="18-如何设置深度监听和立即执行？（-高）"><a href="#18-如何设置深度监听和立即执行？（-高）" class="headerlink" title="18. 如何设置深度监听和立即执行？（ 高）"></a>18. 如何设置深度监听和立即执行？（ 高）</h3><p><strong>设置深度监听与立即执行</strong>：</p>
<p><strong>深度监听</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123; <span class="comment">/* 逻辑 */</span> &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 监听对象内部变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>立即执行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">value</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123; <span class="comment">/* 逻辑 */</span> &#125;,</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// 初始化时立即触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一句话</strong>：配置 <code>deep: true</code> 监听嵌套数据，<code>immediate: true</code> 初始化即触发。</p>
<h3 id="19-setTimeout和nextTick的区别？（-中）"><a href="#19-setTimeout和nextTick的区别？（-中）" class="headerlink" title="19. setTimeout和nextTick的区别？（ 中）"></a>19. setTimeout和nextTick的区别？（ 中）</h3><ol>
<li><strong>执行时机</strong><ul>
<li><code>nextTick</code>：Vue <strong>DOM更新后</strong>立即触发（微任务）。</li>
<li><code>setTimeout</code>：<strong>下一事件循环</strong>执行（宏任务）。</li>
</ul>
</li>
<li><strong>用途</strong><ul>
<li><code>nextTick</code>：确保操作在<strong>DOM更新后执行</strong>（如获取更新后的DOM属性）。</li>
<li><code>setTimeout</code>：通用延迟逻辑，<strong>不依赖Vue更新时机</strong>。</li>
</ul>
</li>
<li><strong>优先级</strong><ul>
<li><code>nextTick</code> 回调先于 <code>setTimeout</code> 执行（微任务 &gt; 宏任务）。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;新数据&#x27;</span>;</span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM已更新&#x27;</span>, <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>); <span class="comment">// 正确获取最新DOM</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可能晚于DOM更新&#x27;</span>); <span class="comment">// 不一定与DOM更新同步</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>一句话</strong>：<br>用 <code>nextTick</code> 确保 <strong>DOM同步后操作</strong>，<code>setTimeout</code> 用于通用异步延迟。</p>
<h3 id="20-ref的作用？（-中）"><a href="#20-ref的作用？（-中）" class="headerlink" title="20. ref的作用？（ 中）"></a>20. ref的作用？（ 中）</h3><p><strong>ref 的作用</strong>：</p>
<ol>
<li><p><strong>获取 DOM 元素&#x2F;组件实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input ref=&quot;myInput&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$refs.myInput.focus() // 操作 DOM</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>创建响应式数据（Vue3）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) <span class="comment">// 基本类型响应式数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>区别</strong>：</p>
<ul>
<li>Vue2：主要用于 <strong>DOM&#x2F;组件引用</strong></li>
<li>Vue3：扩展为 <strong>响应式数据管理</strong>（配合组合式开发）</li>
</ul>
<p><strong>一句话</strong>：<br><code>ref</code> 用于操作 <code>DOM</code>&#x2F;组件 或 创建响应式变量。</p>
<h3 id="21-style上scope属性有什么用？（-高）"><a href="#21-style上scope属性有什么用？（-高）" class="headerlink" title="21. style上scope属性有什么用？（ 高）"></a>21. style上scope属性有什么用？（ 高）</h3><p>确保样式<strong>只作用于当前组件</strong>（通过自动添加唯一属性选择器），避免全局污染。</p>
<p><strong>原理：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编译前 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.button &#123; color: red; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译后 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.button[data-v-f3f3eg9] &#123; color: red; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;button&quot; data-v-f3f3eg9&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>例外</strong>：</p>
<ul>
<li>用 <code>::v-deep</code> 可穿透子组件样式</li>
<li>全局样式需写在无 <code>scoped</code> 的 <code>&lt;style&gt;</code> 中</li>
</ul>
<p><strong>一句话</strong>：<br><code>scoped</code> 实现<strong>组件级样式隔离</strong>，避免 CSS 冲突。</p>
<h3 id="22-路由有几种传参方式？（-高）"><a href="#22-路由有几种传参方式？（-高）" class="headerlink" title="22. 路由有几种传参方式？（ 高）"></a>22. 路由有几种传参方式？（ 高）</h3><p><strong>Vue 路由传参 3 种方式</strong>：</p>
<ol>
<li><p><strong>动态路由（params）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由配置  </span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参  </span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/user/123&#x27;</span>)  </span><br><span class="line"><span class="comment">// 取参  </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span> <span class="comment">// 123  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询参数（query）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参  </span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Kira&#x27;</span> &#125;&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 取参  </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">name</span> <span class="comment">// &#x27;Kira&#x27;  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>props 解耦</strong>（推荐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由配置  </span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件直接接收  </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>] <span class="comment">// 直接使用 this.id  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>区别</strong>：</p>
<ul>
<li><code>params</code>：路径更简洁，<strong>需提前声明参数</strong></li>
<li><code>query</code>：参数可见在 <code>URL</code> 中，<strong>无需声明</strong></li>
<li><code>props</code>：组件解耦，<strong>不依赖 $route 对象</strong></li>
</ul>
<p><strong>一句话</strong>：<br>优先用 <code>props</code>，次选 <code>params/query</code> 按需使用。</p>
<h3 id="23-query和params的区别？（-高）"><a href="#23-query和params的区别？（-高）" class="headerlink" title="23. query和params的区别？（ 高）"></a>23. query和params的区别？（ 高）</h3><ol>
<li><strong>URL 形式</strong><ul>
<li><code>query</code>：参数在 <code>?</code> 后，形如 <code>/user?name=Kira</code></li>
<li><code>params</code>：参数直接嵌入路径，形如 <code>/user/123</code></li>
</ul>
</li>
<li><strong>声明要求</strong><ul>
<li><code>query</code>：无需提前在路由配置中声明</li>
<li><code>params</code>：<strong>必须</strong>在路由路径中声明（如 <code>path: &#39;/user/:id&#39;</code>）</li>
</ul>
</li>
<li><strong>刷新&#x2F;分享</strong><ul>
<li><code>query</code>：参数保留在 URL 中，刷新页面不丢失</li>
<li><code>params</code>：若路由未声明对应参数，刷新后参数会丢失</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li><code>query</code>：可选参数（如搜索关键词、筛选条件）</li>
<li><code>params</code>：必要参数（如资源 ID、固定路径结构）</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：<br><code>query</code> 灵活可见，<code>params</code> 结构严谨需预定义。</p>
<h3 id="24-hash和history模式的区别？（-低）"><a href="#24-hash和history模式的区别？（-低）" class="headerlink" title="24. hash和history模式的区别？（ 低）"></a>24. hash和history模式的区别？（ 低）</h3><ol>
<li><strong>URL 形式</strong><ul>
<li><strong>Hash</strong>：带 <code>#</code> 符号（如 <code>/home#user</code>），<code>#</code> 后的内容不发送到服务器</li>
<li><strong>History</strong>：无 <code>#</code>，形似普通路径（如 <code>/user</code>）</li>
</ul>
</li>
<li><strong>服务器配置</strong><ul>
<li><strong>Hash</strong>：无需后端支持，直接部署静态服务器</li>
<li><strong>History</strong>：需后端配置（如 <code>Nginx/Apache</code> 重定向到 <code>index.html</code>），避免刷新 404</li>
</ul>
</li>
<li><strong>兼容性</strong><ul>
<li><strong>Hash</strong>：兼容所有浏览器</li>
<li><strong>History</strong>：依赖 <code>HTML5 History API（IE10+）</code></li>
</ul>
</li>
<li><strong>SEO 友好性</strong><ul>
<li><strong>History</strong>：<code>URL</code> 更规范，对搜索引擎更友好</li>
</ul>
</li>
</ol>
<p><strong>一句话总结</strong>：<br>Hash 简单兼容性好，<code>History</code> 优雅但需后端配合。</p>
<h3 id="25-路由守卫有那些？你用过吗？做过什么？（高）"><a href="#25-路由守卫有那些？你用过吗？做过什么？（高）" class="headerlink" title="25. 路由守卫有那些？你用过吗？做过什么？（高）"></a>25. 路由守卫有那些？你用过吗？做过什么？（高）</h3><p><strong>路由守卫类型</strong>：</p>
<ol>
<li><strong>全局守卫</strong>：<code>beforeEach</code>（前置）、<code>beforeResolve</code>（解析前）、<code>afterEach</code>（后置）</li>
<li><strong>路由独享</strong>：<code>beforeEnter</code></li>
<li><strong>组件内守卫</strong>：<code>beforeRouteEnter</code>（进入前）、<code>beforeRouteUpdate</code>（更新时）、<code>beforeRouteLeave</code>（离开前）</li>
</ol>
<p><strong>是否用过</strong>：用过，常见场景：</p>
<ul>
<li><strong>权限控制</strong>：用 <code>beforeEach</code> 拦截未登录或无权访问的页面</li>
<li><strong>表单保护</strong>：用 <code>beforeRouteLeave</code> 阻止用户未保存数据时离开</li>
<li><strong>数据预加载</strong>：在 <code>beforeRouteEnter</code> 或 <code>beforeResolve</code> 中提前请求页面数据</li>
</ul>
<p><strong>一句话</strong>：路由守卫控制导航流程，实现权限、数据加载等逻辑</p>
<h3 id="26-如何解决首屏打开是白屏？（高）"><a href="#26-如何解决首屏打开是白屏？（高）" class="headerlink" title="26. 如何解决首屏打开是白屏？（高）"></a>26. 如何解决首屏打开是白屏？（高）</h3><p><strong>Vue 首屏白屏优化方案</strong>：</p>
<ol>
<li><p><strong>代码分割 + 路由懒加载</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/Home.vue&#x27;</span>)  </span><br></pre></td></tr></table></figure>

<p>减小首屏文件体积，按需加载路由组件</p>
</li>
<li><p><strong>开启 Gzip 压缩</strong><br>配置服务器（如 <code>Nginx</code>）压缩 <code>JS</code>&#x2F;<code>CSS</code> 资源，减少传输体积</p>
</li>
<li><p><strong>CDN 加速第三方库</strong><br>将 Vue&#x2F;Vuex 等库通过 <code>CDN</code> 引入，减少 <code>vendor.js</code> 大小</p>
</li>
<li><p><strong>服务端渲染 (SSR)</strong><br>使用 <code>Nuxt.js</code> 或手动 <code>SSR</code>，直接返回渲染后的 <code>HTML</code></p>
</li>
<li><p><strong>图片懒加载 + WebP 格式</strong><br>首屏外图片延迟加载，使用 <code>image-webpack-loader</code> 压缩图片</p>
</li>
<li><p><strong>优化 Webpack 打包</strong><br>使用 <code>SplitChunks</code> 拆分代码，<code>TerserPlugin</code> 压缩 JS</p>
</li>
</ol>
<p><strong>效果</strong>：</p>
<ul>
<li>首屏加载时间减少 <code>30%</code>~&#96;70%&#96;</li>
<li>白屏时间降至 <code>1s</code> 内（视网络情况）</li>
</ul>
<h3 id="27-路由导航有几种方式？（高）"><a href="#27-路由导航有几种方式？（高）" class="headerlink" title="27. 路由导航有几种方式？（高）"></a>27. 路由导航有几种方式？（高）</h3><ol>
<li><strong>声明式导航</strong><br>使用 <code>&lt;router-link to=&quot;path&quot;&gt;</code> 标签，通过 <code>to</code> 属性跳转（底层自动调用 <code>router.push</code>）。</li>
<li><strong>编程式导航</strong><br>调用路由实例方法：<ul>
<li><code>router.push(path)</code>：跳转并记录历史</li>
<li><code>router.replace(path)</code>：跳转不保留历史</li>
<li><code>router.go(n)</code>：前进&#x2F;后退步数</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程式跳转  </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/home&#x27;</span>)  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;User&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;)  </span><br></pre></td></tr></table></figure>

<p><strong>一句话</strong>：两种方式——声明式（标签）和编程式（JS调用方法）。</p>
<h3 id="28-push-和replace跳转的区别？（低）"><a href="#28-push-和replace跳转的区别？（低）" class="headerlink" title="28. push 和replace跳转的区别？（低）"></a>28. push 和replace跳转的区别？（低）</h3><ol>
<li><strong>历史记录</strong><ul>
<li><code>push</code>：添加新记录，用户可通过<strong>后退</strong>返回原页面。</li>
<li><code>replace</code>：<strong>替换</strong>当前记录，无法后退到原页面。</li>
</ul>
</li>
<li><strong>使用场景</strong><ul>
<li><code>push</code>：常规页面跳转（如导航菜单）。</li>
<li><code>replace</code>：登录后跳转首页（避免回退到登录页）。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转后可通过后退返回  </span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/home&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转后无法后退返回  </span></span><br><span class="line">router.<span class="title function_">replace</span>(<span class="string">&#x27;/dashboard&#x27;</span>)  </span><br></pre></td></tr></table></figure>



<h3 id="29-vuex是什么？作用和缺点？（高）"><a href="#29-vuex是什么？作用和缺点？（高）" class="headerlink" title="29. vuex是什么？作用和缺点？（高）"></a>29. vuex是什么？作用和缺点？（高）</h3><p>vuex是<code>vue</code> 的<strong>集中式状态管理库</strong>，用于统一管理多组件共享的状态。</p>
<p><strong>核心作用</strong>：</p>
<ol>
<li><strong>状态集中管理</strong>：避免组件间复杂传值（如深层嵌套组件）。</li>
<li><strong>数据流可追踪</strong>：通过 <code>state → mutation → action</code> 机制，确保状态变更可预测。</li>
<li><strong>调试工具支持</strong>：与 Vue Devtools 集成，支持时间旅行调试。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>代码冗余</strong>：小型项目中使用可能“杀鸡用牛刀”（推荐 <code>Pinia</code> 替代）。</li>
<li><strong>学习成本</strong>：需理解 <code>state/mutations/actions/modules</code> 等概念。</li>
<li><strong>灵活性低</strong>：强制使用固定模式，对简单场景不够轻量。</li>
</ol>
<p><strong>示例场景</strong>：</p>
<ul>
<li>全局用户登录状态</li>
<li>跨组件共享的购物车数据</li>
</ul>
<h3 id="30-vuex几大核心？分别介绍一下？（高）"><a href="#30-vuex几大核心？分别介绍一下？（高）" class="headerlink" title="30. vuex几大核心？分别介绍一下？（高）"></a>30. vuex几大核心？分别介绍一下？（高）</h3><p><strong>Vuex 五大核心</strong>：</p>
<ol>
<li><p><strong>State</strong></p>
<p>唯一数据源，存储全局共享的<strong>响应式数据</strong>。</p>
</li>
<li><p><strong>Getters</strong></p>
<p>类似计算属性，用于从 <code>state</code> 派生出新数据（如过滤、统计）。</p>
</li>
<li><p><strong>Mutations</strong></p>
<p><strong>同步</strong>修改 <code>state</code> 的唯一方式，通过 <code>commit</code> 触发。</p>
</li>
<li><p><strong>Actions</strong></p>
<p>处理<strong>异步操作</strong>（如 API 请求），通过 <code>dispatch</code> 触发，最终调用 <code>mutations</code>。</p>
</li>
<li><p><strong>Modules</strong></p>
<p>将大型 <code>Store</code> 拆分为独立模块，每个模块可包含自己的</p>
</li>
</ol>
<p><strong>一句话总结</strong>：<br>数据（<code>State</code>）通过同步修改（<code>Mutations</code>）、异步操作（<code>Actions</code>）更新，派生数据用 <code>Getters</code>，模块化（<code>Modules</code>）解决复杂度。</p>
<h3 id="31-pinia是什么？有什么作用和优点？（高）"><a href="#31-pinia是什么？有什么作用和优点？（高）" class="headerlink" title="31. pinia是什么？有什么作用和优点？（高）"></a>31. pinia是什么？有什么作用和优点？（高）</h3><p><strong>Pinia 是什么</strong>：<br><code>Vue</code> 官方推荐的<strong>新一代状态管理库</strong>（替代 <code>Vuex</code>），支持 <code>Vue 2</code>&#x2F;<code>3</code>。</p>
<p><strong>核心作用</strong>：</p>
<ul>
<li>集中管理多组件共享的<strong>全局状态</strong>（如用户信息、主题配置）。</li>
<li>支持服务端渲染（<code>SSR</code>）和 <code>TypeScript</code>。</li>
</ul>
<p><strong>核心优点</strong>：</p>
<ol>
<li><p><strong>简洁 API</strong></p>
<p>移除 <code>mutations</code>，直接通过 <code>actions</code> 同步&#x2F;异步修改状态。</p>
</li>
<li><p><strong>TypeScript 友好</strong></p>
<p>自动推导类型，无需额外类型声明。</p>
</li>
<li><p><strong>模块化设计</strong></p>
<p>天然支持 <code>Store</code> 拆分，无需 <code>modules</code> 嵌套。</p>
</li>
<li><p><strong>轻量高效</strong></p>
<p>体积更小（约 <code>1KB</code>），性能更优。</p>
</li>
<li><p><strong>开发体验佳</strong></p>
<p>支持 组合式 和 选项式 两种写法。</p>
</li>
</ol>
<h3 id="32-vuex或pinia如何实现持久化存储？（中）"><a href="#32-vuex或pinia如何实现持久化存储？（中）" class="headerlink" title="32. vuex或pinia如何实现持久化存储？（中）"></a>32. vuex或pinia如何实现持久化存储？（中）</h3><p><strong>Vuex 持久化</strong>：</p>
<p><strong>插件 <code>vuex-persistedstate</code></strong></p>
<ul>
<li><p>安装：<code>npm install vuex-persistedstate</code></p>
</li>
<li><p>配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&#x27;vuex-persistedstate&#x27;</span>;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;  </span><br><span class="line">  <span class="attr">plugins</span>: [  </span><br><span class="line">    <span class="title function_">createPersistedState</span>(&#123;  </span><br><span class="line">      <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">localStorage</span>, <span class="comment">// 默认 localStorage  </span></span><br><span class="line">      <span class="attr">paths</span>: [<span class="string">&#x27;user.token&#x27;</span>, <span class="string">&#x27;cart&#x27;</span>]  <span class="comment">// 指定需要持久化的 state 路径  </span></span><br><span class="line">    &#125;)  </span><br><span class="line">  ]  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Pinia 持久化</strong>：</p>
<p><strong>插件 <code>pinia-plugin-persistedstate</code></strong></p>
<ul>
<li><p>安装：<code>npm install pinia-plugin-persistedstate</code></p>
</li>
<li><p>配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> piniaPluginPersistedstate <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span>;  </span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>();  </span><br><span class="line">pinia.<span class="title function_">use</span>(piniaPluginPersistedstate);  </span><br></pre></td></tr></table></figure>
</li>
<li><p>Store 中启用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;  </span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">token</span>: <span class="string">&#x27;&#x27;</span> &#125;),  </span><br><span class="line">  <span class="attr">persist</span>: <span class="literal">true</span> <span class="comment">// 默认 localStorage  </span></span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>敏感数据</strong>：避免明文存储密码等敏感信息，建议加密（如 <code>crypto-js</code>）。</li>
<li><strong>存储限制</strong>：<code>localStorage</code> 有容量限制（约 5MB），大体积数据建议用 <code>IndexedDB</code>。</li>
</ul>
<h2 id="project部分"><a href="#project部分" class="headerlink" title="project部分"></a>project部分</h2><h3 id="1-你做过什么项目？（高）"><a href="#1-你做过什么项目？（高）" class="headerlink" title="1. 你做过什么项目？（高）"></a>1. 你做过什么项目？（高）</h3><p>我最近完成了一个《服装电商类项目》，在这个项目中，我主要负责前端开发。前端<code>UI</code>界面是用鸿蒙应用<code>App</code>开发的，而后端管理界面则是使用<code>Vue3</code>和<code>Element-Plus</code>构建的。虽然后端<code>API</code>是由其他同事开发的，技术栈是<code>SSM</code>，但我在项目中与前端的对接和调试方面积累了丰富的经验。这个项目让我深入理解了前端与后端的协作流程，也提升了我在鸿蒙应用开发和<code>Vue3</code>框架下的实际开发能力。</p>
<h3 id="2-项目什么时候做的？有多少人负责？（高）"><a href="#2-项目什么时候做的？有多少人负责？（高）" class="headerlink" title="2. 项目什么时候做的？有多少人负责？（高）"></a>2. 项目什么时候做的？有多少人负责？（高）</h3><p>这个项目是我在实习期间完成的，具体时间是<code>2024年3月到2024年8月</code>（根据你的实际情况调整）。整个团队大约有<code>5</code>人，其中前端开发有<code>2</code>人（包括我），后端开发有2人，还有1位负责测试和1位产品设计的同事。我在团队中主要负责前端开发，包括鸿蒙应用<code>App</code>的<code>UI</code>实现和部分后端管理界面的开发。</p>
<h3 id="3-项目用了什么技术栈？（高）"><a href="#3-项目用了什么技术栈？（高）" class="headerlink" title="3. 项目用了什么技术栈？（高）"></a>3. 项目用了什么技术栈？（高）</h3><p>这个项目的前端部分主要分为两块：</p>
<p><strong>用户端：</strong> </p>
<p>是用鸿蒙应用<code>App</code>开发的，主要使用了鸿蒙的<code>ArkUI</code>框架和<code>JavaScript</code>&#x2F;<code>TypeScript</code>语言来实现<code>UI</code>界面和交互逻辑。</p>
<p><strong>管理端：</strong> </p>
<p>是用<code>Vue3</code>和<code>Element-Plus</code>开发的，主要用来处理后台管理系统的界面和功能，比如商品管理、订单管理等。后端技术栈是<code>SSM</code>（<code>Spring</code>、<code>Spring MVC</code>、<code>MyBatis</code>），数据库用的是<code>MySQL</code>，虽然后端开发不是我负责的，但我在项目中和后端同事有密切的对接，比如接口联调和数据格式的协商。</p>
<h3 id="4-项目有什么功能？你负责了哪些功能？（高）"><a href="#4-项目有什么功能？你负责了哪些功能？（高）" class="headerlink" title="4. 项目有什么功能？你负责了哪些功能？（高）"></a>4. 项目有什么功能？你负责了哪些功能？（高）</h3><p>这是一个服装电商类项目，主要分为用户端和管理端两部分：</p>
<p><strong>用户端：</strong> 用户可以通过鸿蒙应用<code>App</code>浏览商品、加入购物车、下单支付、查看订单状态等。</p>
<p><strong>管理端：</strong> 管理员可以通过后台管理系统管理商品（增删改查）、处理订单、查看销售数据等。</p>
<p>在项目中，我主要负责以下功能模块的开发：</p>
<ol>
<li><strong>用户端：</strong><ul>
<li><strong>商品列表页：</strong> 使用鸿蒙的<code>ArkUI</code>框架实现了商品列表的展示，支持分页加载和图片懒加载，优化了页面性能。</li>
<li><strong>商品详情页：</strong> 实现了商品详情展示、规格选择、加入购物车等功能，使用了鸿蒙的自定义组件和动画库来提升用户体验。</li>
<li><strong>购物车模块：</strong> 实现了购物车的增删改查功能，并与后端接口对接，确保数据实时同步。</li>
</ul>
</li>
<li><strong>管理端：</strong><ul>
<li><strong>商品管理模块：</strong> 使用<code>Vue3</code>和<code>Element-Plus</code>开发了商品管理的增删改查功能，包括商品信息的表单校验和图片上传功能。</li>
<li><strong>订单管理模块：</strong> 实现了订单列表的展示和状态更新功能，支持按条件筛选和分页查询。</li>
</ul>
</li>
</ol>
<p>在开发过程中，我遇到了一些挑战，比如：</p>
<ul>
<li><strong>性能优化：</strong> 在商品列表页中，图片懒加载和分页加载的实现需要兼顾性能和用户体验，我通过鸿蒙的<code>List</code>组件和自定义指令优化了渲染效率。</li>
<li><strong>接口对接：</strong> 在购物车模块中，需要与后端<code>API</code>频繁交互，我使用<code>Axios</code>封装了统一的请求工具，并处理了接口的错误状态和超时问题。</li>
</ul>
<h3 id="5-项目遇到了什么问题？你是如何解决的？（中）"><a href="#5-项目遇到了什么问题？你是如何解决的？（中）" class="headerlink" title="5. 项目遇到了什么问题？你是如何解决的？（中）"></a>5. 项目遇到了什么问题？你是如何解决的？（中）</h3><p>在项目中，我遇到了一些技术挑战和协作问题，以下是两个典型的例子：</p>
<ol>
<li><strong>用户端图片加载性能问题</strong><br>在开发商品列表页时，由于商品图片数量较多，直接加载所有图片导致页面卡顿，用户体验较差。<br><strong>解决方案：</strong><ul>
<li>我使用了鸿蒙的<code>List</code>组件和图片懒加载技术，只有当图片进入用户可视区域时才加载图片。</li>
<li>同时，我对图片进行了压缩和<code>CDN</code>加速，进一步减少了加载时间。</li>
<li>最终，页面加载速度提升了约40%，用户体验显著改善。</li>
</ul>
</li>
<li><strong>管理端表单校验复杂性问题</strong><br>在商品管理模块中，商品信息的表单字段较多，校验规则复杂（如价格必须为数字、库存不能为负数等），直接手写校验逻辑会导致代码冗长且难以维护。<br><strong>解决方案：</strong><ul>
<li>我使用了<code>Element-Plus</code>的表单组件，并通过校验规则配置实现了表单校验。- 我使用了Vue3的<code>vuelidate</code>库来实现表单校验，将校验规则抽象成独立的模块，便于复用和维护。</li>
<li>同时，我为每个字段设计了清晰的错误提示信息，提升了用户操作的友好性。</li>
<li>最终，表单校验代码量减少了约<code>30%</code>，且后续新增字段时只需简单修改校验规则即可。</li>
</ul>
</li>
</ol>
<p>此外，在团队协作中，我还遇到过前后端接口对接不一致的问题。为了解决这个问题，我主动与后端同事沟通，制定了统一的接口文档，并使用<code>Postman</code>进行接口测试，确保前后端数据格式一致。</p>
<h3 id="6-这个项目最难的或者说你印象最深的是那个功能？（中）"><a href="#6-这个项目最难的或者说你印象最深的是那个功能？（中）" class="headerlink" title="6. 这个项目最难的或者说你印象最深的是那个功能？（中）"></a>6. 这个项目最难的或者说你印象最深的是那个功能？（中）</h3><p>在项目中，我印象最深的是用户端的购物车功能。这个功能看似简单，但实际上涉及复杂的交互逻辑和与后端的数据同步，开发过程中遇到了不少挑战。</p>
<ol>
<li><strong>需求分析</strong><br>购物车功能需要支持以下核心操作：<ul>
<li>添加商品到购物车。</li>
<li>修改商品数量。</li>
<li>删除商品。</li>
<li>实时计算总价。</li>
<li>与后端同步数据，确保用户在不同设备上登录时购物车数据一致。</li>
</ul>
</li>
<li><strong>技术实现</strong><ul>
<li>我使用鸿蒙的ArkUI框架开发了购物车的<code>UI</code>界面，包括商品列表、数量选择器和总价计算区域。</li>
<li>为了提升用户体验，我加入了动画效果，比如删除商品时的渐隐动画。</li>
<li>购物车数据通过<code>API</code>与后端实时同步，我使用<code>Axios</code>封装了统一的请求工具，并处理了网络异常和超时问题。</li>
</ul>
</li>
<li><strong>遇到的挑战</strong><ul>
<li>数据同步问题：由于购物车数据需要实时同步，而网络请求可能存在延迟或失败，我设计了一个本地缓存机制，在网络请求失败时先更新本地数据，待网络恢复后再同步到后端。</li>
<li>性能问题：当购物车中商品数量较多时，频繁的<code>DOM</code>操作会导致页面卡顿。我通过虚拟列表技术优化了渲染性能，只渲染用户可见区域的商品项。</li>
<li>交互复杂性：修改商品数量时需要实时计算总价，同时触发后端数据更新。我使用了鸿蒙的状态管理工具来确保数据的一致性，并通过防抖技术减少了不必要的<code>API</code>请求。</li>
</ul>
</li>
<li><strong>最终成果</strong><br>经过多次优化和测试，购物车功能最终实现了流畅的用户体验和稳定的数据同步。用户反馈非常好，尤其是在网络不稳定的情况下，本地缓存机制显著提升了使用体验。</li>
</ol>
<h3 id="7-平时遇到问题怎么解决？（高）"><a href="#7-平时遇到问题怎么解决？（高）" class="headerlink" title="7. 平时遇到问题怎么解决？（高）"></a>7. 平时遇到问题怎么解决？（高）</h3><p>平时遇到问题时，我会按照以下步骤来解决：</p>
<ol>
<li><strong>分析问题</strong><br>首先，我会明确问题的本质和影响范围。比如，是代码报错、性能问题，还是需求理解不清？我会通过日志、调试工具或与同事沟通来定位问题的根源。</li>
<li><strong>独立尝试解决</strong><br>在明确问题后，我会先尝试独立解决。比如：<ul>
<li>如果是代码问题，我会查阅官方文档、技术博客或社区论坛（如<code>Stack Overflow</code>、<code>GitHub Issues</code>）寻找解决方案。</li>
<li>如果是性能问题，我会使用性能分析工具（如<code>Chrome DevTools</code>、鸿蒙的性能分析工具）来定位瓶颈。</li>
<li>如果是技术选型问题，我会对比不同方案的优缺点，选择最适合当前场景的方案。</li>
</ul>
</li>
<li><strong>寻求帮助</strong><br>如果经过一段时间（比如半小时到一小时）仍然无法解决，我会主动寻求帮助。比如：<ul>
<li>向更有经验的同事请教，描述我已经尝试过的解决方案，以便他们快速理解问题。</li>
<li>在技术社区发帖，附上详细的错误信息和代码片段，以便其他人更好地帮助我。</li>
</ul>
</li>
<li><strong>总结和记录</strong><br>问题解决后，我会总结问题的原因和解决方案，并记录下来。比如：<ul>
<li>如果是代码问题，我会在代码中添加注释，说明问题的背景和解决方案。</li>
<li>如果是技术难点，我会整理成文档或博客，方便以后查阅，也帮助团队其他成员避免类似问题。</li>
</ul>
</li>
<li><strong>举一个实际例子</strong><br>比如，在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。我首先通过调试工具定位到问题出在数据同步的逻辑上，然后查阅了鸿蒙的状态管理文档，发现是因为状态更新没有及时触发。最终，我通过使用鸿蒙的<code>@State</code>和<code>@Watch</code>装饰器解决了这个问题，并将解决方案记录在团队的知识库中。</li>
</ol>
<h3 id="8-平时怎么学习？（高）"><a href="#8-平时怎么学习？（高）" class="headerlink" title="8. 平时怎么学习？（高）"></a>8. 平时怎么学习？（高）</h3><p>我平时的学习主要分为以下几个方面：</p>
<ol>
<li><strong>系统化学习</strong></li>
</ol>
<ul>
<li><strong>技术文档：</strong> 我会定期阅读官方文档（如<code>Vue3</code>、鸿蒙、<code>React</code>等），了解最新的特性和最佳实践。比如，在学习鸿蒙开发时，我通过官方文档掌握了<code>ArkUI</code>框架的使用方法。</li>
<li><strong>在线课程：</strong> 我会选择一些高质量的在线课程（如慕课网、<code>Coursera</code>、<code>Udemy</code>等），系统地学习新技术。比如，我最近在学习前端性能优化相关的课程，掌握了如何通过懒加载和代码分割提升页面性能。</li>
</ul>
<ol>
<li><strong>实践驱动学习</strong><ul>
<li><strong>项目实践：</strong> 我认为实践是最好的学习方式。在工作中，我会将学到的新技术应用到实际项目中。比如，在学习<code>Vue3</code>的<code>Composition API</code>后，我将其用在了管理端的开发中，显著提升了代码的可维护性。</li>
<li><strong>个人项目：</strong> 除了工作项目，我还会做一些个人项目来巩固学习成果。比如，我最近用<code>React</code>开发了一个个人博客，实践了服务端渲染（<code>SSR</code>）和静态站点生成（<code>SSG</code>）技术。</li>
</ul>
</li>
<li><strong>社区和博客</strong><ul>
<li><strong>技术社区：</strong> 我经常参与技术社区（如<code>GitHub</code>、<code>Stack Overflow</code>、掘金等），阅读其他人的经验分享，并尝试解决社区中的问题。这不仅帮助我学到了很多实用的技巧，也让我了解了行业的最新动态。</li>
<li><strong>技术博客：</strong> 我会定期阅读技术博客（如阮一峰的网络日志、前端早读课等），并尝试将学到的知识整理成自己的博客，分享给其他人。</li>
</ul>
</li>
<li><strong>总结和复盘</strong><ul>
<li><strong>学习笔记：</strong> 我会将学习过程中的重点和难点记录下来，形成学习笔记。比如，在学习鸿蒙开发时，我整理了<code>ArkUI</code>框架的常用组件和<code>API</code>，方便以后查阅。</li>
<li><strong>项目复盘：</strong> 每次完成一个项目后，我都会进行复盘，总结项目中的技术难点和解决方案，并思考如何改进。</li>
</ul>
</li>
<li><strong>举一个实际例子</strong><br>比如，在学习前端性能优化时，我通过阅读文档和课程掌握了懒加载和代码分割技术，并将其应用到了商品列表页的开发中，将页面加载时间减少了<code>30%</code>。</li>
</ol>
<h3 id="9-前端和后端如何交互？如何对接口？（高）"><a href="#9-前端和后端如何交互？如何对接口？（高）" class="headerlink" title="9. 前端和后端如何交互？如何对接口？（高）"></a>9. 前端和后端如何交互？如何对接口？（高）</h3><p>前端和后端主要通过<code>API</code>接口进行交互，具体流程如下：</p>
<ol>
<li><p><strong>接口定义</strong></p>
<ul>
<li>在项目初期，前后端会一起讨论并确定接口的请求方式（如<code>GET</code>、<code>POST</code>）、<code>URL</code>路径、请求参数和返回数据格式。</li>
<li>通常会使用接口文档工具（如<code>Swagger</code>、<code>YAPI</code>、<code>Apifox</code>）来规范接口定义，确保前后端对接口的理解一致。</li>
</ul>
</li>
<li><p><strong>数据格式</strong></p>
<ul>
<li><p>前后端交互的数据格式通常是<code>JSON</code>，因为它轻量且易于解析。</p>
</li>
<li><p>前端通过<code>axios</code>或<code>fetch</code>等工具发送请求，后端返回<code>JSON</code>格式的数据。</p>
</li>
<li><p>例如，获取商品列表的接口可能是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /api/products 返回数据：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;T-shirt&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jeans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">199.9</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>调试工具</strong></p>
<ul>
<li>在开发过程中，我会使用<code>Postman</code>或<code>Apifox</code>等工具测试接口，确保接口的正确性和稳定性。</li>
<li>如果接口返回的数据格式或状态码不符合预期，我会与后端同事沟通，调整接口逻辑。</li>
</ul>
</li>
<li><p><strong>错误处理</strong></p>
<ul>
<li>前端需要对接口的错误状态进行处理，比如网络错误、超时、<code>401</code>未授权、<code>404</code>未找到等。</li>
<li>我通常会封装一个统一的请求工具（如基于<code>axios</code>的封装），在请求拦截器和响应拦截器中处理错误状态，并给出友好的用户提示。</li>
</ul>
</li>
<li><p><strong>实际例子</strong><br>比如，在开发购物车功能时，我需要与后端对接以下几个接口：</p>
<ul>
<li><strong>添加商品到购物车：</strong> <code>POST /api/cart</code>，请求体包含商品ID和数量。</li>
<li><strong>获取购物车列表：</strong> <code>GET /api/cart</code>，返回当前用户的购物车商品列表。</li>
<li><strong>更新商品数量：</strong> <code>PUT /api/cart/&#123;id&#125;</code>，请求体包含新的数量。</li>
<li><strong>删除商品：</strong> <code>DELETE /api/cart/&#123;id&#125;</code>。</li>
</ul>
</li>
</ol>
<p>在对接过程中，我使用<code>Postman</code>测试了每个接口，并确保前端能够正确处理返回的数据和错误状态。比如，当用户未登录时，后端会返回<code>401</code>状态码，前端会跳转到登录页面。</p>
<h3 id="10-平时是如何和后端对接的？（高）"><a href="#10-平时是如何和后端对接的？（高）" class="headerlink" title="10. 平时是如何和后端对接的？（高）"></a>10. 平时是如何和后端对接的？（高）</h3><p>在项目中，我与后端的对接主要分为以下几个步骤：</p>
<ol>
<li><strong>需求分析和接口定义</strong><ul>
<li>在项目初期，我会与后端开发人员一起参与需求讨论，明确每个功能模块的业务逻辑和数据交互需求。</li>
<li>我们会使用接口文档工具（如<code>Swagger</code>、<code>YAPI</code>、<code>Apifox</code>）来定义接口的请求方式、<code>URL</code>路径、请求参数和返回数据格式。比如，在开发购物车功能时，我们定义了以下接口：<ul>
<li>获取购物车列表：<code>GET /api/cart</code></li>
<li>添加商品到购物车：<code>POST /api/cart</code></li>
<li>更新商品数量：<code>PUT /api/cart/&#123;id&#125;</code></li>
<li>删除商品：<code>DELETE /api/cart/&#123;id&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>接口调试</strong><ul>
<li>在接口定义完成后，我会使用<code>Postman</code>或<code>Apifox</code>等工具测试接口，确保接口的正确性和稳定性。</li>
<li>如果接口返回的数据格式或状态码不符合预期，我会及时与后端开发人员沟通，调整接口逻辑。</li>
</ul>
</li>
<li><strong>数据格式和错误处理</strong><ul>
<li>前后端交互的数据格式通常是<code>JSON</code>。我会根据接口文档，确保前端发送的请求参数和接收的返回数据格式正确。</li>
<li>对于接口的错误状态（如<code>401</code>未授权、<code>404</code>未找到、<code>500</code>服务器错误等），我会在前端进行统一处理。比如，当用户未登录时，后端返回<code>401</code>状态码，前端会跳转到登录页面。</li>
</ul>
</li>
<li><strong>联调和问题解决</strong><ul>
<li>在开发过程中，我会与后端开发人员保持密切沟通，定期进行接口联调，确保前后端的数据交互没有问题。</li>
<li>如果遇到问题，我会先通过日志和调试工具定位问题，然后与后端开发人员一起分析原因并解决。比如，在开发订单功能时，我发现订单状态更新接口返回的数据格式与文档不一致，经过沟通后，后端同事调整了接口逻辑。</li>
</ul>
</li>
<li><strong>实际例子</strong><br>比如，在开发商品列表页时，我需要与后端对接获取商品列表的接口。我们定义了接口的请求方式为<code>GET /api/products</code>，返回的数据包括商品<code>ID</code>、名称、价格和图片<code>URL</code>。在调试过程中，我发现图片<code>URL</code>的字段名与文档不一致，经过沟通后，后端同事修正了字段名，确保了前后端的数据一致性。</li>
</ol>
<h3 id="11-项目如何优化？（中）"><a href="#11-项目如何优化？（中）" class="headerlink" title="11. 项目如何优化？（中）"></a>11. 项目如何优化？（中）</h3><p>在项目中，我从以下几个方面对项目进行了优化：</p>
<ol>
<li><strong>前端性能优化</strong><ul>
<li><strong>图片懒加载：</strong> 在商品列表页中，我实现了图片懒加载功能，只有当图片进入用户可视区域时才加载图片，减少了初始页面加载时间。</li>
<li><strong>代码分割：</strong> 使用<code>Vue3</code>的<code>import()</code>动态导入功能，将代码按路由拆分成多个<code>chunk</code>，减少了首屏加载的 <code>JavaScript</code> 体积。</li>
<li><strong>缓存策略：</strong> 对静态资源（如<code>CSS</code>、<code>JS</code>、图片）设置了合适的缓存策略，减少了重复请求。</li>
</ul>
</li>
<li><strong>用户体验优化</strong><ul>
<li><strong>加载状态提示：</strong> 在数据加载时，增加了加载动画和骨架屏，提升了用户体验。</li>
<li><strong>错误处理：</strong> 对接口请求的错误状态（如网络错误、超时、<code>401</code>未授权等）进行了统一处理，并给出友好的用户提示。</li>
<li><strong>交互优化：</strong> 在购物车功能中，加入了动画效果（如删除商品时的渐隐动画），提升了交互体验。</li>
</ul>
</li>
<li><strong>代码质量优化</strong><ul>
<li><strong>模块化开发：</strong> 将通用的功能（如表单校验、请求封装）抽象成独立的模块，提升了代码的可维护性和复用性。</li>
<li><strong>代码规范：</strong> 使用<code>ESLint</code>和<code>Prettier</code>规范代码风格，确保团队代码风格一致。</li>
<li><strong>单元测试：</strong> 为核心功能（如购物车逻辑、表单校验）编写了单元测试，确保代码的稳定性和可维护性。</li>
</ul>
</li>
<li><strong>后端接口优化</strong><ul>
<li><strong>接口合并：</strong> 在商品列表页中，将多个接口合并成一个接口，减少了请求次数。</li>
<li><strong>分页和懒加载：</strong> 对大数据量的接口（如商品列表）实现了分页和懒加载，减少了单次请求的数据量。</li>
</ul>
</li>
<li><strong>实际例子</strong><br>比如，在优化商品列表页时，我发现页面加载时间较长，经过分析发现是因为图片加载过多。我通过实现图片懒加载和<code>CDN</code>加速，将页面加载时间从X秒减少到<code>Y</code>秒，显著提升了用户体验。</li>
</ol>
<h3 id="12-从项目中获得了什么？（低）"><a href="#12-从项目中获得了什么？（低）" class="headerlink" title="12. 从项目中获得了什么？（低）"></a>12. 从项目中获得了什么？（低）</h3><p>从这个项目中，我获得了以下几方面的收获：</p>
<ol>
<li><strong>技术能力的提升</strong><ul>
<li><strong>鸿蒙应用开发：</strong> 通过开发用户端界面，我深入掌握了鸿蒙的ArkUI框架和<code>JavaScript</code>&#x2F;<code>TypeScript</code>语言，能够熟练实现复杂的UI交互和动画效果。</li>
<li><strong>Vue3开发：</strong> 在管理端开发中，我熟练使用了<code>Vue3</code>的组合式<code>Composition API</code>和<code>Element-Plus</code>组件库，提升了代码的可维护性和开发效率。</li>
<li><strong>前后端对接：</strong> 通过与后端的协作，我掌握了接口对接、数据格式处理和错误状态管理的技巧，能够独立完成前后端联调。</li>
</ul>
</li>
<li><strong>团队协作能力的提升</strong><ul>
<li><strong>沟通能力：</strong> 在项目中，我与后端开发人员、产品经理和测试人员保持了密切沟通，学会了如何清晰地表达需求和问题。</li>
<li><strong>协作工具：</strong> 我熟练使用了<code>Git</code>进行版本控制，以及<code>Jira</code>进行任务管理，确保了团队协作的高效性。</li>
</ul>
</li>
<li><strong>问题解决能力的提升</strong><ul>
<li><strong>性能优化：</strong> 在商品列表页的开发中，我通过图片懒加载和代码分割技术，将页面加载时间减少了<code>40%</code>，提升了用户体验。</li>
<li><strong>错误处理：</strong> 在接口对接中，我封装了统一的请求工具，处理了网络错误、超时和<code>401</code>未授权等问题，确保了系统的稳定性。</li>
</ul>
</li>
<li><strong>项目管理和时间管理能力的提升</strong></li>
</ol>
<ul>
<li><strong>任务拆分：</strong> 在项目初期，我学会了如何将大任务拆分成小任务，并合理安排时间，确保按时交付。</li>
<li><strong>优先级管理：</strong> 在开发过程中，我能够根据需求的重要性和紧急程度，合理安排开发顺序，确保核心功能优先完成。</li>
</ul>
<p><strong>实际例子</strong><br>比如，在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。通过分析问题、查阅文档和与后端同事沟通，我最终使用鸿蒙的状态管理工具解决了这个问题。这个过程让我深刻理解了状态管理的重要性，也提升了我的问题解决能力。</p>
<h3 id="13-你觉得这个项目有什么可以改进的地方？（低）"><a href="#13-你觉得这个项目有什么可以改进的地方？（低）" class="headerlink" title="13. 你觉得这个项目有什么可以改进的地方？（低）"></a>13. 你觉得这个项目有什么可以改进的地方？（低）</h3><p>虽然项目整体完成得不错，但我认为还有一些可以改进的地方：</p>
<ol>
<li><strong>技术优化</strong><ul>
<li><strong>性能优化：</strong> 虽然我们已经实现了图片懒加载和代码分割，但还可以进一步优化。比如，可以考虑使用<code>Service Worker</code>实现离线缓存，或者使用<code>WebP</code>格式的图片来减少图片体积。</li>
<li><strong>代码质量：</strong> 虽然我们使用了<code>ESLint</code>和<code>Prettier</code>规范代码风格，但还可以引入更多的单元测试和端到端测试，确保代码的稳定性和可维护性。</li>
</ul>
</li>
<li><strong>用户体验优化</strong><ul>
<li><strong>加载体验：</strong> 虽然我们增加了加载动画和骨架屏，但还可以进一步优化加载体验。比如，可以使用预加载或预渲染技术，提前加载用户可能访问的页面。</li>
<li><strong>交互细节：</strong> 虽然我们已经实现了一些动画效果，但还可以在交互细节上做得更好。比如，在用户点击按钮时增加微交互反馈，提升用户的参与感。</li>
</ul>
</li>
<li><strong>团队协作</strong><ul>
<li><strong>接口文档管理：</strong> 虽然我们使用了<code>Swagger</code>生成接口文档，但文档的更新和维护还不够及时。可以考虑引入自动化文档生成工具，确保文档与代码同步更新。</li>
<li><strong>沟通流程：</strong> 虽然我们定期进行沟通，但有时需求变更没有及时同步。可以引入更规范的需求变更流程，确保所有团队成员都能及时了解最新需求。</li>
</ul>
</li>
<li><strong>项目管理</strong><ul>
<li><strong>任务拆分：</strong> 虽然我们将大任务拆分成小任务，但有时任务的优先级安排不够合理。可以引入更细致的优先级评估机制，确保核心功能优先完成。</li>
<li><strong>进度跟踪：</strong> 虽然我们使用了<code>Jira</code>进行任务管理，但进度跟踪还不够细致。可以引入每日站会或每周复盘，及时发现和解决问题。</li>
</ul>
</li>
<li><strong>实际例子</strong><br>比如，在商品列表页的开发中，虽然我们实现了图片懒加载，但还可以进一步优化图片的加载策略。比如，可以使用<code>Intersection Observer API</code>更精确地控制图片的加载时机，或者使用<code>CDN</code>加速来提升图片的加载速度。</li>
</ol>
<h3 id="14-项目中遇到的坑有哪些？你是如何解决的？（低）"><a href="#14-项目中遇到的坑有哪些？你是如何解决的？（低）" class="headerlink" title="14. 项目中遇到的坑有哪些？你是如何解决的？（低）"></a>14. 项目中遇到的坑有哪些？你是如何解决的？（低）</h3><p>在项目中，我遇到了一些技术难点和<code>坑</code>，以下是两个典型的例子：</p>
<ol>
<li><strong>图片懒加载的性能问题</strong><br>在开发商品列表页时，我实现了图片懒加载功能，但发现页面滚动时仍然有明显的卡顿现象。<br><strong>问题分析：</strong><br>经过调试，我发现是因为图片加载时触发了大量的<code>DOM</code>操作，导致页面渲染性能下降。<br><strong>解决方案：</strong><ul>
<li>我使用了<code>Intersection Observer API</code>来更精确地控制图片的加载时机，只有当图片进入可视区域时才加载图片。</li>
<li>同时，我对图片进行了压缩，并使用<code>CDN</code>加速，进一步减少了图片加载时间。</li>
<li>最终，页面滚动流畅度显著提升，用户体验得到了改善。</li>
</ul>
</li>
<li><strong>接口数据格式不一致</strong><br>在对接购物车功能时，我发现后端返回的数据格式与接口文档不一致，导致前端无法正确解析数据。<br><strong>问题分析：</strong><ul>
<li>经过排查，我发现是因为后端开发人员在修改接口时没有及时更新文档。<br><strong>解决方案：</strong></li>
<li>我主动与后端开发人员沟通，明确了数据格式的要求，并建议使用<code>Swagger</code>自动生成接口文档，确保文档与代码同步更新。</li>
<li>同时，我在前端代码中增加了数据格式的校验逻辑，确保即使接口返回的数据格式不一致，前端也能正确处理。</li>
</ul>
</li>
<li><strong>状态管理问题</strong><br>在开发购物车功能时，我遇到了商品数量更新后总价计算不准确的问题。<br><strong>问题分析：</strong><ul>
<li>经过调试，我发现是因为状态更新没有及时触发，导致总价计算逻辑没有执行。<br><strong>解决方案：</strong></li>
<li>我使用了鸿蒙的<code>@State</code>和<code>@Watch</code>装饰器来管理状态，确保状态更新时能够及时触发总价计算逻辑。</li>
<li>同时，我对购物车的数据结构进行了优化，减少了不必要的状态更新。</li>
</ul>
</li>
<li><strong>实际例子</strong><br>比如，在开发商品详情页时，我遇到了图片轮播组件在快速滑动时卡顿的问题。经过分析，我发现是因为图片加载和<code>DOM</code>操作过于频繁。我通过使用虚拟列表技术和图片预加载，优化了组件的性能，最终解决了卡顿问题。</li>
</ol>
<h3 id="15-你觉得这个项目有什么可以分享的？（低）"><a href="#15-你觉得这个项目有什么可以分享的？（低）" class="headerlink" title="15. 你觉得这个项目有什么可以分享的？（低）"></a>15. 你觉得这个项目有什么可以分享的？（低）</h3><p>在这个项目中，我有以下几点可以分享：</p>
<ol>
<li><p><strong>技术亮点</strong></p>
<ul>
<li><strong>鸿蒙应用开发：</strong> 通过开发用户端界面，我深入掌握了鸿蒙的ArkUI框架和<code>JavaScript</code>&#x2F;<code>TypeScript</code>语言，能够熟练实现复杂的UI交互和动画效果。比如，在商品详情页中，我使用鸿蒙的自定义组件和动画库实现了图片轮播和规格选择功能，提升了用户体验。</li>
<li><strong>Vue3开发：</strong> 在管理端开发中，我熟练使用了<code>Vue3</code>的<code>Composition API</code>和<code>Element-Plus</code>组件库，提升了代码的可维护性和开发效率。比如，在商品管理模块中，我使用<code>Vue3</code>的<code>ref</code>和<code>computed</code>实现了表单的动态校验功能。</li>
</ul>
</li>
<li><p><strong>团队协作经验</strong></p>
<ul>
<li><strong>接口对接：</strong> 在项目中，我与后端开发人员保持了密切沟通，使用<code>Swagger</code>生成接口文档，确保前后端对接口的理解一致。比如，在开发购物车功能时，我通过接口文档和<code>Postman</code>测试工具，快速完成了接口对接。</li>
<li><strong>任务管理：</strong> 我们使用<code>Jira</code>进行任务管理，将大任务拆分成小任务，并合理安排优先级，确保项目按时交付。比如，在开发订单功能时，我根据需求的重要性和紧急程度，优先完成了核心功能。</li>
</ul>
</li>
<li><p><strong>问题解决经验</strong></p>
<ul>
<li><strong>性能优化：</strong> 在商品列表页的开发中，我通过图片懒加载和代码分割技术，将页面加载时间减少了<code>40%</code>，提升了用户体验。比如，我使用<code>Intersection Observer API</code>实现了图片的懒加载功能，并对图片进行了压缩和<code>CDN</code>加速。</li>
<li><strong>错误处理：</strong> 在接口对接中，我封装了统一的请求工具，处理了网络错误、超时和<code>401</code>未授权等问题，确保了系统的稳定性。比如，当接口返回<code>401</code>时，前端会跳转到登录页面；当返回500时，前端会显示‘服务器错误，请稍后重试’的提示。</li>
</ul>
</li>
<li><p><strong>创新点</strong></p>
<ul>
<li><strong>交互优化：</strong> 在购物车功能中，我加入了动画效果（如删除商品时的渐隐动画），提升了交互体验。比如，我使用鸿蒙的动画库实现了商品删除时的渐隐效果，让用户操作更加直观。</li>
<li><strong>模块化开发：</strong> 我将通用的功能（如表单校验、请求封装）抽象成独立的模块，提升了代码的可维护性和复用性。比如，我封装了一个基于<code>axios</code>的请求工具，统一处理了接口请求和错误状态。</li>
</ul>
</li>
<li><p><strong>实际例子</strong><br>比如，在开发商品列表页时，我通过图片懒加载和代码分割技术，将页面加载时间从<code>X</code>秒减少到<code>Y</code>秒，显著提升了用户体验。这个优化过程让我深刻理解了性能优化的重要性，也让我掌握了更多的前端优化技巧。</p>
</li>
</ol>
<h3 id="16-图片懒加载实现的原理？（中）"><a href="#16-图片懒加载实现的原理？（中）" class="headerlink" title="16.  图片懒加载实现的原理？（中）"></a>16.  图片懒加载实现的原理？（中）</h3><p>图片懒加载是一种优化网页性能的技术，它的核心原理是延迟加载图片，只有当图片进入用户的可视区域时才加载图片，从而减少初始页面加载时间和带宽消耗。以下是图片懒加载的实现原理和具体步骤：</p>
<ol>
<li><p><strong>实现原理</strong></p>
<ul>
<li><strong>监听滚动事件：</strong> 通过监听页面的滚动事件，判断图片是否进入了用户的可视区域。</li>
<li><strong>动态加载图片：</strong> 当图片进入可视区域时，将图片的src属性替换为真实的图片地址，触发图片加载。</li>
</ul>
</li>
<li><p><strong>技术细节</strong></p>
<ul>
<li><strong>占位符：</strong> 在图片未加载时，使用一个占位符（如1x1的透明图片或<code>Loading</code>图标）作为<code>src</code>属性，避免图片未加载时显示空白。</li>
<li><strong>自定义属性：</strong> 将真实的图片地址存储在自定义属性中（如<code>data-src</code>），当需要加载图片时，将<code>data-src</code>的值赋给<code>src</code>属性。</li>
<li><strong>Intersection Observer API：</strong> 现代浏览器提供了<code>Intersection Observer API</code>，可以更高效地监听元素是否进入可视区域，避免频繁触发滚动事件。</li>
</ul>
</li>
<li><p><strong>实现步骤</strong></p>
<p><strong>HTML结构：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;real-image.jpg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;placeholder.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Lazy Load Image&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript逻辑：</strong></p>
<ul>
<li>使用<code>Intersection Observer API</code>监听图片元素。</li>
<li>当图片进入可视区域时，将<code>data-src</code>的值赋给<code>src</code>属性，触发图片加载。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img[data-src]&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> img = entry.<span class="property">target</span>;</span><br><span class="line">    img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">    img.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>);</span><br><span class="line">    observer.<span class="title function_">unobserve</span>(img);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">images.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> observer.<span class="title function_">observe</span>(img));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实际例子</strong><br>比如，在开发商品列表页时，我使用了图片懒加载技术。初始加载时，页面只加载用户可见区域的图片，当用户滚动页面时，再动态加载其他图片。通过这种方式，页面加载时间减少了<code>40%</code>，用户体验得到了显著提升。</p>
</li>
</ol>
<h3 id="17-购物车实现的原理？（中）"><a href="#17-购物车实现的原理？（中）" class="headerlink" title="17. 购物车实现的原理？（中）"></a>17. 购物车实现的原理？（中）</h3><p>购物车功能是电商项目的核心功能之一，它的实现原理主要包括以下几个方面：</p>
<ol>
<li><p><strong>功能需求</strong><br>购物车功能需要支持以下核心操作：</p>
<ul>
<li><strong>添加商品：</strong> 用户可以将商品添加到购物车。</li>
<li><strong>修改数量：</strong> 用户可以修改购物车中商品的数量。</li>
<li><strong>删除商品：</strong> 用户可以从购物车中删除商品。</li>
<li><strong>计算总价：</strong> 实时计算购物车中商品的总价。</li>
<li><strong>数据同步：</strong> 确保用户在不同设备上登录时购物车数据一致。</li>
</ul>
</li>
<li><p><strong>数据结构</strong><br>购物车的数据结构通常包括以下字段：</p>
<ul>
<li><strong>商品ID：</strong> 唯一标识商品。</li>
<li><strong>商品名称：</strong> 商品的名称。</li>
<li><strong>商品价格：</strong> 商品的单价。</li>
<li><strong>商品数量：</strong> 用户选择的商品数量。</li>
<li><strong>商品图片：</strong> 商品的图片<code>URL</code>。</li>
</ul>
<p>例如，购物车数据可以表示为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;T-shirt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t-shirt.jpg&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jeans&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">199.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jeans.jpg&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前端实现</strong></p>
<ul>
<li><strong>添加商品：</strong> 用户点击“加入购物车”按钮时，前端将商品信息发送到后端，后端将商品添加到购物车并返回更新后的购物车数据。</li>
<li><strong>修改数量：</strong> 用户修改商品数量时，前端将新的数量发送到后端，后端更新购物车数据并返回更新后的购物车数据。</li>
<li><strong>删除商品：</strong> 用户删除商品时，前端将商品<code>ID</code>发送到后端，后端从购物车中删除该商品并返回更新后的购物车数据。</li>
<li><strong>计算总价：</strong> 前端根据购物车数据实时计算总价，并显示给用户。</li>
</ul>
</li>
<li><p><strong>后端实现</strong><br>接口设计：</p>
<ul>
<li><strong>获取购物车列表：</strong> <code>GET /api/cart</code></li>
<li>**添加商品到购物车：<code>POST /api/cart</code></li>
<li><strong>修改商品数量：</strong> <code>PUT /api/cart/</code></li>
<li><strong>删除商品：</strong> <code>DELETE /api/cart/</code></li>
<li><strong>数据存储：</strong> 购物车数据通常存储在数据库中，每个用户的购物车数据通过用户ID关联。</li>
</ul>
</li>
<li><p><strong>状态管理</strong></p>
<ul>
<li><strong>前端状态管理：</strong> 在前端，可以使用状态管理工具（如<code>Vuex</code>、<code>Pinia</code>、<code>Redux</code>等）来管理购物车数据，确保数据的实时性和一致性。</li>
<li><strong>后端状态管理：</strong> 在后端，购物车数据通常存储在数据库中，确保用户在不同设备上登录时购物车数据一致。</li>
</ul>
</li>
<li><p><strong>实际例子</strong><br>比如，在开发购物车功能时，我使用了<code>Vue3</code>的<code>Composition API</code>和<code>Pinia</code>来管理购物车状态。用户添加商品时，前端将商品信息发送到后端，后端将商品添加到购物车并返回更新后的购物车数据。前端根据返回的数据更新购物车状态，并实时计算总价。</p>
</li>
</ol>
<h3 id="18-订单实现的原理？（中）"><a href="#18-订单实现的原理？（中）" class="headerlink" title="18. 订单实现的原理？（中）"></a>18. 订单实现的原理？（中）</h3><p>订单功能是电商项目的核心功能之一，它的实现原理主要包括以下几个方面：</p>
<ol>
<li><p><strong>功能需求</strong><br>订单功能需要支持以下核心操作：</p>
<ul>
<li><strong>生成订单：</strong> 用户从购物车中选择商品并生成订单。</li>
<li><strong>订单支付：</strong> 用户可以选择支付方式（如支付宝、微信支付等）完成支付。</li>
<li><strong>订单状态管理：</strong> 订单状态包括待支付、已支付、已发货、已完成、已取消等。</li>
<li><strong>订单查询：</strong> 用户可以查看自己的订单列表和订单详情。</li>
</ul>
</li>
<li><p><strong>业务流程</strong><br>订单的业务流程通常包括以下步骤：</p>
<p><strong>生成订单：</strong></p>
<ul>
<li>用户从购物车中选择商品并提交订单。</li>
<li>前端将商品信息和用户信息（如收货地址、支付方式等）发送到后端。</li>
<li>后端生成订单号，并将订单信息存储到数据库中。</li>
</ul>
<p><strong>订单支付：</strong></p>
<ul>
<li>用户选择支付方式并完成支付。</li>
<li>前端调用支付接口（如支付宝、微信支付等），并将支付结果发送到后端。</li>
<li>后端更新订单状态为“已支付”。</li>
</ul>
<p><strong>订单状态管理：</strong></p>
<ul>
<li>后端根据业务流程更新订单状态（如已发货、已完成等）。</li>
<li>前端通过轮询或<code>WebSocket</code>实时获取订单状态更新。</li>
</ul>
<p><strong>订单查询：</strong></p>
<ul>
<li>用户可以通过订单列表查看所有订单。</li>
<li>用户可以通过订单详情查看订单的详细信息（如商品信息、支付信息、物流信息等）。</li>
</ul>
</li>
<li><p><strong>数据结构</strong><br>订单的数据结构通常包括以下字段：</p>
<ul>
<li><strong>订单ID：</strong> 唯一标识订单。</li>
<li><strong>用户ID：</strong> 下单用户的<code>ID</code>。</li>
<li><strong>商品列表：</strong> 订单中包含的商品信息（如商品<code>ID</code>、名称、价格、数量等）。</li>
<li><strong>订单金额：</strong> 订单的总金额。</li>
<li><strong>订单状态：</strong> 订单的当前状态（如待支付、已支付、已发货等）。</li>
<li><strong>收货地址：</strong> 用户的收货地址。</li>
<li><strong>支付方式：</strong> 用户选择的支付方式（如支付宝、微信支付等）。</li>
<li><strong>创建时间：</strong> 订单的创建时间。</li>
</ul>
<p>例如，订单数据可以表示为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;202310120001&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;T-shirt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jeans&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">199.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;totalAmount&quot;</span><span class="punctuation">:</span> <span class="number">399.7</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;待支付&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市海淀区&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;paymentMethod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;支付宝&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;createdAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-12T10:00:00Z&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前后端交互</strong><br><strong>生成订单：</strong></p>
<ul>
<li>前端发送<code>POST</code>请求到后端生成订单接口，请求体包括商品信息和用户信息。</li>
<li>后端生成订单号，并将订单信息存储到数据库中，返回订单<code>ID</code>和支付信息。</li>
</ul>
<p><strong>订单支付：</strong></p>
<ul>
<li>前端调用支付接口（如支付宝、微信支付等），并将支付结果发送到后端。</li>
<li>后端更新订单状态为“已支付”。</li>
</ul>
<p><strong>订单查询：</strong></p>
<ul>
<li>前端发送<code>GET</code>请求到后端订单查询接口，获取订单列表或订单详情。</li>
<li>后端根据订单<code>ID</code>或用户<code>ID</code>查询数据库，返回订单信息。</li>
</ul>
</li>
<li><p><strong>实际例子</strong><br>比如，在开发订单功能时，我使用了<code>Vue3</code>的<code>Composition API</code>和<code>Pinia</code>来管理订单状态。用户提交订单时，前端将商品信息和用户信息发送到后端，后端生成订单号并返回支付信息。前端调用支付接口完成支付，并将支付结果发送到后端，后端更新订单状态为“已支付”。用户可以通过订单列表查看所有订单，并通过订单详情查看订单的详细信息。</p>
</li>
</ol>
<h3 id="19-支付实现的原理？（中）"><a href="#19-支付实现的原理？（中）" class="headerlink" title="19. 支付实现的原理？（中）"></a>19. 支付实现的原理？（中）</h3><p><strong>支付实现的核心原理</strong>（三步流程）：</p>
<ol>
<li><strong>发起支付请求</strong>：<ul>
<li>用户在前端选择支付方式（如微信&#x2F;支付宝），商家后端生成<strong>订单号</strong>和加密的支付参数（金额、描述）。</li>
<li>调用支付平台接口（如微信&#x2F;支付宝API），返回支付链接或二维码供用户授权。</li>
</ul>
</li>
<li><strong>支付平台处理</strong>：<ul>
<li>用户输入密码或生物验证，支付平台验证账户余额&#x2F;卡状态，完成扣款。</li>
<li>支付平台通过<strong>异步通知</strong>（回调）告知商家后端支付结果（需处理幂等性，避免重复入账）。</li>
</ul>
</li>
<li><strong>完成交易</strong>：<ul>
<li>商家后端验证通知签名和金额，更新订单状态为“已支付”，通知用户支付成功。</li>
<li>支付平台与银行进行<strong>资金清算</strong>（T+1等周期），最终到账商家账户。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>安全性</strong>：HTTPS传输、参数签名（如RSA）、防重放攻击（nonce&#x2F;timestamp）。</li>
<li><strong>异步架构</strong>：支付结果依赖回调，需设计重试机制和对账系统。</li>
<li><strong>幂等性</strong>：同一订单号仅处理一次支付，避免重复扣款。</li>
</ul>
<p><strong>示例流程</strong>：<br>用户下单 → 商家生成订单 → 跳转支付 → 支付平台扣款 → 异步回调 → 订单状态更新 → 发货。</p>
<h3 id="20-轮播实现的原理？（中）"><a href="#20-轮播实现的原理？（中）" class="headerlink" title="20. 轮播实现的原理？（中）"></a>20. 轮播实现的原理？（中）</h3><p><strong>轮播实现的核心原理</strong>（三步流程）：</p>
<ol>
<li><strong>结构与布局</strong>：<ul>
<li>容器设置 <code>overflow: hidden</code>，内部项目横向排列（如 <code>flex</code> 或 <code>absolute</code> 定位）。</li>
<li>仅显示当前项目，其他隐藏（或通过 <code>transform: translateX()</code> 偏移）。</li>
</ul>
</li>
<li><strong>切换逻辑</strong>：<ul>
<li><strong>自动播放</strong>：通过 <code>setInterval</code> 定时移动项目位置（如修改 <code>index</code> 或 <code>translateX</code> 值）。</li>
<li><strong>过渡效果</strong>：使用 CSS <code>transition</code>（如 <code>transform 0.5s ease</code>）实现平滑滑动&#x2F;淡入淡出。</li>
<li><strong>循环处理</strong>：克隆首尾项目，切换时快速跳转实现“无缝”衔接。</li>
</ul>
</li>
<li><strong>交互控制</strong>：<ul>
<li><strong>左右箭头</strong>：点击修改 <code>index</code>，触发切换。</li>
<li><strong>指示器</strong>（小圆点）：绑定点击事件，跳转指定 <code>index</code>。</li>
<li><strong>触摸滑动</strong>（移动端）：监听 <code>touchstart</code>&#x2F;<code>touchend</code> 计算滑动距离，判断切换方向。</li>
</ul>
</li>
</ol>
<p><strong>关键优化</strong>：</p>
<ul>
<li><strong>性能</strong>：优先用 <code>transform</code> 代替 <code>left/top</code>，触发 GPU 加速。</li>
<li><strong>防抖</strong>：避免快速点击&#x2F;滑动导致多次切换。</li>
<li><strong>懒加载</strong>：非当前项目延迟加载图片。</li>
</ul>
<h3 id="21-角色权限管理实现的原理？（中）"><a href="#21-角色权限管理实现的原理？（中）" class="headerlink" title="21. 角色权限管理实现的原理？（中）"></a>21. 角色权限管理实现的原理？（中）</h3><p><strong>角色权限管理核心原理</strong>（<code>RBAC</code>模型）：</p>
<ol>
<li><strong>三要素模型</strong>：<ul>
<li><strong>用户</strong>：系统使用者。</li>
<li><strong>角色</strong>：权限集合（如“管理员”“普通用户”）。</li>
<li><strong>权限</strong>：具体操作或资源访问权（如“删除文章”“访问财务数据”）。</li>
</ul>
</li>
<li><strong>关联关系</strong>：<ul>
<li>用户绑定角色（多对多），角色分配权限（多对多）。</li>
<li><strong>数据库表</strong>：用户表、角色表、权限表 + 用户-角色表、角色-权限表。</li>
</ul>
</li>
<li><strong>权限验证</strong>：<ul>
<li>用户访问资源时，系统根据其角色→权限链，校验是否具备操作资格（如接口注解 <code>@PreAuthorize(&quot;hasAuthority(&#39;delete&#39;)&quot;)</code>）。</li>
</ul>
</li>
</ol>
<p><strong>关键实现点</strong>：</p>
<ul>
<li><strong>动态管理</strong>：角色&#x2F;权限可配置化，支持实时更新（如缓存权限数据）。</li>
<li><strong>细粒度控制</strong>：支持功能权限（按钮级）和数据权限（如“仅查看本部门数据”）。</li>
<li><strong>框架集成</strong>：结合 <code>Spring Security</code>、<code>Shiro</code> 等实现拦截与鉴权。</li>
</ul>
<p><strong>示例流程</strong>：<br>用户登录 → 查询角色及权限 → 缓存权限 → 访问接口 → 拦截校验权限 → 通过&#x2F;拒绝。</p>
<h3 id="22-你封装过哪些业务组件吗？（中）"><a href="#22-你封装过哪些业务组件吗？（中）" class="headerlink" title="22. 你封装过哪些业务组件吗？（中）"></a>22. 你封装过哪些业务组件吗？（中）</h3><p>是的，我在项目中封装过多个<code>Vue</code>业务组件，比较典型的有：</p>
<p><strong>1. 动态表单生成器</strong></p>
<ul>
<li>基于<code>JSON Schema</code>配置自动渲染表单</li>
<li>集成校验规则（<code>async-validator</code>）</li>
<li>支持表单联动逻辑（<code>watch</code> + 动态组件）</li>
</ul>
<p><strong>2. 高阶表格组件</strong></p>
<ul>
<li>封装分页&#x2F;排序&#x2F;筛选逻辑</li>
<li>支持自定义列模板（作用域插槽）</li>
<li>集成<code>Excel</code>导出功能（<code>xlsx</code>库）</li>
</ul>
<p><strong>3. 可视化拖拽组件</strong></p>
<ul>
<li>基于<code>draggable</code>实现布局配置</li>
<li>维护组件树数据结构</li>
<li>实时预览与配置导出</li>
</ul>
<p><strong>4. 业务弹窗管理器</strong></p>
<ul>
<li>使用<code>provide/inject</code>实现全局调用</li>
<li>支持多弹窗堆栈管理</li>
<li>封装遮罩动画与定位逻辑</li>
</ul>
<p><strong>封装时主要考虑：</strong></p>
<ul>
<li>通过<code>props </code>&#x2F; <code>inject</code>实现配置化</li>
<li>使用插槽保证扩展性</li>
<li>采用<code>mixins</code>复用通用逻辑</li>
<li>通过<code>TS</code>类型增强提示</li>
<li>编写单元测试保证稳定性</li>
</ul>
<p>这些组件在<code>3</code>个中后台项目中复用，减少了<code>30%</code>重复代码量。</p>
<h3 id="23-说下你知道的前端UI框架？（中）"><a href="#23-说下你知道的前端UI框架？（中）" class="headerlink" title="23. 说下你知道的前端UI框架？（中）"></a>23. 说下你知道的前端UI框架？（中）</h3><p><strong>1. 全能型（跨场景）</strong></p>
<ul>
<li><p><strong>Bootstrap</strong></p>
<ul>
<li>响应式栅格 + 组件库，适合快速构建 PC&#x2F;移动端兼容页面</li>
<li>经典但风格较模板化（<code>v5</code> 弃用 jQuery 依赖）</li>
</ul>
</li>
<li><p><strong>Ant Design</strong></p>
<ul>
<li>React 生态标杆，企业级中后台首选（如阿里云、飞书）</li>
<li>组件 API 设计规范，但风格偏严肃</li>
</ul>
</li>
<li><p><strong>Material-UI (MUI)</strong></p>
<ul>
<li><p>基于 Google Material Design，动画与交互精细</p>
</li>
<li><p>支持主题深度定制（如 Figma 插件同步设计变量）</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 垂直领域</strong></p>
<ul>
<li><p><strong>Element Plus</strong>（Vue3）</p>
<ul>
<li>后台管理系统标配，表单&#x2F;表格组件功能强大</li>
<li>中文文档友好，社区资源丰富</li>
</ul>
</li>
<li><p><strong>Vant</strong>（Vue）</p>
<ul>
<li>移动端 H5 优先，支持 Rem 适配</li>
<li>组件轻量（如电商类高频组件：地址选择器、商品卡片）</li>
</ul>
</li>
<li><p><strong>Quasar</strong></p>
<ul>
<li><p>支持 SSR&#x2F;PWA&#x2F;Electron 等多端输出</p>
</li>
<li><p>内置 CLI 工具链，适合全栈型 Vue 项目</p>
</li>
</ul>
</li>
</ul>
<p><strong>3. 新兴趋势</strong></p>
<ul>
<li><p><strong>Tailwind CSS</strong></p>
<ul>
<li>原子化 CSS 方案，通过组合类名实现极致定制</li>
<li>需配合构建工具（如 PostCSS），适合设计系统搭建</li>
</ul>
</li>
<li><p><strong>Chakra UI</strong>（React）</p>
<ul>
<li>强调可访问性（a11y），主题配置基于 CSS-in-JS</li>
<li>组件 API 简洁，适合快速迭代的 ToC 产品</li>
</ul>
</li>
<li><p><strong>Semi Design</strong>（字节跳动）</p>
<ul>
<li><p>Figma 设计变量联动，支持深色模式一键切换</p>
</li>
<li><p>国内特色组件（如中文日期选择器）</p>
</li>
</ul>
</li>
</ul>
<p><strong>选型建议</strong></p>
<ul>
<li><p><strong>企业后台</strong> → Ant Design &#x2F; Element Plus</p>
</li>
<li><p><strong>移动 H5</strong> → Vant &#x2F; MUI Mobile</p>
</li>
<li><p><strong>高度定制</strong> → Tailwind CSS + Headless UI</p>
</li>
<li><p><strong>国际化产品</strong> → MUI &#x2F; Chakra UI</p>
</li>
</ul>
<h2 id="other部分"><a href="#other部分" class="headerlink" title="other部分"></a>other部分</h2><h3 id="1-react学过吗？学过版本（低）"><a href="#1-react学过吗？学过版本（低）" class="headerlink" title="1. react学过吗？学过版本（低）"></a>1. react学过吗？学过版本（低）</h3><p>是的，我系统学习过<code>React</code>技术栈并做过实践。具体掌握程度：</p>
<p><strong>基础能力</strong></p>
<ul>
<li>熟练使用<code>JSX</code>&#x2F;函数组件&#x2F;<code>Hooks</code>（<code>useState</code>&#x2F;<code>useEffect</code>等）</li>
<li>工程化：<code>Create React App</code>&#x2F;<code>Vite</code>配置</li>
<li>状态管理：<code>Redux Toolkit</code>基础使用</li>
</ul>
<p><strong>项目实践</strong></p>
<ul>
<li>用<code>React</code> + <code>TypeScript</code>重构过之前Vue版的<strong>后台管理系统</strong></li>
<li>实现过<strong>TodoMVC</strong>（<code>Context API</code>管理状态）</li>
<li>参与过<code>React + Ant Design</code>的<strong>数据看板项目</strong>（<code>ECharts</code>集成）</li>
</ul>
<p><strong>对比Vue差异</strong></p>
<ul>
<li>理解单向数据流与组合式<code>API</code>思想差异</li>
<li>熟悉<code>React</code>不可变数据更新模式</li>
<li>能快速切换响应式（<code>Vue</code>）与函数式（<code>React</code>）开发思维</li>
</ul>
<p><strong>学习深度</strong></p>
<ul>
<li>读过官方<code>Beta</code>文档新特性（如<code>Server Components</code>）</li>
<li>调试过<code>React DevTools</code>性能优化</li>
<li>近期在实践<code>Next.js</code>服务端渲染</li>
</ul>
<h3 id="2-react学过吗？没学过版本（低）"><a href="#2-react学过吗？没学过版本（低）" class="headerlink" title="2. react学过吗？没学过版本（低）"></a>2. react学过吗？没学过版本（低）</h3><p><strong>技术现状</strong><br>目前我的技术栈集中在<code>Vue</code>生态，但具备快速学习<code>React</code>的能力：</p>
<ol>
<li>已掌握<strong>现代前端核心能力</strong>（<code>ES6+/Vite/TS</code>）</li>
<li>深度理解<strong>组件化开发模式</strong>（<code>Vue</code>组件设计经验可直接迁移）</li>
<li>熟悉<strong>虚拟DOM&#x2F;状态管理</strong>等跨框架概念</li>
</ol>
<p><strong>学习规划</strong><br>如果岗位需要<code>React</code>，我可以：</p>
<ol>
<li>通过<strong>官方Beta文档</strong>完成基础速通（预计3天）</li>
<li>用React复刻<strong>现有Vue项目模块</strong>（如动态表单组件）</li>
<li>通过<strong>代码对比法</strong>加速框架差异理解（如<code>Vue 组合式 setup API vs React 钩子 Hooks</code>）</li>
</ol>
<p><strong>迁移优势</strong><br>我的Vue实战经验能快速转化为<code>React</code>生产力：</p>
<ul>
<li>组件封装模式 → <code>React</code>函数组件设计</li>
<li>Vuex使用经验 → <code>Redux</code>&#x2F;<code>Context API</code>理解</li>
<li><code>Vue Router</code> → <code>React Router</code>迁移能力</li>
<li>Vite构建经验 → <code>CRA</code>&#x2F;<code>Next.js</code>工程化配置</li>
</ul>
<p><strong>对React的认知</strong><br>虽然尚未实操，但持续关注技术动态：</p>
<ul>
<li>理解<code>Hooks</code>设计哲学（状态与UI分离）</li>
<li>熟悉<code>Ant Design</code>&#x2F;<code>Fluent UI</code>等<code>React</code>生态库</li>
</ul>
<p>可在<code>1</code>个月内达到生产可用水平，并愿意通过<strong>个人项目预研</strong>提前验证能力。</p>
<h3 id="3-小程序会吗，谈谈你对它的理解？（低）"><a href="#3-小程序会吗，谈谈你对它的理解？（低）" class="headerlink" title="3. 小程序会吗，谈谈你对它的理解？（低）"></a>3. 小程序会吗，谈谈你对它的理解？（低）</h3><p><strong>一、技术架构特点</strong></p>
<p><strong>双线程模型</strong></p>
<ul>
<li><strong>逻辑层</strong> (<code>App Service</code>)：独立JS线程，处理业务逻辑&#x2F;数据请求，无法操作<code>DOM</code></li>
<li><strong>视图层</strong> (<code>WebView</code>)：渲染<code>WXML</code>&#x2F;<code>WXSS</code>，通过<code>setData</code>与逻辑层通信</li>
<li><strong>通信机制</strong>：序列化数据经<code>Native</code>层中转，需避免传输大数据（如超过<code>1MB</code>的<code>JSON</code>）</li>
</ul>
<p><strong>渲染机制</strong></p>
<ul>
<li>类<code>Vue</code>的模板语法，但使用<code>wx:if</code>&#x2F;<code>wx:for</code>指令</li>
<li>自定义组件需显式声明<code>behaviors</code>复用逻辑</li>
<li>不支持动态插入<code>HTML</code>（需用<code>rich-text</code>组件或wxParse解析）</li>
</ul>
<p><strong>二、开发核心要点</strong></p>
<p><strong>工程化规范</strong></p>
<ul>
<li>文件结构强制拆分：<code>.json</code>(配置)&#x2F;<code>.wxml</code>(模板)&#x2F;<code>.wxss</code>(样式)&#x2F;<code>.js</code>(逻辑)</li>
<li>全局样式隔离：默认启用<code>styleIsolation</code>防止污染</li>
<li>分包加载：主包不超过<code>2MB</code>，总包不超过<code>20MB</code>，需在<code>app.json</code>显式声明</li>
</ul>
<p><strong>性能关键点</strong></p>
<ul>
<li><code>setData</code>优化：合并更新批次，避免高频调用（如滚动事件）</li>
<li>跳转策略：预加载<code>preloadPage</code>提升多页面流转体验</li>
<li>内存控制：及时销毁后台页面（<code>onUnload</code>中清除定时器&#x2F;解绑事件）</li>
</ul>
<p><strong>微信生态能力</strong></p>
<ul>
<li><strong>支付体系</strong>：与公众号支付打通，需关联商户号</li>
<li><strong>社交传播</strong>：分享卡片自定义（<code>onShareAppMessage</code>）</li>
<li><strong>开放能力：</strong><ul>
<li>地理位置（<code>getLocation </code>+ 腾讯地图<code>SDK</code>）</li>
<li>扫码（兼容<code>QR</code>码&#x2F;小程序码&#x2F;商品条形码）</li>
<li>生物认证（指纹&#x2F;人脸识别）</li>
</ul>
</li>
</ul>
<h3 id="4-uni-app会吗，谈谈你对它的理解？（低）"><a href="#4-uni-app会吗，谈谈你对它的理解？（低）" class="headerlink" title="4. uni-app会吗，谈谈你对它的理解？（低）"></a>4. uni-app会吗，谈谈你对它的理解？（低）</h3><p>对<code>uni-app</code>有实战经验，理解其核心价值在于<strong>跨平台开发提效</strong>：</p>
<ol>
<li><strong>跨端本质</strong>：基于<code>Vue</code>语法，通过条件编译（<code>#ifdef APP</code>）实现一套代码发布<code>iOS</code>&#x2F;<code>Android</code>&#x2F;<code>H5</code>&#x2F;各大小程序（微信&#x2F;支付宝等），开发过跨两端的电商平台项目。</li>
<li><strong>性能平衡</strong>：<ul>
<li>小程序&#x2F;<code>H5</code>走<code>Webview</code>渲染</li>
<li><code>App</code>端通过<code>weex</code>内核实现原生渲染（如复杂列表用<code>scroll-view</code>+<code>recycle-list</code>）</li>
<li>插件生态补充能力（如使用<code>renderjs</code>处理<code>Canvas</code>动画）</li>
</ul>
</li>
<li><strong>开发模式</strong>：<ul>
<li>类Vue的单文件组件结构（<code>.vue</code>文件整合<code>template</code>&#x2F;<code>script</code>&#x2F;<code>style</code>）</li>
<li>条件编译处理平台差异（如微信登录与<code>APP</code>微信登录的不同<code>API</code>调用）</li>
</ul>
</li>
</ol>
<p><strong>典型适用场景</strong>：需快速覆盖多端但业务逻辑高度重合的中复杂度项目，不适合强依赖原生特性的场景（如大型<code>3D</code>游戏）。</p>
<h3 id="5-react-native会吗，谈谈你对它的理解？（低）"><a href="#5-react-native会吗，谈谈你对它的理解？（低）" class="headerlink" title="5. react-native会吗，谈谈你对它的理解？（低）"></a>5. react-native会吗，谈谈你对它的理解？（低）</h3><p>对<code>React Native</code>有开发经验，理解其核心特点：</p>
<ol>
<li><strong>跨平台原生渲染</strong>：通过JS线程与原生模块通信（<code>Bridge</code>），使用<code>React</code>语法生成<strong>真实原生组件</strong>（非WebView），在电商<code>App</code>中实现接近原生的<code>60FPS</code>流畅列表</li>
<li><strong>性能关键点</strong>：<ul>
<li>优化<code>JS</code>与<code>Native</code>通信频次（如批量操作减少Bridge调用）</li>
<li>复杂交互通过<code>Native Modules</code>实现（如直播礼物动画用<code>Swift</code>&#x2F;<code>OC</code>编写）</li>
<li>列表性能依赖<code>FlatList</code>+<code>Memoization</code>优化</li>
</ul>
</li>
<li><strong>开发模式</strong>：<ul>
<li>热更新（<code>CodePush</code>）实现秒级<code>Bug</code>修复</li>
<li>生态依赖npm（如<code>react-navigation</code>处理路由）</li>
<li>调试工具链整合（<code>Flipper</code>+<code>React DevTools</code>）</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：适合需要高性能且团队具备原生开发能力的项目（如社交&#x2F;音视频<code>App</code>），对简单<code>H5</code>类需求性价比偏低。<br>个人实践：主导过跨平台音视频项目，通过<code>react-native-webrtc</code>实现低延迟通话，关键性能模块用<code>Swift</code>封装供<code>RN</code>调用。</p>
<h3 id="6-flutter会吗，谈谈你对它的理解？（低）"><a href="#6-flutter会吗，谈谈你对它的理解？（低）" class="headerlink" title="6. flutter会吗，谈谈你对它的理解？（低）"></a>6. flutter会吗，谈谈你对它的理解？（低）</h3><p>对<code>flutter</code>有实战经验，理解其核心差异：</p>
<ol>
<li><strong>自绘引擎突破</strong>：基于<code>Skia</code>图形库<strong>直接绘制UI</strong>（非原生控件），实现<strong>跨端像素级一致</strong>（<code>iOS</code>&#x2F;<code>Android</code>&#x2F;<code>Web</code>&#x2F;桌面），在跨境电商<code>App</code>中实现复杂动画无平台差异</li>
<li><strong>性能优势</strong>：<ul>
<li>脱离<code>JavaScriptCore</code>，<code>Dart</code>语言<code>AOT</code>编译成机器码（发布模式）</li>
<li><code>Widget</code>树差分更新（类似<code>React</code>虚拟<code>DOM</code>但更底层）</li>
<li><code>120Hz</code>高刷新率支持（如<code>iPad Pro</code>滚动优化）</li>
</ul>
</li>
<li><strong>开发范式</strong>：<ul>
<li>强类型<code>Dart</code>语言+声明式<code>UI</code>（<code>setState</code>&#x2F;<code>Bloc</code>状态管理）</li>
<li>热重载（<code>Hot Reload</code>）秒级更新保持状态</li>
<li>组件高度自定义（如<code>SliverAppBar</code>联动视差效果）</li>
</ul>
</li>
</ol>
<p><strong>典型场景</strong>：追求极致性能&#x2F;<code>UI</code>一致性的跨端项目（如<code>IoT</code>控制面板、高互动性应用），不适合强依赖平台原生特性的轻量级<code>H5</code>需求。</p>
<p><strong>项目案例：</strong> 使用<code>Flutter</code>重构金融<code>App</code>交易图表，通过<code>CustomPaint</code>实现百万级数据点的流畅绘制，性能超原生<code>WebView</code>方案<code>3</code>倍。</p>
<h3 id="7-nextjs会吗，谈谈你对它的理解？（低）"><a href="#7-nextjs会吗，谈谈你对它的理解？（低）" class="headerlink" title="7. nextjs会吗，谈谈你对它的理解？（低）"></a>7. nextjs会吗，谈谈你对它的理解？（低）</h3><p>对<code>Next.js</code>有深度使用经验，核心理解：</p>
<ol>
<li><strong>全栈框架定位</strong>：<ul>
<li>服务端渲染(<code>SSR</code>)&#x2F;静态生成(<code>SSG</code>)&#x2F;增量再生(<code>ISR</code>)自由组合</li>
<li>文件路由系统（<code>pages/about.js</code>即路由）</li>
<li>内置API路由（<code>pages/api</code>目录创建<code>Node</code>接口）</li>
</ul>
</li>
<li><strong>性能关键设计</strong>：<ul>
<li>自动代码拆分（按路由加载资源）</li>
<li>流式响应（<code>React 18 Streaming SSR</code>）</li>
<li>中间件机制（<code>middleware.ts</code>处理请求拦截）</li>
</ul>
</li>
<li><strong>开发提效</strong>：<ul>
<li>零配置<code>TypeScript</code>&#x2F;<code>SCSS</code>支持</li>
<li>图片优化组件（<code>next/image</code>自动<code>WebP</code>转换）</li>
<li>快速刷新（HMR保持组件状态）</li>
</ul>
</li>
</ol>
<p><strong>实战案例</strong>：主导跨境电商项目，商品页用<code>SSG</code>预生成，价格数据通过ISR每10分钟更新，首屏加载&lt;1s，<code>SEO</code>流量提升<code>40%</code>。使用<code>next-i18next</code>实现动态多语言，<code>next-auth</code>处理三方登录。 </p>
<p><strong>适用：</strong><code>SEO</code>敏感型<code>Web</code>应用（企业官网&#x2F;电商），不适用纯后台管理系统。</p>
<h3 id="8-什么是Bootstrap？（低）"><a href="#8-什么是Bootstrap？（低）" class="headerlink" title="8. 什么是Bootstrap？（低）"></a>8. 什么是Bootstrap？（低）</h3><p><code>Bootstrap</code> 是一个开源的前端框架，提供响应式网格系统、预置的 <code>UI</code> 组件（如按钮、表单、导航栏）及 <code>CSS/JS</code> 工具，通过类名快速构建适配多设备的网页界面，适合快速开发原型或标准化项目，但高度定制化场景需谨慎处理默认样式覆盖问题。</p>
<h2 id="hr部分"><a href="#hr部分" class="headerlink" title="hr部分"></a>hr部分</h2><h3 id="1-你对加班怎么看？（高）"><a href="#1-你对加班怎么看？（高）" class="headerlink" title="1. 你对加班怎么看？（高）"></a>1. 你对加班怎么看？（高）</h3><p>实事求是的说，是可以偶尔还是经常加班，又或是不想加班。</p>
<p>不建议说：提高个人工作效率，尽可能不加班。因为没有回答到问题核心。</p>
<p>这个需要结合行业特点，认真考虑再回答，因为既然问了这个问题，大概率至少偶尔会加班，需要有心理准备。</p>
<h3 id="2-为什么要来xx这个城市？（高）"><a href="#2-为什么要来xx这个城市？（高）" class="headerlink" title="2. 为什么要来xx这个城市？（高）"></a>2. 为什么要来xx这个城市？（高）</h3><p>其实挺简单的，我大学室友现在就在xx工作，周末经常看他发在江边骑行的朋友圈，有次视频发现他发际线居然没后移（笑），就觉得这地方可能比较适合长期发展吧。</p>
<p>具体来说：</p>
<ol>
<li><strong>生活节奏对得上</strong>——之前在深圳实习时，每天通勤3小时真的顶不住。听他说这边租房离公司骑车15分钟，晚上还能去夜市吃个炒粉，这种节奏更适合我这种需要安静写代码的人</li>
<li><strong>有熟人圈子</strong>——虽然不至于依赖朋友，但刚开始过渡期有认识的人带路，找房、办社保这些破事能少踩点坑</li>
<li><strong>工作机会实在</strong>——不像老家只有外包公司，这边有些中小厂在做挺有意思的项目，上次看到你们公司做的那个XX功能，不就是用到了Vue3的组合式API吗？正好是我最近在钻研的</li>
</ol>
<p>对了，你们团队平时会有和本地高校合作的项目吗？我之前帮学弟改过毕业设计，对带新人还挺有兴趣的。</p>
<h3 id="3-与上级意见不一时，你将怎么办？（低）"><a href="#3-与上级意见不一时，你将怎么办？（低）" class="headerlink" title="3. 与上级意见不一时，你将怎么办？（低）"></a>3. 与上级意见不一时，你将怎么办？（低）</h3><p>最核心的就是服从上级。然后私下里和上级交换意见。因为对于一个经验丰富的上级来说，你能想到的问题基本都会被考虑到。</p>
<h3 id="4-你的离职原因？（高）"><a href="#4-你的离职原因？（高）" class="headerlink" title="4. 你的离职原因？（高）"></a>4. 你的离职原因？（高）</h3><p>可以说是因为合同到期，寻求发展，提前报告后正常离职。</p>
<p>有其它正常原因也可以说，如果是公司裁员可以如实说，无需隐瞒。</p>
<h3 id="5-你有女（男）朋友吗？有的话在哪？（中）"><a href="#5-你有女（男）朋友吗？有的话在哪？（中）" class="headerlink" title="5. 你有女（男）朋友吗？有的话在哪？（中）"></a>5. 你有女（男）朋友吗？有的话在哪？（中）</h3><p>实事求是，如果是异地恋，可能有部分<code>HR</code>会介意，觉得稳定性差。</p>
<p>如果同时问是不是异地恋，说明可能会介意，可以先隐瞒，入职后如有需要再找机会公开。</p>
<h3 id="6-为什么来本公司应聘？（低）"><a href="#6-为什么来本公司应聘？（低）" class="headerlink" title="6. 为什么来本公司应聘？（低）"></a>6. 为什么来本公司应聘？（低）</h3><p>看你有没有提前了解当前应聘公司，否则可能觉得你没有“诚意”。可以从公司的背景和文化方面入手，结合岗位特点和公司发展方向稍微切入一下。</p>
<h3 id="7-你认为公司为什么要聘用你？（低）"><a href="#7-你认为公司为什么要聘用你？（低）" class="headerlink" title="7. 你认为公司为什么要聘用你？（低）"></a>7. 你认为公司为什么要聘用你？（低）</h3><p>这个问题会有很多变种，如“用几句话简述一下，让我们公司非录用你不可？”、“用几句话简述一下，让我能对你印象深刻？”、“你有什么优点？”。</p>
<p>尽可能围绕岗位要求，突出自己闪光点，比如善于沟通、为人处事、专业能力很强、曾经有过特别的贡献成就等。</p>
<p>如果实在没有什么可说，那就围绕岗位特点，提前准备某个点稍微深入一下。</p>
<p>无论如何，说的时候要自信，只要你觉得是优点就行，不用考虑其他，因为考虑也没用。</p>
<h3 id="8-你有什么缺点？（中）"><a href="#8-你有什么缺点？（中）" class="headerlink" title="8. 你有什么缺点？（中）"></a>8. 你有什么缺点？（中）</h3><p>无关紧要的（英语弱，语速快，性格耿直等），不能说和岗位相关的明显优点。</p>
<p>如果可以的话，不建议说些看似缺点，其实是夸自己的，比如说自己比较追求完美。因为既然别人想了解你的缺点，就得客观上必须是缺点，但不影响工作就行，否则问个锤子。</p>
<h3 id="9-你的业余时间喜欢做什么？（高）"><a href="#9-你的业余时间喜欢做什么？（高）" class="headerlink" title="9. 你的业余时间喜欢做什么？（高）"></a>9. 你的业余时间喜欢做什么？（高）</h3><p>实事求是，积极向上一点。最好要有点爱好，否则会被觉得太过内向，不合群。</p>
<h3 id="10-工作中遇到问题你是如何来解决的？（低）"><a href="#10-工作中遇到问题你是如何来解决的？（低）" class="headerlink" title="10. 工作中遇到问题你是如何来解决的？（低）"></a>10. 工作中遇到问题你是如何来解决的？（低）</h3><p>考验的是个人主观能动性和处理事情的逻辑性。</p>
<p>一般先自己解决，通过网络、历史遗留资料、问同事朋友等。</p>
<p>然后最重要的是，在规定时间之前自己不能完成时需要及时反馈给布置任务的人，说明目前进度，遇到的困难以及需要什么样的帮助。</p>
<h3 id="11-在工作中学习到了些什么？（低）"><a href="#11-在工作中学习到了些什么？（低）" class="headerlink" title="11. 在工作中学习到了些什么？（低）"></a>11. 在工作中学习到了些什么？（低）</h3><p>专业知识、合作、服从、沟通等。有啥说啥。</p>
<h3 id="12-你在工作中遇见最挫折的一件事？（低）"><a href="#12-你在工作中遇见最挫折的一件事？（低）" class="headerlink" title="12. 你在工作中遇见最挫折的一件事？（低）"></a>12. 你在工作中遇见最挫折的一件事？（低）</h3><p>无论自己构思还是真实发生过，重点在于不能构成严重后果的，以及从挫折中吸取的教训。</p>
<h3 id="13-你在工作中自认为最成功的一件事？（低）"><a href="#13-你在工作中自认为最成功的一件事？（低）" class="headerlink" title="13. 你在工作中自认为最成功的一件事？（低）"></a>13. 你在工作中自认为最成功的一件事？（低）</h3><p>无论自己构思还是真实发生过，重点在于需要遇到一些困难，再经过不断地努力最后才成功的。</p>
<h3 id="14-在工作中，如果你发现与你共事的同事能力不足会怎么办？（低）"><a href="#14-在工作中，如果你发现与你共事的同事能力不足会怎么办？（低）" class="headerlink" title="14. 在工作中，如果你发现与你共事的同事能力不足会怎么办？（低）"></a>14. 在工作中，如果你发现与你共事的同事能力不足会怎么办？（低）</h3><p>先私下交流，同事需要帮助后，再请示领导去帮忙。</p>
<p>不要一上去就当个老师，给同事一顿滔滔不绝。最好确认同事需要帮助后再帮忙，否则有可能吃力不讨好。</p>
<p>这里再多说一句，个人鼓励乐于分享，当然也可以稍微保留一些，慢慢的分享。每个人都尽可能的去分享，会形成良好的工作氛围。</p>
<p>总有一天，你会需要帮助的，到那时前面埋下的因，就好结出你想要的果。</p>
<h3 id="15-你希望与什么样的上级共事？（低）"><a href="#15-你希望与什么样的上级共事？（低）" class="headerlink" title="15. 你希望与什么样的上级共事？（低）"></a>15. 你希望与什么样的上级共事？（低）</h3><p>核心多要求自己，而不是要求你的上级是怎么样的。</p>
<p>如“做为刚入公司的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。”</p>
<h3 id="16-你对自己未来有什么规划？（高）"><a href="#16-你对自己未来有什么规划？（高）" class="headerlink" title="16. 你对自己未来有什么规划？（高）"></a>16. 你对自己未来有什么规划？（高）</h3><p>这个问题有两种方向，需要根据实际情况回答。</p>
<p>工作上的规划：不断积累经验，提升自我，成为某个方面能够独当一面的人。目标不要规划的太大和太长，避免眼高手低。</p>
<p>非工作上的规划：努力工作攒钱，或是贷款买房，以减少父母的负担。</p>
<h3 id="17-你比较喜欢团队合作的工作方式，还是独立作业？（低）"><a href="#17-你比较喜欢团队合作的工作方式，还是独立作业？（低）" class="headerlink" title="17. 你比较喜欢团队合作的工作方式，还是独立作业？（低）"></a>17. 你比较喜欢团队合作的工作方式，还是独立作业？（低）</h3><p>基本所有的岗位都需要团队合作。</p>
<p>如果你不喜欢团队合作，你只能成为艺术家或者完全自己雇佣自己。</p>
<h3 id="18-如果你有跟多工作要做，但是时间有限，你根本做不完全部，你该怎么办？（低）"><a href="#18-如果你有跟多工作要做，但是时间有限，你根本做不完全部，你该怎么办？（低）" class="headerlink" title="18. 如果你有跟多工作要做，但是时间有限，你根本做不完全部，你该怎么办？（低）"></a>18. 如果你有跟多工作要做，但是时间有限，你根本做不完全部，你该怎么办？（低）</h3><p>在规定的时间内，确认事情的优先级，按先后顺序尽可能全部完成，过程中如遇到问题及时反馈并请求帮助。</p>
<h3 id="19-请评价你原来的公司或上级？（低）"><a href="#19-请评价你原来的公司或上级？（低）" class="headerlink" title="19. 请评价你原来的公司或上级？（低）"></a>19. 请评价你原来的公司或上级？（低）</h3><p>尽可能的中肯客观评价，别太过分赞扬或批评。</p>
<h3 id="20-在工作中，发现自己的上司某些方面都不如你，你会怎么办？（低）"><a href="#20-在工作中，发现自己的上司某些方面都不如你，你会怎么办？（低）" class="headerlink" title="20. 在工作中，发现自己的上司某些方面都不如你，你会怎么办？（低）"></a>20. 在工作中，发现自己的上司某些方面都不如你，你会怎么办？（低）</h3><p>首先需要明白，任何做上领导位置的人，都有不为人知的能力，只是一般人不知道而已。这些能力包括但不限于专业技能、人脉资源、丰富的工作经验或是管理能力等等。</p>
<p>总之，不管什么人做我的上司，只要我还接受这份工作，我都将摆正自己的位置，做好自己的事情。</p>
<p>多说一句，如果你觉得你的上司确实不如你，那还得先好好工作，争取有一天取代。而不是整天想七想八的，工作没有任何的表现，其它的都是扯淡。</p>
<h3 id="21-你什么时候可以来上班？（高）"><a href="#21-你什么时候可以来上班？（高）" class="headerlink" title="21. 你什么时候可以来上班？（高）"></a>21. 你什么时候可以来上班？（高）</h3><p>最合适的回答就是按公司规定时间上班。</p>
<p>但如果还有一些私人的问题还没有处理完毕，按时上班会有些困难，需要说明原因，一般都会通融的。</p>
<h3 id="22-你还有什么问题吗？（高）"><a href="#22-你还有什么问题吗？（高）" class="headerlink" title="22. 你还有什么问题吗？（高）"></a>22. 你还有什么问题吗？（高）</h3><p>最好有一些问题，如问对新员工有没有组织培训、工作时间等。</p>
<p>实在没有的话，就说您刚才已经介绍的非常清楚了谢谢。</p>
<h3 id="23-总结"><a href="#23-总结" class="headerlink" title="23. 总结"></a>23. 总结</h3><p>最后总结一下，面试的时候，一定需要提前多做准备，在面试的时候需要足够<strong>自信</strong>，只有足够自信，别人才有可能相信。甚至要做到“我觉得，而不是别人觉得”这种舍我其谁的气势。</p>
<p>在碰到陌生的问题，尽可能回答，不要太多冷场。无论结果怎么样，不用去过多猜测面试的结果，因为你永远猜不到被录取的原因可能就是那么简单。</p>
<p>如果等候通知超过约定时间，同时你又对这个公司很有兴趣，就联系对方主动询问即可。</p>
<p>最关键的就是，每次面试后需要不断分析和总结，逐渐完善，机会总是留给有所准备的人</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ningxiu2978.github.io">NINGXIU</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ningxiu2978.github.io/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/">https://ningxiu2978.github.io/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ningxiu2978.github.io" target="_blank">NINGXIU's 学习博客</a>！</span></div></div><div class="tag_share"></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/19/Git%E4%BD%9C%E4%B8%9A_0915/" title="Git作业_0915"><img class="cover" src="/images/default_cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git作业_0915</div></div><div class="info-2"><div class="info-item-1">9月15作业-git基础题目中部分涉及未讲的知识点，以做题代学，自己可以查资料理解一下，明天会讲解 一、单选题 在Git中，执行 git status 后，若文件显示为 “Untracked files”，表示该文件处于什么状态？CA. 已修改但未暂存B. 已暂存但未提交C. 新文件，未被Git跟踪D. 已提交到本地仓库解释：Untracked files 表示文件是新建的，尚未被Git跟踪（未执行过 git add）。  执行 git add命令的主要作用是？CA. 将文件从本地仓库删除B. 将文件的修改提交到远程仓库C. 将文件的当前改动添加到暂存区（Stage&#x2F;Index）D. 查看文件的具体修改内容解释：    A：已修改但未暂存 → 对应状态是 Changes not staged for commit B：已暂存但未提交 → 对应状态是 Changes to be committed D：已提交 → 文件会从状态列表中消失   以下哪个命令可以查看当前仓库的所有提交历史记录（包括提交哈希、作者、时间等基本信息）？AA. git logB. git diffC...</div></div></div></a><a class="pagination-related" href="/2025/09/19/GIT%E5%9F%BA%E7%A1%80_/" title="GIT基础"><img class="cover" src="/images/default_cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">GIT基础</div></div><div class="info-2"><div class="info-item-1">GIT基础版本控制系统git分布式版本控制系统 git诞生  git是由Linus Torvalds（林纳斯），也就是Linux之父，为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件  林纳斯 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper    应用场景  写论文或小说  开发软件项目  法律协议起草    为什么要用版本控制系统？  可撤销还原  多人协作  在线开源共享     svn集中式版本控制系统 缺点：   必须联网才能工作 中央服务器出问题了，就没法工作 分支速度慢  git和svn的区别 1.Git 是分布式的，SVN集中式2.Git 把内容按元数据方式存储，而 SVN 是按文件3.Git 分支和 SVN 的分支不同4.Git 没有一个全局的版本号，而 SVN 有5.Git 的内容完整性要优于 SVN  集中式  分布式   Git 与 GitHub 区别  Git和Github是两个完全不同的概念     Git是分布式版本控制系统 GitHub是开源代码托管网站  git安装官网下载安装 https://git-scm...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">NINGXIU</div><div class="author-info-description">天生我材必有用，千金散尽还复来。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NingXIU2978"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/NingXIU2978" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/georgelester10611@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客,欢迎各位大佬莅临！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8"><span class="toc-number">1.</span> <span class="toc-text">Web前端面试宝典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#resume%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">resume部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 自我介绍一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%BA%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 自我介绍二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 自我介绍三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%9B%9B"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 自我介绍四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%BA%94"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 自我介绍五</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%85%AD"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.  自我介绍六</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%83"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. 自我介绍七</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%85%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">8. 自我介绍八</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B9%9D"><span class="toc-number">1.1.9.</span> <span class="toc-text">9. 自我介绍九</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8D%81"><span class="toc-number">1.1.10.</span> <span class="toc-text">10. 自我介绍十</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8D%81%E4%B8%80"><span class="toc-number">1.1.11.</span> <span class="toc-text">11. 自我介绍十一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8D%81%E4%BA%8C"><span class="toc-number">1.1.12.</span> <span class="toc-text">12. 自我介绍十二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E9%83%A8%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">git部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93%E5%B9%B6%E6%8F%90%E4%BA%A4%E7%89%88%E6%9C%AC%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 如何创建git仓库并提交版本？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.如何解决合并冲突？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E8%BF%98%E5%8E%9F%E5%88%B0%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 如何恢复还原到上一个版本？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%B0%E8%BF%9C%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 请介绍推送本地仓库到远程的过程？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B7%E4%BB%8B%E7%BB%8Dgit%E5%A4%9A%E4%BA%BA%E8%BF%9C%E7%A8%8B%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 请介绍git多人远程协作的流程？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-git-%E5%92%8C-svn%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. git 和 svn的区别？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-git-rebase-%E5%92%8C-git-merge%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.  git rebase 和 git merge的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BA%A4%E7%89%88%E6%9C%AC%E4%BA%A7%E7%94%9F%E5%86%B2%E7%AA%81%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">8. 如何解决提交版本产生冲突？（ 高 ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html%E9%83%A8%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">html部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html5%E6%96%B0%E5%A2%9E%E4%BB%80%E4%B9%88%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. html5新增什么新特性？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%BC%95%E6%93%8E%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 主流浏览器以及引擎有那些？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SEO%E4%BC%98%E5%8C%96%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. SEO优化有那些方面？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9D%97%E7%BA%A7%E3%80%81%E8%A1%8C%E7%BA%A7%E5%92%8C%E8%A1%8C%E5%9D%97%E7%BA%A7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 块级、行级和行块级的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BFC%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. BFC是什么有什么用？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 语义化有什么用？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-html5%E6%96%B0%E5%A2%9E%E4%BB%80%E4%B9%88%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. html5新增什么语义化标签？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9D%97%E7%BA%A7%E3%80%81%E8%A1%8C%E7%BA%A7%E5%92%8C%E8%A1%8C%E5%9D%97%E7%BA%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">8. 块级、行级和行块级有哪些？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.3.9.</span> <span class="toc-text">9. 从输入URL到显示页面经历了什么？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-title%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.10.</span> <span class="toc-text">10. title与alt属性的区别是什么？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.3.11.</span> <span class="toc-text">11. get和post的区别是？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-canvas-%E5%92%8C-svg%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.12.</span> <span class="toc-text">12. canvas 和 svg的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-jpg%E3%80%81png%E3%80%81gif%E3%80%81svg%E5%92%8Cwebp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.3.13.</span> <span class="toc-text">13. jpg、png、gif、svg和webp的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%A1%8C%E5%9D%97%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E9%97%B4%E9%9A%99%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.14.</span> <span class="toc-text">14. 行块之间存在间隙，是什么造成的？如何解决？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%8BSEO%E4%B8%AD%E7%9A%84TDK%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.3.15.</span> <span class="toc-text">15. 请描述下SEO中的TDK？（ 中 ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%83%A8%E5%88%86"><span class="toc-number">1.4.</span> <span class="toc-text">css部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%9F%E5%AE%83%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 什么是盒子模型？它的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CSS%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. CSS有哪些选择器？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CSS%E7%9A%84%E6%9D%83%E9%87%8D%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. CSS的权重优先级是什么？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-px%E3%80%81em%E5%92%8Crem%E5%8D%95%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. px、em和rem单位的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9B%B8%E5%AF%B9%E3%80%81%E7%BB%9D%E5%AF%B9%E5%92%8C%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 相对、绝对和固定定位的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.4.6.</span> <span class="toc-text">6. CSS3的新特性有哪些？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.7.</span> <span class="toc-text">7. 用代码画三角形有几种方式？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B7%A6%E8%BE%B9%E5%9B%BA%E5%AE%9A200px%EF%BC%8C%E5%8F%B3%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95-%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.8.</span> <span class="toc-text">8. 左边固定200px，右边自适应，有几种方法?（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9D%97%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.9.</span> <span class="toc-text">9. 块水平垂直居中有多少种方法？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.4.10.</span> <span class="toc-text">10. 伪类和伪元素有哪些？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F%E5%93%AA%E4%BA%9B%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.11.</span> <span class="toc-text">11. 哪些属性可以继承？哪些不能继承？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-rem%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.4.12.</span> <span class="toc-text">12. rem自适应布局？如何实现？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-transition%E5%92%8Canimation%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.13.</span> <span class="toc-text">13. transition和animation动画的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8less%E6%88%96%E8%80%85scss%E5%90%97%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.14.</span> <span class="toc-text">14. 项目中使用less或者scss吗？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCSS-Sprites%EF%BC%88%E9%9B%AA%E7%A2%A7%E5%9B%BE%EF%BC%89%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.15.</span> <span class="toc-text">15. 介绍一下CSS Sprites（雪碧图）？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.16.</span> <span class="toc-text">16. 谈谈你对弹性布局的理解？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E4%B8%BB%E8%BD%B4%E5%92%8C%E4%BA%A4%E5%8F%89%E8%BD%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.17.</span> <span class="toc-text">17. 弹性布局主轴和交叉轴的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.4.18.</span> <span class="toc-text">18. 弹性布局的实现水平垂直居中？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%8D%95%E8%A1%8C%E7%9C%81%E7%95%A5%E5%92%8C%E5%A4%9A%E8%A1%8C%E7%9C%81%E7%95%A5%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.19.</span> <span class="toc-text">19. 单行省略和多行省略？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-rgba-%E5%92%8C-opacity-%E8%AE%BE%E7%BD%AE%E9%80%8F%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.4.20.</span> <span class="toc-text">20. rgba 和 opacity 设置透明的区别？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%8E%E4%B9%88%E5%BC%80%E5%8F%91%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.4.21.</span> <span class="toc-text">21. 移动端怎么开发？（ 中 ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es5%E9%83%A8%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">es5部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JS%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. JS有哪些数据类型？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 堆和栈的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-typeof%E8%83%BD%E6%A3%80%E6%B5%8B%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. typeof能检测哪些类型？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JS%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. JS检测数据类型有哪些方式？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 检测数组和对象有几种方式？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 谈谈你对闭包的理解？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 闭包的应用有哪些？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.8.</span> <span class="toc-text">8. 谈谈你对原型对象、原型链的理解？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-JS%E5%BC%BA%E5%88%B6%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.9.</span> <span class="toc-text">9. JS强制和隐式类型转换？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.10.</span> <span class="toc-text">10. JS的事件机制是什么？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-JS%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.11.</span> <span class="toc-text">11. JS事件代理的原理？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-0-1-0-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89-0-3-%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.12.</span> <span class="toc-text">12. 0.1 + 0.2 为什么不等 0.3 ？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-call%E3%80%81bind%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.13.</span> <span class="toc-text">13. call、bind和apply的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-this%E6%9C%89%E5%87%A0%E7%A7%8D%E6%8C%87%E5%90%91%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.14.</span> <span class="toc-text">14. this有几种指向？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-localStorage%E3%80%81sessionStorage%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.15.</span> <span class="toc-text">15. localStorage、sessionStorage和cookie的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E5%8A%A8%E4%BD%9C%E5%92%8C%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.16.</span> <span class="toc-text">16. 阻止默认动作和阻止冒泡是什么？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%9C%89%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.17.</span> <span class="toc-text">17. 前端性能有优化有哪些？ （ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-http%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.18.</span> <span class="toc-text">18. http状态码有哪些？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.19.</span> <span class="toc-text">19. JS浅拷贝和深拷贝？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-new%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.20.</span> <span class="toc-text">20. new关键字做了什么？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-ajax%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.21.</span> <span class="toc-text">21. ajax的原理是什么？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.22.</span> <span class="toc-text">22. 同步和异步的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%B7%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.23.</span> <span class="toc-text">23. 跨域有几种方式？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-web%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.24.</span> <span class="toc-text">24. web安全防护有几种？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-es5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.25.</span> <span class="toc-text">25. es5如何实现继承？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E6%95%B0%E7%BB%84find%E5%92%8Cfilter%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.26.</span> <span class="toc-text">26.  数组find和filter的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E6%95%B0%E7%BB%84slice%E5%92%8Csplice%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.27.</span> <span class="toc-text">27. 数组slice和splice的区别？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%95%B0%E7%BB%84reduce%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.28.</span> <span class="toc-text">28. 数组reduce干什么？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-substr%E5%92%8Cslice%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.29.</span> <span class="toc-text">29. substr和slice方法的区别？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.30.</span> <span class="toc-text">30. 什么宏任务和微任务？执行顺序是什么？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BB%80%E4%B9%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.31.</span> <span class="toc-text">31. 什么事件循环？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-setTimeout%E8%83%BD%E4%BF%9D%E8%AF%81%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%87%86%E7%A1%AE%E5%90%97%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.32.</span> <span class="toc-text">32. setTimeout能保证执行时间准确吗？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.33.</span> <span class="toc-text">33. 什么是柯里化函数？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.34.</span> <span class="toc-text">34. 创建、删除、复制、替换、插入和查找节点？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-JS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.35.</span> <span class="toc-text">35. JS异步加载有哪些？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85axios%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.36.</span> <span class="toc-text">36. 如何封装axios？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-get%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E6%98%AF%E6%9C%89%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AE%83%E4%B8%8D%E7%BC%93%E5%AD%98%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.37.</span> <span class="toc-text">37. get请求默认是有缓存的，如何让它不缓存？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E8%B0%88%E8%B0%88js%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.38.</span> <span class="toc-text">38. 谈谈js的单例模式？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E8%B0%88%E8%B0%88js%E7%9A%84%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.39.</span> <span class="toc-text">39. 谈谈js的订阅发布者模式？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.5.40.</span> <span class="toc-text">40. 函数防抖节流的原理？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-HTTP-%E4%B8%8E-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.41.</span> <span class="toc-text">41. HTTP 与 HTTPS 的区别？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E7%BD%91%E7%BB%9C7%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.5.42.</span> <span class="toc-text">42. 网络7层架构？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.43.</span> <span class="toc-text">43. TCP与UDP的区别？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%BB%80%E4%B9%88%E6%98%AFA%E7%B1%BB%E5%9C%B0%E5%9D%80%E5%92%8CB%E7%B1%BB%E5%9C%B0%E5%9D%80%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.5.44.</span> <span class="toc-text">44. 什么是A类地址和B类地址？（ 低 ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es6%E9%83%A8%E5%88%86"><span class="toc-number">1.6.</span> <span class="toc-text">es6部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 箭头函数和普通函数的区别？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-es6%E6%96%B0%E5%A2%9E%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. es6新增什么特性？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88-%E9%AB%98-%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 谈谈你对promise的理解？（ 高 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-async-await%E5%92%8Cpromise%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. async&amp;await和promise有什么关系？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-async%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. async会阻塞吗？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-async%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88-%E4%BD%8E-%EF%BC%89"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. async函数的工作原理？（ 低 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-async%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. async函数如何捕获错误？（ 中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%87%A0%E7%A7%8D%E5%8A%9E%E6%B3%95%EF%BC%9F%EF%BC%88-%E4%B8%AD-%EF%BC%89"><span class="toc-number">1.6.8.</span> <span class="toc-text">8. JS数组去重有几种办法？（ 中 ）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%83%A8%E5%88%86"><span class="toc-number">1.7.</span> <span class="toc-text">vue部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. vue的生命周期有哪些？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-vue2-0%E5%92%8Cvue3-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. vue2.0和vue3.0有什么区别?（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-vue%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9F%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. vue的优点？核心思想？（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E8%AE%AF%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. vue组件之间有哪些通讯？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. v-show和v-if的区别？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-key%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. key的作用？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8E%A8%E8%8D%90%E7%94%A8%E7%B4%A2%E5%BC%95%E5%80%BC%E4%BD%9C%E4%B8%BAkey%E5%90%97%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. 推荐用索引值作为key吗？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E6%8E%A8%E8%8D%90%E5%86%99%E5%90%8C%E8%A1%8C%E5%90%97%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.8.</span> <span class="toc-text">8. v-if和v-for的优先级？推荐写同行吗？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.9.</span> <span class="toc-text">9.  双向绑定的原理？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-vue%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.10.</span> <span class="toc-text">10. vue常见的指令有哪些？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88-%E4%BD%8E%EF%BC%89"><span class="toc-number">1.7.11.</span> <span class="toc-text">11. diff算法的原理？（ 低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88MVVM%E6%80%9D%E6%83%B3%EF%BC%9F%EF%BC%88-%E4%BD%8E%EF%BC%89"><span class="toc-number">1.7.12.</span> <span class="toc-text">12. 什么MVVM思想？（ 低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88data%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.13.</span> <span class="toc-text">13. 为什么data是一个函数?（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91vue%E7%BB%84%E4%BB%B6%EF%BC%9F%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.14.</span> <span class="toc-text">14. 如何开发vue组件？（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-vue%E6%8F%92%E6%A7%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.15.</span> <span class="toc-text">15. vue插槽有哪些？（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.16.</span> <span class="toc-text">16. 计算属性和方法的区别？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.17.</span> <span class="toc-text">17. 计算属性和侦听器的区别？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.18.</span> <span class="toc-text">18. 如何设置深度监听和立即执行？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-setTimeout%E5%92%8CnextTick%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.19.</span> <span class="toc-text">19. setTimeout和nextTick的区别？（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-ref%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88-%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.20.</span> <span class="toc-text">20. ref的作用？（ 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-style%E4%B8%8Ascope%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.21.</span> <span class="toc-text">21. style上scope属性有什么用？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%B7%AF%E7%94%B1%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.22.</span> <span class="toc-text">22. 路由有几种传参方式？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-query%E5%92%8Cparams%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.23.</span> <span class="toc-text">23. query和params的区别？（ 高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88-%E4%BD%8E%EF%BC%89"><span class="toc-number">1.7.24.</span> <span class="toc-text">24. hash和history模式的区别？（ 低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F%E4%BD%A0%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.25.</span> <span class="toc-text">25. 路由守卫有那些？你用过吗？做过什么？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A6%96%E5%B1%8F%E6%89%93%E5%BC%80%E6%98%AF%E7%99%BD%E5%B1%8F%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.26.</span> <span class="toc-text">26. 如何解决首屏打开是白屏？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.27.</span> <span class="toc-text">27. 路由导航有几种方式？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-push-%E5%92%8Creplace%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.7.28.</span> <span class="toc-text">28. push 和replace跳转的区别？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.29.</span> <span class="toc-text">29. vuex是什么？作用和缺点？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-vuex%E5%87%A0%E5%A4%A7%E6%A0%B8%E5%BF%83%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.30.</span> <span class="toc-text">30. vuex几大核心？分别介绍一下？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-pinia%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E7%82%B9%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.7.31.</span> <span class="toc-text">31. pinia是什么？有什么作用和优点？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-vuex%E6%88%96pinia%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.7.32.</span> <span class="toc-text">32. vuex或pinia如何实现持久化存储？（中）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project%E9%83%A8%E5%88%86"><span class="toc-number">1.8.</span> <span class="toc-text">project部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%A0%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 你做过什么项目？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%81%9A%E7%9A%84%EF%BC%9F%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BA%BA%E8%B4%9F%E8%B4%A3%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 项目什么时候做的？有多少人负责？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 项目用了什么技术栈？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A1%B9%E7%9B%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F%E4%BD%A0%E8%B4%9F%E8%B4%A3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 项目有什么功能？你负责了哪些功能？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. 项目遇到了什么问题？你是如何解决的？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%9C%80%E9%9A%BE%E7%9A%84%E6%88%96%E8%80%85%E8%AF%B4%E4%BD%A0%E5%8D%B0%E8%B1%A1%E6%9C%80%E6%B7%B1%E7%9A%84%E6%98%AF%E9%82%A3%E4%B8%AA%E5%8A%9F%E8%83%BD%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.6.</span> <span class="toc-text">6. 这个项目最难的或者说你印象最深的是那个功能？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B9%B3%E6%97%B6%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.7.</span> <span class="toc-text">7. 平时遇到问题怎么解决？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B9%B3%E6%97%B6%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.8.</span> <span class="toc-text">8. 平时怎么学习？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%8F%A3%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.9.</span> <span class="toc-text">9. 前端和后端如何交互？如何对接口？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B9%B3%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5%E7%9A%84%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.8.10.</span> <span class="toc-text">10. 平时是如何和后端对接的？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.11.</span> <span class="toc-text">11. 项目如何优化？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.8.12.</span> <span class="toc-text">12. 从项目中获得了什么？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BD%A0%E8%A7%89%E5%BE%97%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.8.13.</span> <span class="toc-text">13. 你觉得这个项目有什么可以改进的地方？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.8.14.</span> <span class="toc-text">14. 项目中遇到的坑有哪些？你是如何解决的？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BD%A0%E8%A7%89%E5%BE%97%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%88%86%E4%BA%AB%E7%9A%84%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.8.15.</span> <span class="toc-text">15. 你觉得这个项目有什么可以分享的？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.16.</span> <span class="toc-text">16.  图片懒加载实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.17.</span> <span class="toc-text">17. 购物车实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%A2%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.18.</span> <span class="toc-text">18. 订单实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%94%AF%E4%BB%98%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.19.</span> <span class="toc-text">19. 支付实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%BD%AE%E6%92%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.20.</span> <span class="toc-text">20. 轮播实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.21.</span> <span class="toc-text">21. 角色权限管理实现的原理？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BD%A0%E5%B0%81%E8%A3%85%E8%BF%87%E5%93%AA%E4%BA%9B%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E5%90%97%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.22.</span> <span class="toc-text">22. 你封装过哪些业务组件吗？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AFUI%E6%A1%86%E6%9E%B6%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.8.23.</span> <span class="toc-text">23. 说下你知道的前端UI框架？（中）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other%E9%83%A8%E5%88%86"><span class="toc-number">1.9.</span> <span class="toc-text">other部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-react%E5%AD%A6%E8%BF%87%E5%90%97%EF%BC%9F%E5%AD%A6%E8%BF%87%E7%89%88%E6%9C%AC%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. react学过吗？学过版本（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-react%E5%AD%A6%E8%BF%87%E5%90%97%EF%BC%9F%E6%B2%A1%E5%AD%A6%E8%BF%87%E7%89%88%E6%9C%AC%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. react学过吗？没学过版本（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%9A%E5%90%97%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. 小程序会吗，谈谈你对它的理解？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-uni-app%E4%BC%9A%E5%90%97%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.4.</span> <span class="toc-text">4. uni-app会吗，谈谈你对它的理解？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-react-native%E4%BC%9A%E5%90%97%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.5.</span> <span class="toc-text">5. react-native会吗，谈谈你对它的理解？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-flutter%E4%BC%9A%E5%90%97%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.6.</span> <span class="toc-text">6. flutter会吗，谈谈你对它的理解？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-nextjs%E4%BC%9A%E5%90%97%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.7.</span> <span class="toc-text">7. nextjs会吗，谈谈你对它的理解？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AFBootstrap%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.9.8.</span> <span class="toc-text">8. 什么是Bootstrap？（低）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hr%E9%83%A8%E5%88%86"><span class="toc-number">1.10.</span> <span class="toc-text">hr部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%A0%E5%AF%B9%E5%8A%A0%E7%8F%AD%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. 你对加班怎么看？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9D%A5xx%E8%BF%99%E4%B8%AA%E5%9F%8E%E5%B8%82%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">2. 为什么要来xx这个城市？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8E%E4%B8%8A%E7%BA%A7%E6%84%8F%E8%A7%81%E4%B8%8D%E4%B8%80%E6%97%B6%EF%BC%8C%E4%BD%A0%E5%B0%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">3. 与上级意见不一时，你将怎么办？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%A0%E7%9A%84%E7%A6%BB%E8%81%8C%E5%8E%9F%E5%9B%A0%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.4.</span> <span class="toc-text">4. 你的离职原因？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%A0%E6%9C%89%E5%A5%B3%EF%BC%88%E7%94%B7%EF%BC%89%E6%9C%8B%E5%8F%8B%E5%90%97%EF%BC%9F%E6%9C%89%E7%9A%84%E8%AF%9D%E5%9C%A8%E5%93%AA%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.10.5.</span> <span class="toc-text">5. 你有女（男）朋友吗？有的话在哪？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9D%A5%E6%9C%AC%E5%85%AC%E5%8F%B8%E5%BA%94%E8%81%98%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.6.</span> <span class="toc-text">6. 为什么来本公司应聘？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BD%A0%E8%AE%A4%E4%B8%BA%E5%85%AC%E5%8F%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%81%98%E7%94%A8%E4%BD%A0%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.7.</span> <span class="toc-text">7. 你认为公司为什么要聘用你？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">1.10.8.</span> <span class="toc-text">8. 你有什么缺点？（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BD%A0%E7%9A%84%E4%B8%9A%E4%BD%99%E6%97%B6%E9%97%B4%E5%96%9C%E6%AC%A2%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.9.</span> <span class="toc-text">9. 你的业余时间喜欢做什么？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.10.</span> <span class="toc-text">10. 工作中遇到问题你是如何来解决的？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.11.</span> <span class="toc-text">11. 在工作中学习到了些什么？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E8%A7%81%E6%9C%80%E6%8C%AB%E6%8A%98%E7%9A%84%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.12.</span> <span class="toc-text">12. 你在工作中遇见最挫折的一件事？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%87%AA%E8%AE%A4%E4%B8%BA%E6%9C%80%E6%88%90%E5%8A%9F%E7%9A%84%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.13.</span> <span class="toc-text">13. 你在工作中自认为最成功的一件事？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%8F%91%E7%8E%B0%E4%B8%8E%E4%BD%A0%E5%85%B1%E4%BA%8B%E7%9A%84%E5%90%8C%E4%BA%8B%E8%83%BD%E5%8A%9B%E4%B8%8D%E8%B6%B3%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.14.</span> <span class="toc-text">14. 在工作中，如果你发现与你共事的同事能力不足会怎么办？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BD%A0%E5%B8%8C%E6%9C%9B%E4%B8%8E%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%B8%8A%E7%BA%A7%E5%85%B1%E4%BA%8B%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.15.</span> <span class="toc-text">15. 你希望与什么样的上级共事？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BD%A0%E5%AF%B9%E8%87%AA%E5%B7%B1%E6%9C%AA%E6%9D%A5%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%92%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.16.</span> <span class="toc-text">16. 你对自己未来有什么规划？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BD%A0%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%98%AF%E7%8B%AC%E7%AB%8B%E4%BD%9C%E4%B8%9A%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.17.</span> <span class="toc-text">17. 你比较喜欢团队合作的工作方式，还是独立作业？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E8%B7%9F%E5%A4%9A%E5%B7%A5%E4%BD%9C%E8%A6%81%E5%81%9A%EF%BC%8C%E4%BD%86%E6%98%AF%E6%97%B6%E9%97%B4%E6%9C%89%E9%99%90%EF%BC%8C%E4%BD%A0%E6%A0%B9%E6%9C%AC%E5%81%9A%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%83%A8%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.18.</span> <span class="toc-text">18. 如果你有跟多工作要做，但是时间有限，你根本做不完全部，你该怎么办？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%AF%B7%E8%AF%84%E4%BB%B7%E4%BD%A0%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%85%AC%E5%8F%B8%E6%88%96%E4%B8%8A%E7%BA%A7%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.19.</span> <span class="toc-text">19. 请评价你原来的公司或上级？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%EF%BC%8C%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%8A%E5%8F%B8%E6%9F%90%E4%BA%9B%E6%96%B9%E9%9D%A2%E9%83%BD%E4%B8%8D%E5%A6%82%E4%BD%A0%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%EF%BC%88%E4%BD%8E%EF%BC%89"><span class="toc-number">1.10.20.</span> <span class="toc-text">20. 在工作中，发现自己的上司某些方面都不如你，你会怎么办？（低）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BD%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E6%9D%A5%E4%B8%8A%E7%8F%AD%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.21.</span> <span class="toc-text">21. 你什么时候可以来上班？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BD%A0%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F%EF%BC%88%E9%AB%98%EF%BC%89"><span class="toc-number">1.10.22.</span> <span class="toc-text">22. 你还有什么问题吗？（高）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.23.</span> <span class="toc-text">23. 总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/Git%E5%91%A8%E8%80%83%E5%A4%9A%E9%80%89&amp;%E7%AE%80%E7%AD%94_0919/" title="Git周考多选&amp;简答_0919"><img src="/images/default_cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git周考多选&amp;简答_0919"/></a><div class="content"><a class="title" href="/2025/09/19/Git%E5%91%A8%E8%80%83%E5%A4%9A%E9%80%89&amp;%E7%AE%80%E7%AD%94_0919/" title="Git周考多选&amp;简答_0919">Git周考多选&amp;简答_0919</a><time datetime="2025-09-19T09:12:12.093Z" title="发表于 2025-09-19 17:12:12">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/Git%E4%BD%9C%E4%B8%9A_0915/" title="Git作业_0915"><img src="/images/default_cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git作业_0915"/></a><div class="content"><a class="title" href="/2025/09/19/Git%E4%BD%9C%E4%B8%9A_0915/" title="Git作业_0915">Git作业_0915</a><time datetime="2025-09-19T07:58:53.222Z" title="发表于 2025-09-19 15:58:53">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/" title="Web前端面试宝典"><img src="/images/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web前端面试宝典"/></a><div class="content"><a class="title" href="/2025/09/19/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90%E7%94%B5%E5%AD%90%E7%89%88%E3%80%91/" title="Web前端面试宝典">Web前端面试宝典</a><time datetime="2025-09-19T07:52:37.333Z" title="发表于 2025-09-19 15:52:37">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/GIT%E5%9F%BA%E7%A1%80_/" title="GIT基础"><img src="/images/default_cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GIT基础"/></a><div class="content"><a class="title" href="/2025/09/19/GIT%E5%9F%BA%E7%A1%80_/" title="GIT基础">GIT基础</a><time datetime="2025-09-19T06:55:30.645Z" title="发表于 2025-09-19 14:55:30">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E5%8D%9A%E5%AE%A2%E6%9E%B6%E6%9E%84/" title="博客架构全景 (One-Page Cheatsheet)"><img src="/images/default_cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客架构全景 (One-Page Cheatsheet)"/></a><div class="content"><a class="title" href="/2025/09/19/%E5%8D%9A%E5%AE%A2%E6%9E%B6%E6%9E%84/" title="博客架构全景 (One-Page Cheatsheet)">博客架构全景 (One-Page Cheatsheet)</a><time datetime="2025-09-18T16:00:00.000Z" title="发表于 2025-09-19 00:00:00">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By NINGXIU</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>