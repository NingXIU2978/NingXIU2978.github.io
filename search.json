[{"url":"/2025/09/18/README/","content":"Git学习介绍专注于Git基础与进阶学习的开源仓库，提供实战教程、案例分析，助您快速掌握版本控制精髓。\n软件架构软件架构说明\n安装教程\nxxxx\nxxxx\nxxxx\n\n使用说明\nxxxx\nxxxx\nxxxx\n\n参与贡献\nFork 本仓库\n新建 Feat_xxx 分支\n提交代码\n新建 Pull Request\n\n特技\n使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md\nGitee 官方博客 blog.gitee.com\n你可以 https://gitee.com/explore 这个地址来了解 Gitee 上的优秀开源项目\nGVP 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目\nGitee 官方提供的使用手册 https://gitee.com/help\nGitee 封面人物是一档用来展示 Gitee 会员风采的栏目 https://gitee.com/gitee-stars/\n\n"},{"title":"git笔记_0915","url":"/2025/09/18/git%E7%AC%94%E8%AE%B0_0915/","content":" \n 注意：避免在 仓库 创建 仓库项目（套娃） \n修改分支名：\ngit config –global init.defaultBranch master\ngit config –global init.defaultBranch main \n删除.git文件夹后更新 仓库 gti inir 成功\n \n第一步：配置用户名\ngit config --global user.name &quot;shuning&quot; \n\n第二步：配置邮箱\ngit config --global user.email &quot;sn2978@foxmail.com&quot;\n\n第三步：配置git打开的编辑器\ngit config\n# 设置编辑器为记事本，默认是linux的VIM编辑器，注意你确认您的记事本在C盘路径下git config --global core.editor &quot;C:/Windows/notepad.exe&quot;\n\n \ngit clonegit clone git@gitee.com:vant-contrib&#x2F;vant.git\n冲突可以在后面取别名\n\n先配置SSH公钥\n \n \ngit add \ngit commit提交版本\ngit commit -m “描述”\n \n注意：必须先提交到暂存add，之后提交commit\nGit 如何初始化并提交仓库？\n检查是否已初始化：查看是否存在 .git 文件夹。  \n\n有 → 可直接使用 Git 命令管理；  \n无 → 需执行 git init 初始化仓库。\n\n\n添加文件到暂存区：使用 git add &lt;文件名&gt; 或 git add . 添加所有文件。\n\n提交到本地仓库：使用 git commit -m &quot;提交描述&quot; 提交修改。\n\n（可选）关联远程仓库并推送：git remote add origin &lt;远程地址&gt;git push -u origin &lt;分支名&gt;\n\n\n📌 核心命令三步走：git init → git add . → git commit -m &quot;xxx&quot;\n \n \n","tags":["Git#文章标签"]},{"title":"作业_0916","url":"/2025/09/18/%E4%BD%9C%E4%B8%9A_0916/","content":"一、主观题\ngit stash 练习，练习步骤\n\n \n1.创建并克隆仓库：\n \n \n2.本地修改1.txt文件\n  \n3.远程修改1.txt文件，并提交版本\n  \n4.执行git pull 报错 （因本地有未提交修改，与远程冲突）\n \n5.执行git stash存储工作区修改，使用git stash list查看存储栈\n  \n6.执行git pull 拉取远程最新版本（此时本地无修改，可顺利合并）\n \n7.使用git stash pop 恢复之前暂存的修改（自动尝试合并，若冲突需手动解决）\n  \n8.手动编辑冲突文件，解决冲突后执行 git add -A 标记为已解决\n \n9.提交合并结果并上传远程仓库 git push\n \n2.     git show有什么作用？git show 命令用于显示 Git 仓库中对象（如提交 commit、标签 tag、文件 blob 等）的详细信息。默认显示最近一次提交的元数据和变更内容。\n是查看历史变更和对象内容的核心命令。\n3.     git blame 有什么作用？git blame 用于逐行显示文件中每行代码的最后修改者、提交哈希、修改时间和具体内容，帮助追踪代码变更历史和责任归属。\n运行 git blame &lt;文件路径&gt; 可直观看到每行的“责任人”和修改上下文。\n对代码审查、Bug 追溯、交接维护非常有用。\n4.     再练习一遍撤销还原操作4.1 工作区撤销（丢弃工作区未暂存的修改）\n\n\n在工作区修改了文件\n\n使用git status 查看那些文件被修改了\n \n\n使用以下任一命令丢弃修改，恢复到最近一次提交的状态：\n使用git checkout – 被恢复的文件\n\n\ngit statusgit checkout -- readme.txt// 或者git restore readme.txt\n \n \n4.2  暂存盘软撤销（取消暂存，保留工作区内容）\n\n\n在工作区修改文件\n使用 git add 添加到暂存区\n使用 git status 查看状态\n取消暂存（但保留工作区内容）：\n\n方法1（传统）：\ngit statusgit reset HEAD readme.txt\t# 取消暂存git checkout -- readme.txt\t# 丢弃工作区修改（可选）\n\n方法2（推荐，Git 2.23+）:\ngit restore --staged readme.txt\t\t# 取消暂存git restore readme.txt\t\t\t# 丢弃工作区修改（可选）\n\n注意：先修改一下文件，然后使用git add 将修改过后的文件添加到暂存盘，然后做上面的练习\n\n1.工作区修改文件，添加至暂存区：\n \n2.使用git status查看查看状态：\n\n使用 git reset HEAD 文件名 取消暂存 + git checkout -- 文件名 丢弃修改：\n  \n4.3  暂存盘硬撤销（恢复修改前的工作区内容）（取消暂存并丢弃工作区修改）\n将被修改了文件添加到暂存盘# 假设文件已修改并 add 到暂存区git restore --staged 1.txt\t# 取消暂存git restore 1.txt\t\t# 丢弃工作区所有修改，恢复到 HEAD 状态\n\n \n4.2  版本软回滚（保留工作区和暂存区内容，仅移动 HEAD）\n git reset –soft 短版本号\n 目标：回滚到 22222 提交（3bfdc42），但保留当前 1.txt 的所有内容（包括 33333）\ngit reset --soft 3bfdc42\n\n此时提交历史回到 3bfdc42，但工作区和暂存区保持不变，可重新 commit。\n \n4.3  版本硬回滚（工作区内容也恢复）（工作区、暂存区、HEAD 全部回退）\n git reset –hard 短版本号\n目标：彻底回滚到 11111 提交（2acb598），工作区内容也恢复成那时的样子\n⚠️ 此操作不可逆！未提交的修改将永久丢失。\n \n4.4 恢复恢复刚才的 33333 提交,找回被 reset –hard 删除的提交\n使用 git reflog 查看 HEAD 移动历史，找到被删除提交的哈希：\ngit refloggit reset --hard 8e1f554\t# 恢复到指定提交\n\n \n5.     git reset 和 git revert的区别？\ngit revert：创建一个新的提交来“撤销”旧提交的变更，原提交历史保留。安全，适用于共享分支。 示例：git revert &lt;commit-id&gt; 会生成一个反向提交。\n\ngit reset：将 HEAD、暂存区、工作区重置到指定提交，之后的提交会被“丢弃”（可通过 reflog 恢复）。会改写历史，仅适用于本地或未推送分支。\n 三种模式：\n\n--soft：仅移动 HEAD\n--mixed（默认）：移动 HEAD + 重置暂存区\n--hard：移动 HEAD + 重置暂存区 + 重置工作区\n\n\n\n git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n6.     练习git revert，假设有4个版本，我将回滚到版本2，然后合并修改之后新增版本2增强版，如何实现？查看提交历史：git log --oneline\n找到要撤销的提交（如版本3和版本4），执行：\ngit revert &lt;版本4的commit-id&gt;git revert &lt;版本3的commit-id&gt;\n\n这会生成两个新提交，撤销版本3和4的变更，此时代码状态等同于“版本2”，但历史保留版本3、4、revert1、revert2。\n在此基础上继续开发“版本2增强版”，修改后提交：\n# 修改文件git add .git commit -m &quot;feat: 版本2增强版&quot;\n\n⚠️ 注意：git reset --hard 是直接回退历史，不适用于协作场景。revert 才是协作推荐方式。\n7.     git 可以同时支持几种仓库地址？Git可以同时支持多种仓库地址，比如HTTPS和SSH\n 可以在本地仓库中使用git remote add命令为同一个远程仓库添加多个地址\n8.     在gitee上克隆别人的仓库，默认克隆了几个分支？是否默认创建了远程仓库别名？你能否往这个仓库推送你的版本？\n默认只克隆默认分支（通常是 main 或 master）。\n\n自动创建远程别名 origin。\n\n默认无推送权限（除非你是仓库协作者或拥有者）需要开发者权限。需 Fork 后克隆自己的仓库，修改后提交 Pull Request。\n\n\n9.     一个文件添加到了git仓库，那么我删除这个文件，怎么恢复它？假如我想彻底从git仓库删除这个文件，该怎么做？ 恢复已删除的文件（从最近提交中恢复）：\ngit checkout -- 文件名# 或git restore 文件名\n\n彻底从 Git 仓库删除文件（停止追踪并删除工作区文件）：\ngit rm 文件名git commit -m &quot;删除文件&quot;\n\n若只想停止追踪但保留工作区文件：\ngit rm --cached 文件名git commit -m &quot;停止追踪文件&quot;\n\n git rm 不但会把工作区里面的文件删除，还会把版本库里面的文件也删除，做到彻底移除掉这个文件\n10.      练习远程仓库、新增远程仓库、删除远程仓库、查看以及查看详细远程仓库# 克隆远程仓库git clone 仓库地址# 添加新远程仓库git remote add 别名 仓库地址# 查看所有远程仓库（简略）git remote -v# 查看某个远程仓库详细信息git remote show 别名# 删除远程仓库配置git remote rm 别名\n\n11.      git pull和git push的区别？\ngit pull：从远程仓库拉取最新提交并自动合并到当前分支。相当于 git fetch + git merge。\ngit push：将本地提交推送到远程仓库，更新远程分支。\n\n12.      git push -u 和git push -f 的区别是什么？ -u （或 --set-upstream）以非常安全的模式提交到远程，\n​\t比如远 程早一个版本，它会提示你先git pull 拉取下来\n-f 强制覆盖模式，强制推送，覆盖远程分支历史。危险操作！会丢弃远程分支上其他人的提交。\n 更安全替代：--force-with-lease（仅在远程未更新时强制推送）\n13.      假如我从远程克隆了一个项目，然后我想给这个项目贡献自己的代码？你的理解你应该接下来怎么办？需要修改\n\nFork 项目到自己的账号下（如果是开源项目）。\n克隆自己的 Fork：git clone 自己的仓库地址\n创建新分支开发：git checkout -b feature/xxx\n修改、提交：git add . &amp;&amp; git commit -m &quot;message&quot;\n推送到自己的远程：git push origin feature/xxx\n在网页端发起 Pull Request（PR）到原项目。\n等待审核合并。\n\n14.      我能不能 不经过git add 直接 git commit 提交一个版本？不行，在 Git 中必须先将变更(git add)添加到暂存区(Stage&#x2F;Index)，然后才能提交(git commit)。这是 Git 的基本工作流程。\n15.      有哪些指令可以知道git 仓库改动的信息？\ngit status：查看工作区和暂存区状态（修改、新增、删除）\ngit diff：查看工作区与暂存区差异\ngit diff --cached：查看暂存区与 HEAD 差异\ngit log：查看提交历史\ngit log -p：查看提交历史及每次变更详情\ngit reflog：查看 HEAD 移动记录（包括 reset、checkout 等）\ngit show &lt;commit&gt;：查看某次提交的详情\ngit blame &lt;file&gt;：查看文件每行最后修改者\n\n16.      我有一个项目，想要git来做版本控制管理，第一步应该做什么？初始化本地 Git 仓库，使用命令git init，生成 .git 目录。\n 然后添加文件并首次提交：\ngit add .git commit -m &quot;Initial commit&quot;\n\n\n\n17.      我有一个项目，5个人开发，你应该怎么做，才能确保这个5个可以互相协作开发不出乱子？你的计划是什么？ 协作规范：\n\n使用远程仓库（如 GitHub&#x2F;GitLab&#x2F;Gitee）作为中央仓库。\n每人 Fork 或克隆仓库到本地。\n基于分支开发：\nmain/master 分支保护，禁止直接推送。\n新功能&#x2F;修复在 feature/xxx 或 fix/xxx 分支开发。\n\n\n每日开始前：git pull origin main 同步主干。\n开发完成后：推送分支到远程，发起 Pull Request&#x2F;Merge Request。\nCode Review：团队成员审核代码后合并。\n解决冲突：拉取最新主干，合并到自己分支解决冲突后再提 PR。\n使用 .gitignore 忽略临时文件。\n提交信息规范：清晰描述变更内容。\n\n18.      早上9点公司例会，组长讨论了每个人今日的任务，你分到了一些bug修改，共10条bug，请问今天这一天你打算怎么安排修改？晚上下班前组长要求你们每个人提交今天的任务，你又该怎么做？安排：\n\n从主干拉取最新代码：git pull origin main\n为这组 Bug 创建独立分支：git checkout -b fix/bug-set-20250917\n逐个修复 Bug，每个 Bug 修复后单独提交（原子提交）：\n\n# 修复 bug1git add .git commit -m &quot;fix: 修复用户登录失败问题 #123&quot;# 修复 bug2git add .git commit -m &quot;fix: 修复购物车数量计算错误 #124&quot;...\n\n晚上下班前：\n\n推送分支：git push origin fix/bug-set-20250917\n\n在 Git 平台发起 Merge Request &#x2F; Pull Request 到 main 分支\n\n通知组长或相关同事进行 Code Review\n\n不要直接合并到主干（除非流程允许）\n\n\n19.      接上面，假如你在修改上面的bug时，发现第5个bug，仍然存在问题，你现在想到另一种解决办法，你打算怎么样？不要直接在原提交上修改。\n在当前分支继续修改代码，测试新方案。\n新增一个提交： git add .git commit -m &quot;fix: 优化第5个bug的解决方案，改用XX方法&quot;\n如果原提交有误，可考虑：\n\ngit commit --amend：如果尚未推送，可修改上一次提交。\n或使用 git revert 撤销原修复提交，再提交新方案（适用于已推送场景）。\n\n避免使用 git reset 修改历史，以免影响协作。\n20.      练习从远程克隆仓库到本地，然后做一些修改，修改后提交到远程仓库，顺利提交成功后，再练习本地修改后，再提交到远程，此时远程已经有人修改了比你早提交了版本，你提交不了，发生冲突了，你该如何解决后，提交到远程。 手动解决冲突：编辑冲突文件，删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt;、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记，保留正确内容。\n标记冲突已解决：\ngit add .git commit -m &quot;Merge remote changes and resolve conflicts&quot;\n\n再次推送：\ngit push origin main\n\n\n\n二、     今晚默写和语音题1.     如何创建和合并分支？（默写+语音朗读）创建分支：\n#新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]\n\n合并分支：\n#合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]\n\n\n\n2.     如何将本地仓库与远程仓库同步？（默写+语音朗读）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n答案在下面的网址\nhttp://47.110.66.96/helper/guide/git.html#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF\n三、     明天早上默写和语音题1.     如何解决合并冲突？（默写+面试提问）合并冲突发生在合并分支时，当两个分支的相同部分产生了不同的更改时，解决合并冲突一般步骤如下：\n使用git status命令查看冲突的文件。\n打开冲突文件，手动解决冲突并选择要保留的更改。\n使用git add命令将解决冲突后的文件标记为已解决。\n使用git commit命令提交解决冲突的结果\n2.     如何将本地仓库与远程仓库同步？（默写+面试提问）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n3.     如何创建和合并分支？（默写+面试提问）使用git branch命令创建新分支，例如git branch bug。\n创建分支后，使用git checkout命令切换到新分支，例如git checkout bug。\n要将分支合并到当前分支，可以使用git merge命令，例如git merge dev。\n4.     请介绍git多人远程协作的流程？（默写+面试提问）\n克隆远程仓库\n\n首先，每个开发者需要将远程仓库克隆到本地：\ngit clone &lt;远程仓库URL&gt;\n\n\n创建分支\n\n为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：\ngit checkout -b &lt;分支名&gt;\n\n\n开发与提交\n\n在本地分支上进行开发，完成后提交更改：\ngit add .git commit -m &quot;提交信息&quot;\n\n\n推送分支\n\n将本地分支推送到远程仓库：\ngit push origin &lt;分支名&gt;\n\n\n创建 Pull Request (PR)\n\n在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。\n\n代码审查\n\n团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。\n\n合并 Pull Request (PR)\n\n审查通过后，将 PR 合并到主分支。\n\n同步主分支\n\n合并后，开发者应拉取最新的主分支到本地，保持同步：\ngit checkout maingit pull origin main\n\n\n删除已合并的分支\n\n合并完成后，可以删除远程和本地的已合并分支：\ngit push origin --delete &lt;分支名&gt;git branch -d &lt;分支名&gt;\n\n\n处理冲突\n\n如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：\ngit add &lt;冲突文件&gt;git commit -m &quot;解决冲突&quot;\n\n\n持续集成\n\n许多团队使用 CI&#x2F;CD 工具（如 Jenkins、GitHub Actions）自动测试和部署代码，确保每次合并后的代码质量。\n\n定期同步\n\n开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。\n总结:\n多人协作的关键在于：\n使用分支隔离开发\n通过 PR 进行代码审查\n定期同步主分支\n及时解决冲突\n","tags":["Git#文章标签"]},{"title":"9月17作业 - git进阶","url":"/2025/09/17/%E4%BD%9C%E4%B8%9A_0917_git%E8%BF%9B%E9%98%B6/","content":"一、主观题\ngit pull 和 git fetch的区别？\n\ngit pull —— 下载 + 自动合并\n 作用：git fetch + git merge 的组合命令。它会先从远程拉取最新数据，然后自动尝试合并到你当前所在的本地分支。\n可能直接修改你的工作区！在未保存或未提交本地修改时容易出问题。\ngit fetch —— 仅下载，不合并作用：从远程仓库下载最新的提交、分支、标签等对象到本地仓库，但不会自动合并或修改你当前的工作区和分支。\n\n两个历史不相同的仓库如何git pull 并且 git push到远程仓库？\n\n直接使用git pull 无法拉取远程仓库版本信息，因为是本地和远程仓库是不同的独立仓库，要拉取必须使用 –allow-unrelated-histories参数允许合并无关历史\n 如：\ngit pull origin main --allow-unrelated-histories\n\n合并后解决可能的冲突，再 git push 即可。\n\n请解释一下git 的相关概念、工作区、暂存盘、版本库、远程仓库， 介绍它们的关系是什么？操作流程是什么？\ngit概念：Git 是一个开源的分布式版本控制系统，用于追踪文件变更、协作开发、版本回退等。\n工作区：正在编辑文件的目录，就是你的项目文件夹\n暂存盘：临时区域，用于存放你准备提交（commit）的文件变更。\n版本库：本地仓库，保存项目完整历史记录的地方，位于项目根目录下的 .git 文件夹中。\n远程仓库：托管在服务器上的 Git 仓库，如 GitHub、Gitee、GitLab 等平台上的项目仓库。\n关系：\n\n工作区 → 暂存区：git add\n暂存区 → 本地版本库：git commit\n本地版本库 ↔ 远程仓库：git push &#x2F; git pull &#x2F; git fetch\n远程仓库 → 本地版本库 → 工作区：git clone（首次拉取整个项目）\n\n流程：\n# 1. 在工作区修改文件（如：edit index.html）# 2. 查看当前状态（可选）git status# 3. 把修改添加到暂存区git add index.html# 或添加所有改动：git add .# 4. 提交到本地版本库git commit -m &quot;描述你的修改，例如：更新首页布局&quot;# 5. 推送到远程仓库（如 origin 的 main 分支）git push origin main\n\n\n\n假如现在项目有一个报错，通过报错提示我定位到具体的文件，但是我现在弄清楚这个错误是谁导致的，git怎么做？\n使用命令git blame 文件名\n显示指定文件的每行代码最后一次修改的提交信息（作者、时间、代码内容）。\n\n我想知道工作区和暂存盘的区别？git使用什么命令合适？\n工作区：正在编辑文件的目录，就是你的项目文件夹\n暂存盘：一个临时区域，用于存放你准备提交（commit）的文件变更。\n使用命令：\ngit diff              # 查看工作区与暂存区差异git diff --cached     # 查看暂存区与版本库差异git diff HEAD         # 查看工作区与版本库差异\n\n\n\n我在做项目实现一个功能，我试了好几个方案，都不理想，最后我权衡下来，觉得还是方案2可行性高，打算从方案2继续研究下去。请问你接下来git怎么操作比较合适？\n多方案选择回溯，应使用命令git reset回退到指定提交：\ngit reset --hard 版本号  # 彻底回溯到方案2git reset --soft 版本号  # 保留后续修改\n\n\n\n我在项目因为我对项目有洁癖，被我不小心删除了一个config文件，请问我怎么找回来？\n工作区撤销修改：\n\ngit status 查看修改的文件\n使用命令恢复：git checkout -- 被恢复的文件\n\n暂存盘撤销修改：\n\ngit reset HEAD 被恢复的文件\ngit checkout -- 被恢复的文件\n\n已提交：\ngit checkout 版本号 -- 文件  # 从历史版本恢复\n\n\n\n我有个项目打算使用git做分布式管理， 但是当我提交一个版本的时候居然不能提交，请问有几种可能导致不能提交？\n\n本地分支未关联远程分支：git branch --set-upstream-to=origin/远程分支名 本地分支名\n\n提交信息不规范（某些仓库要求符合conventional commit）\n\n文件大小超限（如GitHub限制100MB）\n\n网络代理问题\n\n远程分支保护策略（如main分支需PR才能合并）\n\n无写权限 → 检查远程仓库权限或 SSH key\n\n\n\n我有个项目是多人协作的，我完成了一个功能，组长催促我赶紧上传到远程，我于是保存版本后，开始使用git push上传，但不能成功上传，请问有几种可能导致不能推送到远程？\n\n本地分支未关联远程分支：git branch --set-upstream-to=origin/远程分支名 本地分支名\n\n提交信息不规范（某些仓库要求符合conventional commit）\n\n文件大小超限（如GitHub限制100MB）\n\n网络代理问题\n\n远程分支保护策略（如main分支需PR才能合并）\n\n无写权限 → 检查远程仓库权限或 SSH key\n\n\n\n练习成语接龙游戏，自己找搭档配合练习， 不想练就把整个过程文字描述一下。\n\ngit pull拉取远程仓库最新的提交和分支信息，\n\n在本地进行修改添加文件内容，\n\n使用git push提交至远程仓库，\n\n提交不了则使用git stash保存工作区内容，使用git pull拉取最新提交版本信息，在本地解决冲突后，git add保存解决冲突后的版本，git commit提交一个版本，最后git push到远程仓库\ngit pull                          # 拉取远程更新（可能冲突）git stash                         # 保存本地未提交修改git pull                          # 成功拉取git stash pop                     # 恢复并合并，手动解决冲突git add .                         # 标记冲突已解决git commit -m &quot;fix: resolve conflict&quot;git push origin main              # 推送\n\n\n练习分支管理、查看分支、删除分支、添加分支、切换分支、创建切换分支\n\n\n\n操作\n命令\n\n\n\n查看本地分支\ngit branch\n\n\n查看详细分支\ngit branch -v\n\n\n查看所有分支\ngit branch -a\n\n\n创建分支\ngit branch dev\n\n\n切换分支\ngit switch dev 或 git checkout dev\n\n\n创建+切换\ngit switch -c dev 或 git checkout -b dev\n\n\n合并分支\ngit merge dev\n\n\n删除分支（安全）\ngit branch -d dev\n\n\n强制删除分支\ngit branch -D dev\n\n\n\n⚠️ 注意：\n\n不能删除当前所在分支。\n-D 是强制删除，即使未合并也可删，不适用于远程分支（远程分支需 git push origin --delete dev）。\n\n\n\n练习抓取远程分支、远程修改默认分支\ngit checkout -b decgit push origin devgit switch -c bug origin\n\n \n\n再练习一遍git  stash的操作\n1.工作区修改文件（不要添加暂存和保存版本）\n2.远程仓库修改文件并提交版本\n3.执行git pull报错，拒绝拉取\n4.执行git stash 存储工作区\n5.执行git pull，允许拉取\n6.使用git stash list 查看，使用git stash pop恢复\n7.手动解决冲突，git add -A\n \n\ngit branch -d 和 git branch -D的区别？\ngit branch -d 分支名：删除已合并的分支\ngit branch -D 分支名：强制删除（无论是否合并），可以删除远程分支\n\n❗ 两者都不能删除当前所在分支！ \n❗ 远程分支删除命令是：git push origin --delete dev\n\n\n.gitignore文件有什么作用？\n.gitignore 作用：上传忽略名单\n可以在.gitignore文件中添加文件夹，指定文件或者指定类型的文件\n# 通用模板示例*.log.DS_Storenode_modules/# 排除特定文件夹但保留必要文件!/logs/important.log# 环境变量文件.env*.secret\n\n\n\ngit log和 git reflog的区别？\ngit log：查看历史版本到当前版本的日志（完整提交信息）\ngit reflog：查看所有历史版本信息（简写哈希+操作动作）\n查看的是一个短的版本号，例如 da213db\n\n\n二、 今晚默写和语音题\ngit仓库中的https和ssh协议的区别?（默写+语音朗读）\n\nhttps协议在推送的时候会弹出登录框，输入仓库托管网站（gitee或者github等）的账户和密码，输入成功后，我们的操作系统会自动记住登录状态，下一次推送不需要再输入账号和密码\n\nssh协议需要自己生成公钥，并且和仓库托管网站登录账户进行绑定，即可。绑定成功后，也是可以免密码登录推送的。\n\n\n\n请介绍推送本地仓库到远程的过程？（默写+语音朗读）\n# 添加暂存盘git add -A# 提交一个版本git commit  -m “描述文字”# 添加远程仓库别名git remote add origin 仓库地址# 推送到远程仓库git push -u origin main\n\n答案在下面的网址http://47.110.66.96/helper/guide/git.html#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF\n三、 明天早上默写和语音题\ngit rebase 和 git merge的区别？（默写+面试提问）\ngit rebase 和 git merge 都是用来“整合分支”的工具，但它们的实现方式、历史记录结构、适用场景完全不同。\n**merge 是“合并”，保留完整历史分支结构；适合公共分支合并 rebase 是“变基”，把你的提交“挪到”目标分支最新提交之后，让历史线性整洁。**适合本地分支整理\n\nmerge 三方合并一次性解决冲突\n\nrebase 逐个提交重放可能多次解冲突\n\n黄金法则：已推送的代码只用 merge，未推送的才用 rebase\n\n\n\n如何解决提交版本产生冲突？（默写+面试提问）\n\n\n多人同时修改同一文件的同一区域\n执行 git pull&#x2F;git merge&#x2F;git rebase 时\n分支合并时存在不兼容的修改\n\n\n解决：\n\n使用git status命令查看冲突的文件。\n\n打开冲突文件，手动解决冲突并选择要保留的更改。\n\n使用git add命令将解决冲突后的文件标记为已解决。\n\n使用git commit命令提交解决冲突的结果\n\n推送到远程仓库：git push origin main\n\n\n\n请介绍推送本地仓库到远程的过程？（默写+面试提问）\n# 添加暂存盘git add -A# 提交一个版本git commit  -m “描述文字”# 添加远程仓库别名git remote add origin 仓库地址# 推送到远程仓库git push -u origin master\n\n\n\n请介绍git多人远程协作的流程？（默写+面试提问）\n\n克隆远程仓库\n\n首先，每个开发者需要将远程仓库克隆到本地：\ngit clone &lt;远程仓库URL&gt;\n\n\n创建分支\n\n为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：\ngit checkout -b &lt;分支名&gt;\n\n\n开发与提交\n\n在本地分支上进行开发，完成后提交更改：\ngit add .git commit -m &quot;提交信息&quot;\n\n\n推送分支\n\n将本地分支推送到远程仓库：\ngit push origin &lt;分支名&gt;\n\n\n创建 Pull Request (PR)\n\n在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。\n\n代码审查\n\n团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。\n\n合并 Pull Request (PR)\n\n审查通过后，将 PR 合并到主分支。\n\n同步主分支\n\n合并后，开发者应拉取最新的主分支到本地，保持同步：\ngit checkout maingit pull origin main\n\n\n删除已合并的分支\n\n合并完成后，可以删除远程和本地的已合并分支：\ngit push origin --delete &lt;分支名&gt;git branch -d &lt;分支名&gt;\n\n\n处理冲突\n\n如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：\ngit add &lt;冲突文件&gt;git commit -m &quot;解决冲突&quot;\n\n\n持续集成\n\n许多团队使用 CI&#x2F;CD 工具（如 Jenkins、GitHub Actions）自动测试和部署代码，确保每次合并后的代码质量。\n\n定期同步\n\n开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。\n总结:\n多人协作的关键在于：\n使用分支隔离开发\n通过 PR 进行代码审查\n定期同步主分支\n及时解决冲突\n\n\n","tags":["Git#文章标签"]},{"title":"Git作业_0916","url":"/2025/09/17/Git%E4%BD%9C%E4%B8%9A_0916/","content":"一、主观题\ngit stash 练习，练习步骤\n\n \n1.创建并克隆仓库：\n \n \n2.本地修改1.txt文件\n  \n3.远程修改1.txt文件，并提交版本\n  \n4.执行git pull 报错 （因本地有未提交修改，与远程冲突）\n \n5.执行git stash存储工作区修改，使用git stash list查看存储栈\n  \n6.执行git pull 拉取远程最新版本（此时本地无修改，可顺利合并）\n \n7.使用git stash pop 恢复之前暂存的修改（自动尝试合并，若冲突需手动解决）\n  \n8.手动编辑冲突文件，解决冲突后执行 git add -A 标记为已解决\n \n9.提交合并结果并上传远程仓库 git push\n \n2.     git show有什么作用？git show 命令用于显示 Git 仓库中对象（如提交 commit、标签 tag、文件 blob 等）的详细信息。默认显示最近一次提交的元数据和变更内容。\n是查看历史变更和对象内容的核心命令。\n3.     git blame 有什么作用？git blame 用于逐行显示文件中每行代码的最后修改者、提交哈希、修改时间和具体内容，帮助追踪代码变更历史和责任归属。\n运行 git blame &lt;文件路径&gt; 可直观看到每行的“责任人”和修改上下文。\n对代码审查、Bug 追溯、交接维护非常有用。\n4.     再练习一遍撤销还原操作4.1 工作区撤销（丢弃工作区未暂存的修改）\n\n\n在工作区修改了文件\n\n使用git status 查看那些文件被修改了\n \n\n使用以下任一命令丢弃修改，恢复到最近一次提交的状态：\n使用git checkout – 被恢复的文件\n\n\ngit statusgit checkout -- readme.txt// 或者git restore readme.txt\n \n \n4.2  暂存盘软撤销（取消暂存，保留工作区内容）\n\n\n在工作区修改文件\n使用 git add 添加到暂存区\n使用 git status 查看状态\n取消暂存（但保留工作区内容）：\n\n方法1（传统）：\ngit statusgit reset HEAD readme.txt\t# 取消暂存git checkout -- readme.txt\t# 丢弃工作区修改（可选）\n\n方法2（推荐，Git 2.23+）:\ngit restore --staged readme.txt\t\t# 取消暂存git restore readme.txt\t\t\t# 丢弃工作区修改（可选）\n\n注意：先修改一下文件，然后使用git add 将修改过后的文件添加到暂存盘，然后做上面的练习\n\n1.工作区修改文件，添加至暂存区：\n \n2.使用git status查看查看状态：\n\n使用 git reset HEAD 文件名 取消暂存 + git checkout -- 文件名 丢弃修改：\n  \n4.3  暂存盘硬撤销（恢复修改前的工作区内容）（取消暂存并丢弃工作区修改）\n将被修改了文件添加到暂存盘# 假设文件已修改并 add 到暂存区git restore --staged 1.txt\t# 取消暂存git restore 1.txt\t\t# 丢弃工作区所有修改，恢复到 HEAD 状态\n\n \n4.2  版本软回滚（保留工作区和暂存区内容，仅移动 HEAD）\n git reset –soft 短版本号\n 目标：回滚到 22222 提交（3bfdc42），但保留当前 1.txt 的所有内容（包括 33333）\ngit reset --soft 3bfdc42\n\n此时提交历史回到 3bfdc42，但工作区和暂存区保持不变，可重新 commit。\n \n4.3  版本硬回滚（工作区内容也恢复）（工作区、暂存区、HEAD 全部回退）\n git reset –hard 短版本号\n目标：彻底回滚到 11111 提交（2acb598），工作区内容也恢复成那时的样子\n⚠️ 此操作不可逆！未提交的修改将永久丢失。\n \n4.4 恢复恢复刚才的 33333 提交,找回被 reset –hard 删除的提交\n使用 git reflog 查看 HEAD 移动历史，找到被删除提交的哈希：\ngit refloggit reset --hard 8e1f554\t# 恢复到指定提交\n\n \n5.     git reset 和 git revert的区别？\ngit revert：创建一个新的提交来“撤销”旧提交的变更，原提交历史保留。安全，适用于共享分支。示例：git revert &lt;commit-id&gt; 会生成一个反向提交。\n\ngit reset：将 HEAD、暂存区、工作区重置到指定提交，之后的提交会被“丢弃”（可通过 reflog 恢复）。会改写历史，仅适用于本地或未推送分支。\n三种模式：\n\n--soft：仅移动 HEAD\n--mixed（默认）：移动 HEAD + 重置暂存区\n--hard：移动 HEAD + 重置暂存区 + 重置工作区\n\n\n\n git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n6.     练习git revert，假设有4个版本，我将回滚到版本2，然后合并修改之后新增版本2增强版，如何实现？查看提交历史：git log --oneline\n找到要撤销的提交（如版本3和版本4），执行：\ngit revert &lt;版本4的commit-id&gt;git revert &lt;版本3的commit-id&gt;\n\n这会生成两个新提交，撤销版本3和4的变更，此时代码状态等同于“版本2”，但历史保留版本3、4、revert1、revert2。\n在此基础上继续开发“版本2增强版”，修改后提交：\n# 修改文件git add .git commit -m &quot;feat: 版本2增强版&quot;\n\n⚠️ 注意：git reset --hard 是直接回退历史，不适用于协作场景。revert 才是协作推荐方式。\n7.     git 可以同时支持几种仓库地址？Git可以同时支持多种仓库地址，比如HTTPS和SSH\n 可以在本地仓库中使用git remote add命令为同一个远程仓库添加多个地址\n8.     在gitee上克隆别人的仓库，默认克隆了几个分支？是否默认创建了远程仓库别名？你能否往这个仓库推送你的版本？\n默认只克隆默认分支（通常是 main 或 master）。\n\n自动创建远程别名 origin。\n\n默认无推送权限（除非你是仓库协作者或拥有者）需要开发者权限。需 Fork 后克隆自己的仓库，修改后提交 Pull Request。\n\n\n9.     一个文件添加到了git仓库，那么我删除这个文件，怎么恢复它？假如我想彻底从git仓库删除这个文件，该怎么做？ 恢复已删除的文件（从最近提交中恢复）：\ngit checkout -- 文件名# 或git restore 文件名\n\n彻底从 Git 仓库删除文件（停止追踪并删除工作区文件）：\ngit rm 文件名git commit -m &quot;删除文件&quot;\n\n若只想停止追踪但保留工作区文件：\ngit rm --cached 文件名git commit -m &quot;停止追踪文件&quot;\n\n git rm 不但会把工作区里面的文件删除，还会把版本库里面的文件也删除，做到彻底移除掉这个文件\n10.      练习远程仓库、新增远程仓库、删除远程仓库、查看以及查看详细远程仓库# 克隆远程仓库git clone 仓库地址# 添加新远程仓库git remote add 别名 仓库地址# 查看所有远程仓库（简略）git remote -v# 查看某个远程仓库详细信息git remote show 别名# 删除远程仓库配置git remote rm 别名\n\n11.      git pull和git push的区别？\ngit pull：从远程仓库拉取最新提交并自动合并到当前分支。相当于 git fetch + git merge。\ngit push：将本地提交推送到远程仓库，更新远程分支。\n\n12.      git push -u 和git push -f 的区别是什么？ -u （或 --set-upstream）以非常安全的模式提交到远程，\n​\t比如远 程早一个版本，它会提示你先git pull 拉取下来\n-f 强制覆盖模式，强制推送，覆盖远程分支历史。危险操作！会丢弃远程分支上其他人的提交。\n 更安全替代：--force-with-lease（仅在远程未更新时强制推送）\n13.      假如我从远程克隆了一个项目，然后我想给这个项目贡献自己的代码？你的理解你应该接下来怎么办？需要修改\n\nFork 项目到自己的账号下（如果是开源项目）。\n克隆自己的 Fork：git clone 自己的仓库地址\n创建新分支开发：git checkout -b feature/xxx\n修改、提交：git add . &amp;&amp; git commit -m &quot;message&quot;\n推送到自己的远程：git push origin feature/xxx\n在网页端发起 Pull Request（PR）到原项目。\n等待审核合并。\n\n14.      我能不能 不经过git add 直接 git commit 提交一个版本？不行，在 Git 中必须先将变更(git add)添加到暂存区(Stage&#x2F;Index)，然后才能提交(git commit)。这是 Git 的基本工作流程。\n15.      有哪些指令可以知道git 仓库改动的信息？\ngit status：查看工作区和暂存区状态（修改、新增、删除）\ngit diff：查看工作区与暂存区差异\ngit diff --cached：查看暂存区与 HEAD 差异\ngit log：查看提交历史\ngit log -p：查看提交历史及每次变更详情\ngit reflog：查看 HEAD 移动记录（包括 reset、checkout 等）\ngit show &lt;commit&gt;：查看某次提交的详情\ngit blame &lt;file&gt;：查看文件每行最后修改者\n\n16.      我有一个项目，想要git来做版本控制管理，第一步应该做什么？初始化本地 Git 仓库，使用命令git init，生成 .git 目录。\n 然后添加文件并首次提交：\ngit add .git commit -m &quot;Initial commit&quot;\n\n\n\n17.      我有一个项目，5个人开发，你应该怎么做，才能确保这个5个可以互相协作开发不出乱子？你的计划是什么？ 协作规范：\n\n使用远程仓库（如 GitHub&#x2F;GitLab&#x2F;Gitee）作为中央仓库。\n每人 Fork 或克隆仓库到本地。\n基于分支开发：\nmain/master 分支保护，禁止直接推送。\n新功能&#x2F;修复在 feature/xxx 或 fix/xxx 分支开发。\n\n\n每日开始前：git pull origin main 同步主干。\n开发完成后：推送分支到远程，发起 Pull Request&#x2F;Merge Request。\nCode Review：团队成员审核代码后合并。\n解决冲突：拉取最新主干，合并到自己分支解决冲突后再提 PR。\n使用 .gitignore 忽略临时文件。\n提交信息规范：清晰描述变更内容。\n\n18.      早上9点公司例会，组长讨论了每个人今日的任务，你分到了一些bug修改，共10条bug，请问今天这一天你打算怎么安排修改？晚上下班前组长要求你们每个人提交今天的任务，你又该怎么做？安排：\n\n从主干拉取最新代码：git pull origin main\n为这组 Bug 创建独立分支：git checkout -b fix/bug-set-20250917\n逐个修复 Bug，每个 Bug 修复后单独提交（原子提交）：\n\n# 修复 bug1git add .git commit -m &quot;fix: 修复用户登录失败问题 #123&quot;# 修复 bug2git add .git commit -m &quot;fix: 修复购物车数量计算错误 #124&quot;...\n\n晚上下班前：\n\n推送分支：git push origin fix/bug-set-20250917\n\n在 Git 平台发起 Merge Request &#x2F; Pull Request 到 main 分支\n\n通知组长或相关同事进行 Code Review\n\n不要直接合并到主干（除非流程允许）\n\n\n19.      接上面，假如你在修改上面的bug时，发现第5个bug，仍然存在问题，你现在想到另一种解决办法，你打算怎么样？不要直接在原提交上修改。\n在当前分支继续修改代码，测试新方案。\n新增一个提交：\n git add .git commit -m &quot;fix: 优化第5个bug的解决方案，改用XX方法&quot;\n\n如果原提交有误，可考虑：\n\ngit commit --amend：如果尚未推送，可修改上一次提交。\n或使用 git revert 撤销原修复提交，再提交新方案（适用于已推送场景）。\n\n避免使用 git reset 修改历史，以免影响协作。\n20.      练习从远程克隆仓库到本地，然后做一些修改，修改后提交到远程仓库，顺利提交成功后，再练习本地修改后，再提交到远程，此时远程已经有人修改了比你早提交了版本，你提交不了，发生冲突了，你该如何解决后，提交到远程。 手动解决冲突：编辑冲突文件，删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt;、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记，保留正确内容。\n标记冲突已解决：\ngit add .git commit -m &quot;Merge remote changes and resolve conflicts&quot;\n\n再次推送：\ngit push origin main\n\n\n\n二、     今晚默写和语音题1.     如何创建和合并分支？（默写+语音朗读）创建分支：\n#新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]\n\n合并分支：\n#合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]\n\n\n\n2.     如何将本地仓库与远程仓库同步？（默写+语音朗读）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n答案在下面的网址\nhttp://47.110.66.96/helper/guide/git.html#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF\n三、     明天早上默写和语音题1.     如何解决合并冲突？（默写+面试提问）合并冲突发生在合并分支时，当两个分支的相同部分产生了不同的更改时，解决合并冲突一般步骤如下：\n使用git status命令查看冲突的文件。\n打开冲突文件，手动解决冲突并选择要保留的更改。\n使用git add命令将解决冲突后的文件标记为已解决。\n使用git commit命令提交解决冲突的结果\n2.     如何将本地仓库与远程仓库同步？（默写+面试提问）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n3.     如何创建和合并分支？（默写+面试提问）使用git branch命令创建新分支，例如git branch bug。\n创建分支后，使用git checkout命令切换到新分支，例如git checkout bug。\n要将分支合并到当前分支，可以使用git merge命令，例如git merge dev。\n4.     请介绍git多人远程协作的流程？（默写+面试提问）\n克隆远程仓库\n\n首先，每个开发者需要将远程仓库克隆到本地：\ngit clone &lt;远程仓库URL&gt;\n\n\n创建分支\n\n为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：\ngit checkout -b &lt;分支名&gt;\n\n\n开发与提交\n\n在本地分支上进行开发，完成后提交更改：\ngit add .git commit -m &quot;提交信息&quot;\n\n\n推送分支\n\n将本地分支推送到远程仓库：\ngit push origin &lt;分支名&gt;\n\n\n创建 Pull Request (PR)\n\n在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。\n\n代码审查\n\n团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。\n\n合并 Pull Request (PR)\n\n审查通过后，将 PR 合并到主分支。\n\n同步主分支\n\n合并后，开发者应拉取最新的主分支到本地，保持同步：\ngit checkout maingit pull origin main\n\n\n删除已合并的分支\n\n合并完成后，可以删除远程和本地的已合并分支：\ngit push origin --delete &lt;分支名&gt;git branch -d &lt;分支名&gt;\n\n\n处理冲突\n\n如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：\ngit add &lt;冲突文件&gt;git commit -m &quot;解决冲突&quot;\n\n\n持续集成\n\n许多团队使用 CI&#x2F;CD 工具（如 Jenkins、GitHub Actions）自动测试和部署代码，确保每次合并后的代码质量。\n\n定期同步\n\n开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。\n总结:\n多人协作的关键在于：\n使用分支隔离开发\n通过 PR 进行代码审查\n定期同步主分支\n及时解决冲突\n","tags":["Git#文章标签"]},{"title":"git笔记","url":"/2025/09/18/git%E7%AC%94%E8%AE%B0/","content":"第一章 概述1、Git 历史同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。\n到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标：\n• 速度\n• 简单的设计\n• 对非线性开发模式的强力支持（允许上千个并行开发的分支）\n• 完全分布式\n• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）\n2、Git 定义Git 是一个开源的分布式版本控制系统（Distributed Version Control System，简称 DVCS），仓库类型分为：本地仓库和远程仓库：\n\n**本地仓库：**开发人员自己电脑上的 Git 仓库\n**远程仓库：**是在远程服务器上的 Git 仓库\n\n/*Git 是目前世界上最先进、最流行的版本控制系统，可以快速高效地处理从很小到非常大的项目版本管理。它没有中央服务器的概念，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了，\n\n\n\n下图就是分布式版本控制工具管理方式：\n \n\nClone：克隆，就是将远程仓库复制到本地\nPush：推送，就是将本地仓库代码上传到远程仓库\nPull：拉取，就是将远程仓库代码下载到本地仓库\n\n特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性\n3、Git 特性和优势Git 之所以快速和高效，主要依赖于它的如下两个特性： \n\n直接记录快照，而非差异比较\n近乎所有操作都是本地执行，不需要联网\n\n特性一：git的记录快照\nGit 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git  不再重新存储该文件，而是只保留一个链接指向之前存储的文件。\n\n/*解析：version1：文件A、B、Cversion2：A 和 C 更新为 A1 C1，  B 没有更新，不备份version3：C1 更新为 C2，  A1 和 B 没有更新，不备份version4：A1 B 更新为 A2 B1，  C2 没有更新，不备份...\n\n优缺点：\n\n缺点：占用磁盘空间较大 \n优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。\n特点：空间换时间\n\n特性二：在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 \n特性： \n\n\n断网后依旧可以在本地对项目进行版本管理 \n联网后，把本地修改的记录同步到云端服务器即可\n\n\nGit的优势还有：\n\n尽可能添加数据而不是删除或修改数据\n分支操作非常快捷流畅\n与 Linux 命令全面兼容\n\nGit 应用场景\n写作（作家、演说家、编剧）\n程序开发\n起草法律条款\n写学术论文\n\n4、Git 与 SVN 比较SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。\n下图就是标准的集中式版本控制工具管理方式：\n\n集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。\nsvn：传统的版本控制系统是基于差异的版本控制（每次记录的是变化的内容），它们存储的是一组基本文件和每个文件随时间逐步累积的差异。\n\n/*解析：初始版本1 中有三个文件 A B C升级到版本2：在版本2中记录的是文件A变化的内容 🔺1  和 文件C变化的内容 🔺1升级到版本3：在版本3中记录文件c的变化内容 🔺2...切换到版本3，需要在初始文件 A 应用一次差异，在初始文件 C 上应用2次差异如果是切换版本5，需要在初始文件 A 上应用2次差异，在初始文件 B 上应用2次差异，在初始文件 C 上应用2次差异\n\n优缺点：\n\n好处：节省磁盘空间\n缺点：耗时、效率低 在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。\n\n集中式和分布式版本控制系统的区别？集中式SVN，分布式git，区别如下：\n集中式的缺点：\n\n必须联网才能工作\n\n中央服务器出问题了，就没法工作\n\n分支速度慢\n\n\n分布式的优点：\n\n不需要联网，也可以工作。\n没有中央服务，每台自己就是服务器。\n没有全局分支，自己的服务器可以创建n个分支，速度极快。\n\ngit和svn的区别\n1.Git 是分布式的，SVN集中式2.Git 把内容按元数据方式存储，而 SVN 是按文件3.Git 分支和 SVN 的分支不同4.Git 没有一个全局的版本号，而 SVN 有5.Git 的内容完整性要优于 SVN\n\n5、Git 中的三个区域使用 Git 管理的项目，拥有三个区域，分别是：\n\n工作区：本地处理工作的区域（写代码，修改代码）\n暂存区：已完成的工作临时存放区域， 等待被提交\nGit 仓库：最终的存放区域\n\n\n解析：\n\n工作区就是电脑里能看到的目录，存放项目或者文件的目录；\n在这个工作目录中的 .git 隐藏文件夹才是版本库；\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n当我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，git commit就是往master分支上提交更改。\n可以简单理解为，需要提交的文件修改后通通放到暂存区，然后，一次性将暂存区的所有修改提交到分支。\n\n\n6、Git 中的三种状态使用 Git 管理的项目，拥有三个状态，分别是：\n\nmodified（已修改）：表示修改了文件，但还没 将修改的结果放到暂存区\nstaged（已暂存）：表示对已修改文件的当前版本做了标记，让它包含在下次提交的列表中\ncommitted（已提交）：表示文件已经安全地保存 在本地的 Git 仓库中\n\n注意：\n\n工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。 \n如果文件已修改并放入暂存区，就属于已暂存状态。 \n如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。\n\n7、Git 和代码托管中心代码托管中心的作用是：维护远程库\n局域网环境下：gitlab 服务器（可以自己搭建的服务器）\n联网环境下：github 和 码云(gitee)\n注意：\n\ngit 和 github 是两个完全没有关系的概念，\n\ngit 是版本控制工具，管理本地仓库\nGitHub 是远程仓库托管中心\n\n\nGit 与 GitHub 区别？git是一个版本控制系统，而github是一个在线开源托管网站。你可以使用git上传源码到github开源网站上去。\n8、Git 工作流程一般工作流程如下：\n\n从远程仓库中克隆 Git 资源作为本地仓库；\n\n从本地仓库中 checkout 代码到工作区，然后进行代码修改；\n\n在提交前先将代码提交到暂存区；\n\n提交到本地仓库，本地仓库中保存修改的各个历史版本；\n\n在修改完成后，需要和团队成员共享代码时，可以将代码 push 到远程仓库（git仓库）。\n\n\n下图展示了 Git 的工作流程：\n\n9、本地库和远程库作用是协作开发\n9.1 团队内部协作\n\n9.2 跨团队协作\n\n第二章 环境准备最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。由于开发机大多数情况都是windows，所以这里讲解windows下的git的安装及使用\n1、Git1.1 软件下载下载地址：https://git-scm.com/download\n\n\n淘宝镜像下载安装\n\nhttps://npm.taobao.org/mirrors/git-for-windows/\n\n安装方式\n因为git是命令行工具，默认安装再C盘，不要装作含中文的目录下，建议一路下一步安装\n\n1.2 软件安装git的安装一路点击“下一步”，使用默认的选项即可\n安装详解：\n\n安装 git for windows\n\n\n\n选择安装路径：使用非中文没有空格的目录\n\n\n\n选择组件：默认\n\n\n选项解析：\n\nAdditional icons ： 否创建图标\n\nOn the Desktop ：在桌面\n\nWindows Explorer integration：集成右键功能\n\nGit Bash Here\nGit GUI Here\n\nGit LFS (Large File Support)：git大文件支持\nAssociate .git* configuration files with the default text editorAssociate .sh files to be run with Bash：打开 git 配置文件的默认文本编辑器\n\n\n选择开始目录文件：默认\n\n\n\n选择默认文本编辑器：使用默认的 vim 编辑器\n\n\n\n初始化分支名称：默认\n\n\n解析：\n\nLet Git decide：让 git 决定\n\n.Let Git use its default branch name (currently: “master”) for the initial branchin newly created repositories. The Git project intends to change this default toa more inclusive name in the near future.\n\n让 git 使用初始化生成的分支，默认名称为 master…\n\n\n调整环境变量：可以选择第一项，也可以使用默认的推荐选项（第二项）\n\n\n解析：\n\nUse Git from Git Bash only:\n\n这是最多的选择，将不会改变你的环境，但是只能在 git bash 中执行 git 命令\n\nGit from the command line and also from 3rd-party software\n\n推荐，这个选项只给你的path添加了一些最小的git包装器，可以从 git bash 中使用git，也可以从命令提示符等以及任何第三方软件中寻找 git\n\nuse Git and optional Unix tools from the Command Prompt\n\n警告：这个选项会修改 path，覆盖 windows的一些命令，如“查找” 和 “排序”…  不推荐\n\n\n\n选择可知行文件：默认自带的 ssh.exe\n\n\n解析：\n\nUse bundled OpenSSH：使用自带的 ssh.exe（可执行文件）\n\nThis uses ssh.exe that comes with Git.)\n\nUse external OpenSSH：使用外部的可执行文件\n\nNEW!This uses an external ssh.exe.Git will not install its own OpenSSH(and related) binaries but use them as found on the PATH.\n\n\n\n选择传输协议：默认\n\n\n解析：\n\nUse the openSSL library\n\n使用通用的 openSSL 库建立连接，推荐\n\nUse the native Windows Secure Channel library\n\n本地windows安全通道连接有一定的局限性，不推荐使用\n\n\n\n配置文本结束符：默认\n\n\n解析：\n\ncheckout Windows-style, commit Unix-style line endings\n\nGit will convert LF to CRLF when checking out text files. When committingtext files,CRLF will be converted to LF. For cross-platform projects,this is the recommended setting on Windows (“core.autocrIf” is set to “true”).\n\n检出文件时将 LF 转换为 CRLF, 提交时将 CRLF 转换为 LF（windows 和 Unix 系统换行符不一样，这个选项会帮我们做转换）\nCheckout as-is, commit Unix-style line endings\n\nGit will not perform any conversion when checking out text files. When committing text files,CRLF will be converted to LF.For cross-platform projects,this is the recommended setting on Unix (“core.autocrlf” is set to “input”).\n\nCheckout as-is, commit as-is\n\nGit will not perform any conversions when checking out or committingtext files. Choosing this option is not recommended for cross-platformprojects (“core.autocrlf” is set to “false”).\n\n\n\n配置 git 终端：默认\n\n\n解析：\n\nUse MinTTY (the default terminal of MSYS2)\n\nGit Bash will use MinTTY as terminal emulator, which sports a resizable window,non-rectangular selections and a Unicode font. Windows console programs(suchas interactive Python) must be launched via ‘winpty&#96; to work in MinTTY.\n\n使用 git 自带的默认终端（推荐，命令和 linux 命令兼容）\nuse Windows’ default console window\n\nGit will use the default console window of Windows (“cmd.exe”), which works wellwith Win32 console programs such as interactive Python or node.js, but has avery limited default scroll-back, needs to be configured to use a Unicode font inorder to display non-ASCII characters correctly, and prior to Windows 10 itswindow was not freely resizable and it only allowed rectangular text selections.\n\n使用 windows 默认的的命令提示符（可能会有命令冲突，不推荐）\n\n\n选择 git pull 默认行为：默认\n\n\n\n启用授权管理器：默认\n\n\n\n启用文件缓存：默认\n\n\n\n最后是一些新的功能，可以不勾选，直接 Install 安装\n\n\n\n安装成功\n\n最后取消勾选”View Release Notes（视图版本说明，不需要）” → finish\n\n\n检测是否安装成功\n\n任意位置右键，有 Git GUI Here 和 Git Bash Here  表示安装成功\n\n验证安装成功\n\nwin菜单 打开运行命令\n\n\n\n打开 CMD 命名窗口\n\n\n\n在命令行中输入  git –version 然后会打印出版本号\n\n\n\n安装成功\n\n\n\n2、TortoiseGit2.1 软件介绍TortoiseGit 其实是一款开源的git的版本控制系统，也叫海龟git。TortoiseGit提供了人性化的图形化界面，不用像Git一样输入许多语句，像git init、git add、git commit这些语句就通通不用记了。轻松使用鼠标，就可以完成代码的提交和上传。对于使用本地Git的新手来说，TortoiseGit更加简便，更加容易上手。\n2.2 软件下载地址：https://tortoisegit.org/download/\n\n\n2.3 软件安装TortoiseGit 安装一路点击“下一步”，使用默认的选项即可\n安装详解：\n\n下一步\n\n\n\n下一步\n\n\n\n客户端选择推荐的 “基于Putty…, 更好的与 windows 集成”，下一步：\n\n\n\n自定义安装路径，下一步：\n\n\n\ninstall，安装\n\n\n\n取消勾选，完成\n\n\n2.4 安装中文语言包中文语言包并不是必选项。可以根据个人情况来选择安装。\n\n点击中文语言语言安装包，直接下一步完成即可\n在 TortoiseGit 的设置中可以选择语言：\n\n\n3、代码托管服务3.1 概述前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。\n知名远程仓库网站gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub\n码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快\nGitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务\n内网仓库gitlab是使用java开发的一个内网仓库\n3.2 创建 GitHub账号访问 github 官方网站https://github.com/，注册账号\n第一步：Sign up\n\n第二步：填入注册信息\n\n账号：24932***8@qq.com\n密码：p***\n用户名：pan0506\n\n\n第三步：注册成功\n选择免费版本，忽略兴趣选项，注册成功后自动登入githhub\n\n注册成功后点击 Create Repository 就可以创建远程仓库了\n3.3 创建gitee账号推荐使用：由于服务器在国内，所以相比于GitHub，码云速度会更快\n访问码云官方网站https://gitee.com/，选择注册：\n\n填入注册信息\n\n用户名：pan0506\n邮箱：343268***@qq.com\n密码：p***\n\n\n3.4 创建Git远程仓库登录成功后即可创建 “我的仓库”\n\n填写仓库名称（其他选项默认即可），点击创建\n\n初始化 readme 文件（可以不需要）：\n\n设置仓库开源：\n\n完成：\n\n每个Git远程仓库都会对应一个网络地址，可以点击克隆&#x2F;下载按钮弹出窗口并点击复制按钮获得这个网络地址：\n\n当前创建的远程仓库对应的地址为：\nhttps://gitee.com/pan0506/my-repo1.git\n3.5 设置其他仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。\n在 【管理】选项 \n→ 仓库成员管理 \n→ 开发者（当前仓库除了创建的人是管理员，其他用户一般都是开发人员） \n→ 添加仓库成员\n→ 邀请用户：\n\n邀请的方式有多种，可以通过链接邀请，也可以直接添加：\n\n注意：\n直接添加可以输入其他用户的个性邮箱或者注册时的用户名（必须是存在的用户）：\n\n点击添加后提交，会将邀请信息发送到对方的用户邮箱，对方同意后，即可参与项目开发，即：代码的下载、修改、推送等操纵\n第三章 GitBash管理文件版本1、 本地仓库操作1.1 初始化本地仓库1.1.1 获取方式获取（初始化）git 仓库的方式有两种：\n\n将尚未进行版本控制的本地目录转换为 Git 仓库\n从其它服务器克隆一个已存在的 Git 仓库（后面演示）\n\n以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓\n1.1.2 命令# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n\n\nLinux 常用命令\n\n清屏命令：clear\n快捷键：Ctrl + L\n重启终端：reset\n\n1.1.3 步骤如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：\n\n在项目目录中，通过鼠标右键打开“Git Bash”\n执行 git init 命令将当前的目录转化为 Git 仓库\n\n在工作空间新建一个 gitRepository 目录，测试 git 操作：\n在当前 gitRepository 目录中新建仓库1：repo1 \n在当前目录 repo1  中右键  →  Git Bash Here，打开 git 命令行窗口\n输入 git init 命令初始化本地仓库\n\n注意：\n\ngit init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，\n里面包含了初始的必要 文件，这些文件是 Git 仓库的必要组成部分。\n.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要轻易修改\n\n概念：\n\n版本库：“.git”目录就是版本库，将来文件都需要保存到版本库中。\n工作目录：包含 “.git”目录的目录，也就是.git目录的上一级目录就是工作目录。\n只有工作目录中的文件才能保存到版本库中。\n\n1.2 配置用户信息1.2.1 签名形式设置自己的用户名和邮件地址（设置签名）。通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作，\n例如：\n\n用户名：pan\nEmail 地址：pan0506@cc.com\n\n注意：\n\n用户名可以和邮箱名称不一致，邮箱也可以是不存在的\n这个签名（用户名和邮箱）的作用：是区分开发人员的身份\n这里的设置的签名和登录远程仓库（GitHub 或 码云）的账号密码没有任何关系，可以是不存在的用户名和邮箱\n\n1.2.2 查看配置项查看配置信息： git config --list\n\n解析：\n\n我们发现这里面并没有用户信息，所以需要我们去配置用户信息\n\n1.2.3 命令用户的信息可以设置为两个级别\n\n仓库级别（也叫项目级别）：仅在当前本地仓库范围有效\n\n命令：\n\ngit config user.name &quot;pan_pro&quot; 命令设置仓库级别用户名（pro表示项目级别）\ngit config user.email &quot;pan0506@cc.com&quot;  命令设置邮箱\n使用  git config --list 或者  cat .git/config  命令查看 配置的信息\n\n\n\n全局范围（也叫系统用户级别）：登录当前操作系统的用户范围\n\n命令：\n\ngit config --global user.name &quot;pan_glb&quot; 设置全局范围用户名（gib表示全局配置）\ngit config --global user.email &quot;pan0506@cc.com&quot;  设置全范围别邮箱\n使用  git config --list 或者 cat ~/.gitconfig：查看当前系统用户家目录（c&#x2F;users&#x2F;cc&#x2F;.gitconfig）中保存的信息。\n\n\n（~ 表示当前系统用户的家目录：c&#x2F;user&#x2F;cc）\n\n1.2.4 签名的优先级就近原则：\n\n项目级别优先于系统用户级别，二者都有时采用项目级别的签名\n如果只有系统用户级别的签名，就以系统用户级别的签名为准\n\n注意：\n\n仓库级别和全局级别，必须存在一个，不允许二者都没有\n\n1.2.5 小结在 linux 系统中，git 的命令都是以 git 开头（主命令），后面跟其他的命令，\n例如：git config，表示配置命令\n还可以在命令后面使用 --添加一些参数，\n例如：git config --golbal，表示全局配置 \n1.3 查看状态（status）1.3.1 准备测试文件在当前目录中新建一个 test.txt 文件用于测试基本操作\n\n1.3.2 命令可以使用 git status 命令查看文件处于什么状态\n\n解析：\n\n没有未追踪文件：\n\non branch master：表示当前在 master 分支上\nno commits yet：没有任何提交\nnothing to commit ：没有可以提交的东西\n(create&#x2F;copy files and use “git add” to track)：使用 git add 命令追踪创建或者复制的文件（即使用 git 管理文件）\n\n有未追踪文件：\n\n Untracked files: 未追踪文件 (use “git add …” to include in what will be committed)：使用git add包含到将要提交的文件（保存到暂存区）    test.txt   ：文件名称\n nothing added to commit but untracked files present (use “git add” to track)：没有添加提交但是有未追踪的文件\n\n\n使用 git status 输出的状态报告很详细，但有些繁琐。\n如果希望以精简的方式显示文件的状态，可以使用 git status -s 或者  git status --short命令，\n其中 -s 是 --short 的简写形式，\n如果有未跟踪文件，前面有红色的 ?? 标记\n\n1.4 跟踪文件1.4.1 添加到暂存区（add）使用命令 git add 开始跟踪文件（即：将文件添加到暂存区），然后查看状态\n\n解析：\n\nChanges to be committed:  改变成将要提交的文件（保存到暂存区的文件）(use “git rm –cached …” to unstage)：可以使用 git rm --cached 取消文件跟踪  new file:   test.txt\n\n1.4.1 取消跟踪（rm）使用命令 git rm --cached 文件名 命令取消跟踪文件（从暂存区删除文件，本地工作区文件还在，不是删除本地文件）\n\n1.5 提交更新（commit）使用 git commit 命令提交文件\n提交的方式有两种\n\ngit commit 文件，进入 vim 编辑器，编辑日志信息\ngit commit -m &quot;message&quot; 文件，在命令中添加日志message，直接提交\n\n1.5.1 第一种方式git commit 文件，进入 vim 编辑器，编辑日志信息\n环境准备：将 test.txt 文件添加到暂存区（跟踪文件）\n\n操作步骤：\n\n输入 git commit test.txt 命令， 进入 vim 编辑器\n\n\n\n进入 vim 编辑器\n\n\n\n在 vim 编辑器中输入提交日志内容\n\n步骤：\n\n:set nu 命令可以显示行号\na  或者 i 命令切换为编辑模式，编辑日志内容\nEsc 退出编辑模式\n:wq + 回车，保存退出\n\n\n\n提交成功信息\n\n\n解析：\n\n[master (root-commit)  e549da4]：表示在master主干根提交\nfirst commit, new file test.txt：提交的日志信息\n1 file changed, 1 insertion(+)：1个文件变化，1行内容（文本中的内容）\n\n\n查询状态\n\n\n解析：\n\nnothing to commit, working tree clean: 没有可以提交的，工作树很干净\n\n1.5.2 第二种方式git commit -m &quot;message&quot; 文件，在命令中添加日志message，直接提交\n环境准备：\n\n修改文件内容（可以手动修改，也可以使用命令修改）\n\n命令修改步骤：\n\nvim test.txt  命令进入文件\n:set nu 命令显示行号\na 命令切换为编辑模式，修改内容\nEsc 退出编辑\n:wq + 回车 保存并退出文件\n\n\n\n修改后查看状态\n\n\n解析\n\nChanges not staged for commit:  没有暂存到可以提交的区域\n(use “git add …” to update what will be committed) ： 使用git add 命令 更新 到准备提交的区域\n(use “git restore …” to discard changes in working directory)  ： 使用git restore 命令取消修改文件\nmodified:   test.txt    修改的文件\nno changes added to commit (use “git add” and&#x2F;or “git commit -a”)   ：可以先add 再commit，也可以直接commit\n\n\n先执行 git add\n\n\n出现了两行警告，解析：\n\nwarning: LF will be replaced by CRLF in test.txt.   行末（换行符）LF 将会被转换为 CRLFThe file will have its original line endings in your working directory  不会修改工作空间的文件行末\n\n\n查看状态\n\n\n解析：\n\nChanges to be committed:  变为可提交的文件(use “git restore –staged …” to unstage)：可以使用 git restore 命令取消跟踪  modified:   test.txt  修改的文件\n\n在命令中添加日志信息，直接提交：\n输入命令： git commit -m &quot;second commit,modify test.txt&quot; test.txt\n\n1.6 综合练习：将java工程提交到版本库1.6.0 需求将 springbootShiro 项目提交到本地仓库，忽略不需要提交的文件\n1.6.1 初始化本地仓库新建 repo2 目录，复制需要版本控制的 springbootShiro 到当前目录，\n执行git init 命令，初始化本地仓库：\n\n1.6.2 忽略文件或目录在此工程中，并不是所有文件都需要保存到版本库中的，\n例如 target 目录是编译后的目录，这个目录及目录下的文件就可以忽略。\nGit解决这个问题很简单，在Git工作区的根目录下创建一个特殊的 .gitignore 文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n步骤：\n\n工作区间的根目录中创建  .gitignore 文件\n编辑内容，填写忽略的文件名称（springbootShiro目录下的target目录）\n\n\n注意文件中的内容：\n\nspringbootShiro/target 表示忽略 springbootShiro 目录下的 taget 文件和 target 目录\nspringbootShiro/target/ 表示忽略 springbootShiro 目录下的 target 目录（不包括 target 文件）\n\n拓展：\n忽略文件语法规范：\n\n\n空行或是以 # 开头的行，即注释行将被忽略。\n\n可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。\n\n可以在后面添加正斜杠 / 来忽略文件夹，例如 build/c 即忽略 build文件夹。\n\n可以使用 ! 来否定忽略，即比如在前面用了 *.apk ，然后使用 !a.apk ，则这个 a.apk 不会被忽略。\n\n* 用来匹配零个或多个字符，如 *.[oa] 忽略所有以 .o或  .a 结尾\n\n*~ 忽略所有以 ~ 结尾的文件（这种文件通常被许多编辑器标记为临时文件）；\n\n[] 用来匹配括号内的任一字符，如 [abc] ，也可以在括号内加连接符，如 [0-9] 匹配0至9的数； \n\n? 用来匹配单个字符。\n\n\n\n看个例子：\n*.a      \t\t// 表示忽略 .a 文件!lib.a   \t\t// 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件/TODO    \t\t// 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODObuild/\t\t\t// 忽略 build/ 文件夹下的所有文件doc/*.txt\t\t// 忽略 doc/notes.txt, 不包括 doc/server/arch.txtdoc/**/*.pdf    // 忽略在 doc/  directory 下的所有的 .pdf 文件 \n\n\n\n\n\n1.6.3 添加到暂存区执行 git add . 命令，添加当前目录下的所有文件（夹）\n\n git add . 命令 表示添加当前目录下的所有文件（夹）添加到暂存区\n 注意：也可以进入到指定目录（cd  springbootShiro）执行 git add . 命令\n\n\n查看 springbootShiro 目录发现，target 目录已经被忽略，没有添加到暂存区\n\n1.6.4 提交到本地仓库执行git commit -m &quot;日志信息&quot; 命令提交\n\n提交命令不使用文件名称，默认提交当前所有暂存区的文件\n\n\n查看 springbootShiro 目录，发现此时 target 目录是被忽略的，没有提交到本地仓库：\n\n2、远程仓库操作回顾Git工作流程\n前面通过命令或者 TortoiseGit 操作的都是本地仓库是，接下来我们要操作远程仓库，示意图：\n一般工作流程如下：\n\n从远程仓库中克隆 Git 资源作为本地仓库。\n\n从本地仓库中 checkout 代码到工作区，然后进行代码修改\n\n在提交前先将代码提交到暂存区。\n\n提交到本地仓库，本地仓库中保存修改的各个历史版本。\n\n在修改完成后，需要和团队成员共享代码时，可以将代码 push 到远程仓库（git仓库）。\n\n\n下图展示了 Git 的工作流程：\n\n2.1 克隆远程仓库克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。\n可以通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地\n在存放的目录中打开 GitBash 窗口，输入命令：git clone 远程仓库地址：\n\n2.2 查看远程仓库如果想查看已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字\ngit remote 命令：在克隆的仓库中查看远程仓库服务器名称：\n\n解析：\n\n前面，我们克隆了远程仓库 myRepo1 到本地，其实这个远程仓库和本地仓库已经建立起关联关系，\n在这个克隆的远程仓库中执行 git remote 命令就能查询当前本地仓库和哪个远程仓库服务器（默认名称origin）建立了关联\n\ngit remote -v 命令可以列出远程仓库地址信息：\n\n解析：\n\n通过这个命令列出了远程仓库的地址信息\nfetch：表示获取远程仓库链接的地址，即：可以从远程仓库获取代码\npush：表示推送本地仓库代码到远程仓库的地址，即：可以将本地仓库的代码推送到远程仓库\n\n如果我们想要查看更详细的信息，可以使用 git remote show origin\n\n**注意：**如果是本地仓库没有和远程仓库建立关联，那么输入查看命令是没有信息显示的，例如在前面我们自己创建的本地仓库 repo1 中查看：\n\n2.3 添加远程仓库对于我们本地创建的Git仓库 repo1，是没有和远程仓库建立联系的，我们可以添加到指定的远程服务器上\ngit remote add &lt;shortname&gt; &lt;url&gt; 命令：添加一个新的远程 Git 仓库，同时指定一个可以引用的简写，\n示例：将本地仓库 repo1 添加到远程仓库（即：将本地仓库关联到远程仓库）\n在码云上新建一个远程仓库repo1（远程仓库和本地仓库名称可以不一致，但是建议保持一致）：\n\n创建后，初始化 readme 文件和 设置为开源仓库\n\n在本地仓库 repo1 中打开 GitBash，执行git remote add &lt;remote-name&gt; &lt;url&gt; 命令:\n\nshortname：通常使用默认的 origin，也可以自定义名称\nurl：远程仓库的地址\n\n\n添加成功后，就能查询到远程仓库的信息了\n练习：创建远程仓库 repo2，并将本地仓库 repo2 添加到该远程仓库\n2.4 拉取远程仓库代码：git pull从远程仓库拉取代码的命令有两个：get pull  和 get fetch\ngit pull &lt;remote-name&gt; &lt;branch-name&gt; 命令：是从远程仓库的指定分支获取最新版本并 merge（合并）到本地仓库\n注意：\n\n如果，当前本地仓库有文件，那么从原仓库拉取文件会报错：\nfatal: refusing to merge unrelated histories \n\n\n解析：\n\n因为本地仓库有文件，从远程仓库拉取文件下来，可能会覆盖当前的文件，所以拉取失败\n\n解决方式：\n\n在拉取的命令后面添加参数选项：–allow-unrelated-histories\n表示强制拉取，并合并到本地仓库\n\n执行强制拉取并合并到本地的命令后会进入到日志界面，不需要填写日志的话直接:wq! 保存推出即可\n\n拉取成功：\n\n2.5 拉取远程仓库代码：git fetch环境准备：将本地仓库 repo1 删除，重新初始化，并关联远程仓库repo1\n\ngit fetch 或者 git fetch origin master 命令：从远程仓库抓取文件\n\n执行完命令抓取命令后，远程仓库的的文件已经以二进制的文件形式抓取到本地仓库（.git 目录下的 objects 目录中）\n但是不会 merge 到本地工作空间（即：没有合并到工作空间中，不会显示）\n\n\n上面抓取的结果我们可以看到抓取到的分支是 origin&#x2F;master，\n需要执行 git merge origin/master 命令 ，将同步到本地仓库的文件 merge（合并）到本地工作空间\n\npull 和 fetch 的区别：\n\n\ngit pull 命令相当于  git fetch + git merge 两个命令的结合\n\n建议使用 git fetch 命令获取远程仓库文件，因为：\n\n\ngit fetch是将远程主机的最新内容拉到本地，用户检查后决定是否合并到分支中，而git pull则是将远程主机的最新内容拉下来直接合并即：git pull &#x3D; git fetch + git merge，可能产生冲突需要手动解决 \n\n当本地仓库存在文件时，从远程仓库拉取数据会报错，解决方式：\n\n添加：–allow-unrelated-histories 参数\n\n2.6 移除远程仓库日常工作中：可能会因为一些原因想要移除一个远程仓库 \n注意：移除远程仓库只是从本地移除远程仓库的记录，并不会真正影响到远程仓库\n可以使用 git remote rm &lt;remote-name&gt; 命令移除远程仓库\n\n2.7 推送到远程仓库前面我们将本地仓库 repo2 关联到远程仓库后，本地仓库中的文件并没有推送到远程仓库中\n推送本地仓库的文件到远程仓库之前要先拉取远程仓库的代码，这里我们的本地仓库有文件，所以需要先强制拉取文件：\n\n强制拉取命令：git pull origin master --allow-unrelated-histories\n\n\n通过git push &lt;remmote-name&gt; &lt;branch-name&gt; 命令将本地仓库的文件推送到远程仓库：\n\n第一次推送的时候需要输入码云的用户名和密码\n\n\n推送成功，本地仓库的文件和目录已经同步到了远程仓库中：\n\n小结：\n\n修改本地文件后，可以通过git push &lt;remmote-name&gt; &lt;branch-name&gt; 命令来同步到远程仓库\n\n3、Git 分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。\n3.1 查看分支分支有两种，一种是本地仓库分支，另一种是远程仓库的分支\n接下来操作 repo2 仓库，来查看分支：\n查看分支的命令：\n\ngit branch 命令：列出所有本地分支\ngit branch -r 命令：列出所有远程分支\ngit branch -a 命令：列出所有本地分支和远程分支\n\n效果如下：\n\n3.2 创建分支创建本地仓库分支，后面可以推送到远程仓库：\n命令：\n\ngit branch &lt;branch-name&gt; 命令：在本地仓库创建一个分支\n\n\n解析：\n\n上面的命令创建了两个分支：a1、a2，加上默认创建的 master 分支，查询结果有三个分支\n\n3.3 切换分支命令：\n\ngit checkout &lt;branch-name&gt; 命令：切换到指定的分支\n\n\n解析：\n\n上面的命令将当前的分支从 master 切换到 a1 分支\n查看分支：标 * 号的分支表示当前分支，或者通过行末括号中的名称也能分辨当前属于哪个分支\n\n3.4 推送至远程仓库分支命令\n\ngit push &lt;remote-name&gt; &lt;branch-name&gt; 命令：将本地分支推送至远程仓库分支\n\n\n练习：将 a2 分支推送到远程仓库分支\n解析：\n\n查看远程仓库中的 a1、a2分支，我们发现，a1、a2分支中的内容和 master 分支中的内容一样，\n原因： a1、a2 分支是在 master 分支的基础上创建出来的，随着我们在不同的分支上开发，修改内容，不同分支的代码会产生差异\n\n3.5 合并分支命令：\n\ngit merge &lt;branch-name&gt; 命令：将指定分支的内容合并到当前分支\n\n例如我们当前在 a1 分支下新增了一个文件 user.txt\n\n当我们切换到 master 分支后发现，master 分支下并没有 User.txt\n\n在当前 master 分支下，执行 git merge a1 命令即可将 a1 分支的文件合并到当前 master 分支下：\n\n注意：\n有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 在合并的时候就会提示会提示文件冲突，合并失败；\n此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决\n示例：\n在 master 分支下修改 User.txt 文件 → 添加缓存区  → 提交到本地仓库：\n\n切换到 a1 分支，修改 User.txt 文件 → 添加缓存区  → 提交到本地仓库：\n\n切换回 master 分支，将 a1 分支合并到 master 分支：\n\n解析：\n\nCONFLICT (content): Merge conflict in User.txt \t\t【表示合并内容发生冲突】Automatic merge failed; fix conflicts and then commit the result.\t\t【自动合并失败】\n行末的分支  (master|MERGING)  表示 master 分支在合并时发生错误\n\n打开 User.txt 查看内容发现，在合并时这里面多了很多多余的内容\n\n需要我们手动解决冲突内容（删除不需要的内容，保留需要内容），然后添加暂存区，提交到本地仓库即可：\n\n3.6 推送到远程将我们在本地仓库分支修改或者添加的文件推送到远程分支中：\n命令：\n\ngit push &lt;remote-name&gt; &lt;branch-name&gt; 命令：将本地分支的内容推送到指定远程分支\n\n\n查看远程仓库的分支，验证推送成功\n3.7 删除分支删除本地分支命令：\n\ngit branch -d &lt;branch-name&gt; 命令：删除指定的分支\n\n\n如果要删除的分支中进行了一些开发动作（比如修改了文件没有推送到远程仓库中），此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D\n示例：\n\n此时：本地仓库 a1 分支修改的内容没有推送到远程仓库，不能直接通过 git branch -d &lt;branch-name&gt; 命令直接删除 a1 分支，可以将命令中的-d参数改为-D 强制删除；\n切换到 master 分支删除 a1：\n\n如果要删除远程仓库中的分支，可以使用命令\n\ngit push &lt;remote-name&gt; –d &lt;branch-name&gt; 命令：可以删除指定的远程仓库：\n\n\n执行命令后查看远程仓库分支，验证删除成功\n4、Git 标签像其他版本控制系统（vcs）一样，GIt可以给历史中某一个提交打上标签，以示重要；比较有代表的就是使用这个功能来标记发布节点（v1.0，v2.0 等）；\n标签指的是某个分支某个特定时间点的状态，通过标签，可以很方便的切换到标记时的状态\n4.1 列出已有标签命令：\n\ngit tag 命令：列出当前标签\n\n示例（当前本地仓库还没有标签）：\n\n4.2 创建标签命令：\n\ngit tag &lt;tag-name&gt; 命令：用来创建一个标签\n\n示例：创建两个标签\n\n标签的作用是用来记录状态（版本）的，所以通常使用 v 开头来标签\n\n\n 也可以通过\n\ngit show &lt;tag-name&gt; 命令：来显示标签的详细信息\n\n\n解析：\n\n详细信息中列出了：提交的标识字符串、作者（用户）信息、提交的日期信息等等\n\n4.3 推送到远程仓库和前面的推送分支命令类似：\n\ngit push &lt;remote-name&gt; &lt;tag-name&gt; 命令：将指定本地标签推送到远程仓库\n\n\n注意：\n\n当前 v1.0 和 v1.1 两个标签标记的内容是一样的\n\n4.4 检出标签通常情况下会新建一个分支，指向某个标签：\n\ngit checkout -b &lt;branch-name&gt; &lt;tag-name&gt; 命令：用于创建一个新的分支，并检出指定标签到这个分支\n\n\n执行完命令后会切换到创建的 a3 分支，这个分支的内容就是前面 v1.0 版本的内容，在这个版本中我们可以继续开发，例如：添加 login.txt 文件：\n\n开发完成后，可以再创建一个标签，标记为 v2.0 版本，提交到远程仓库\n\n小结：\n\n标签通常再一些重要的节点使用，例如发布的时候，下次更新或者升级完成后发布的时候…\n\n4.5 删除标签删除标签分为删除本地标签和远程标签：\n\ngit tag -d &lt;tag-name&gt; 命令：用于删除指定的本地标签；\ngit push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; 命令：用户伤处指定的远程标签，                              \n注意：语法中 :refs/tags/ 是固定写法\n\n \n第四章 TortoiseGit管理文件版本1、本地仓库操作1.1 初始化本地仓库新建仓库3：repo3，在目录中右键选择：”Git create repository here…” (在这里创建版本库)\n\n默认不勾选：”Make it Bare(No working directories)” （表示：制作纯版本库）\n\n初始化本地仓库成功：\n\n1.2 添加文件当前工作目录中新增一个 aaa.txt 文件\n\n选中文件，右键 → TortoiseGit  → Add\n\n添加成功：\n\n添加（到缓存区）成功后，文件会有一个蓝色 + 号：\n\n1.3 提交文件选中已追踪（添加到缓存区）的文件，右键选择 Git commit → &quot;master&quot;... 将文件提交到版本库中：\n\n填写提交日志信息，点击 commit 按钮提交：\n\n提交成功后，文件的状态为绿色√号\n1.4 修改文件被版本库管理的文件不可避免的发生修改，此时只需要直接对文件修改即可，修改完毕后需要将修改的文件提交到版本库。\n修改文件（修改后文件会变为红色感叹号）：\n\n选中修改后的文件，右键提交：\n\n添加提交日志信息，提交：\n\n提交成功成功后，文件状态由红色 ! 号变为绿色 √ 号。\n1.5 查看修改历史在开发过程中可能会经常查看代码的修改历史，或者叫做修改日志。来查看某个版本是谁修改的，什么时间修改的，修改了哪些内容。\n可以选中文件，右键选择 “show log（显示日志）” ：\n\n查看修改历史：\n\n1.6 差异比较当文件内容修改后，需要和修改之前对比一下修改了哪些内容，此时可以使用“比较差异功能”\n修改文件内容：\n\n选择” Diff（比较差异）”\n\n对比修改后的内容：\n\n1.7 还原修改当文件修改后不想把修改的内容提交，还想还原到未修改之前的状态。\n此时可以使用 “Revert（还原）” 功能\n\n点击 “Ok” 还原\n\n还原成功！\n注意：\n\n此操作会撤销所有未提交的修改，所以做还原操作是需要慎重慎重！！！\n\n1.8 删除文件需要删除无用的文件时可以使用git提供的删除功能直接将文件从版本库中删除。\n\n1.9 综合练习：将java工程提交到版本库将 springbootShiro  工程复制到工作区中，提交到版本库中，并且忽略 target 目录\n1.9.1 忽略文件或目录选中要忽略的文件&#x2F;目录，右键 → TortoiseGit →  add to ignore list （添加到忽略列表）\n\n选择 忽略的类型和  .gitignore 文件存放的位置（默认即可）：\n\n完成后在工作空间的根目录多出一个.gitignore文件，这个文件就是文件忽略文件，当然也可以手工编辑。其中的内容就是把 springbootShiro 中的 target 目录忽略掉。\n\n1.9.2 添加暂存区将工程和忽略文件添加到暂存区：\n\n勾选需要添加的文件（这里默认全选），点击ok\n\n点击ok，完成暂存区添加\n1.9.3 提交代码先将 选中项目 和 .gitignore 文件\n右键然后提交代码：\n\n提交成功后查看工程里面的文件，发现 target 目录没有提交到版本库\n\n输入提交日志，点击 commit 提交按钮\n\n查看 springbootShiro 目录，验证 target 目录是否被忽略\n2、远程仓库操作2.1 克隆远程仓库克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。\n在码云上创建一个远程仓库 myRepo2（readme初始化，开源仓库）：\n\n在存放目录中右键 → Git clone…，复制远程仓库的地址到 URL 选项中 → Ok:\n\n克隆成功：\n\n2.2 查看远程仓库在克隆的仓库中右键 → TortoiseGit → settings\n然后，在设置的 Remote 中可以看到远程仓库服务器名称，点击名称，显示远程仓库地址：\n\n2.3 添加远程仓库同样我们，也可以通过 TortoiseGit  将本地仓库添加到远程仓库：\n在码云新建远程仓库： repo3\n\n在本地仓库 repo3 中右键 → settings\n然后在 Remote 中填入名称和 URL → 确定即可：\n\n名称自定义，通常使用 Origin \nurl：远程仓库地址\nPush Url：远程仓库地址（暂时可以不填写）\nPutty Key：这里使用 https 协议传输，不需要填\n\n\n“是否从新添加的远程服务器获取分支” ，选 “是”\n\n默认ok\n\n成功后 close\n\n完成后可以使用 GitBash 命令查看，验证是否添加成功\n2.4 推送到远程仓库将本地仓库的文件推送到远程仓库\n→ 在工作区间中右键 TortoiseGit → push  推送\n\n→ 填写要推送到哪个分支 → ok\n\n出现异常：\n\n异常原因解析：\n在推送的之前要先拉取远程仓库的代码，以防止覆盖，我们的本地仓库有文件，所有要强制拉取，可以使用 git 命令强制拉取（快速简单）\n\n然后重新推送：\n\n到远程仓库查看，验证是否推送成功\n\n2.5 TortoiseGit拉取右键 TortoiseGit → pull → Ok\n\n注意：\n\n如果本地仓库有文件，在使用 TortoiseGit 拉取文件时，同样可会报错\n可以使用 GitBash 的命令强制拉取后，再使用 TortoiseGit 操作（使用 git 命令的方式解决方便快速）\n\n2.6 移除远程仓库在本地仓库的工作空间右键 → TortoiseGit → Settings \nRemote → 选中远程服务器名称（origin） → remove → 确定：\n\n移除之后，可以只用 GitBash 的查看命令，验证是否移除\n3、分支操作上面如果将本地仓库repo3 的远程仓库移除了，这里需要重新添加上，演示本地仓库和远程仓库的分支操作\n3.1 创建分支右键 → TortoiseGit → Create Branch… （创建分支）\n\n填写分支名称，选择分支状态：Base on（默认基于 master 分支，创建出来的分支和 master 分支状态一致）\n\n3.2 切换分支右键 → TortoiseGit → Switch&#x2F;Checkout… （切换分支）\n\n选择分支 → Ok 即可切换\n\n切换后的操作和之前命令操作是一样的\n3.3 合并分支在房前 master 分支下右键 → TortoiseGit → merge… （合并分支）\n\n选择要合并的分支 → Ok 即可\n\n3.4 推送到远程仓库选择 push 选项：\n\n选择要推送的分支，定义远程分支的名称（一般和本地分支名称保持一致）\n\n推送成功后可以在远程仓库查看\n\n4、标签操作略\n第五章 在 idea 中使用 Git在实际开发中，我们都是在开发工具 idea 中开发的，在开发完成之后可以直接在 idea 中完成 git 的相关操作，比如提交代码、推送到远程仓库等等。\n1、配置Git老版本的 IntelliJ IDEA 如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径；\n最新版本会帮我们自动找到 Git 的安装路径；\n点击Test 按钮 测试是否正确配置，如果是正确的则会提示安装的 Git 的版本信息\n\n2、创建工程并添加至Git环境准备：\n创建一个新的 Module：gitTest（maven版的普通Java项目即可）：\n\n添加一些开发的内容：\n\n将当前项目添加到 Git 其实就是在项目的根目录下添加 git 仓库：\n\n在 Idea 上方的 VSC 选项中选择： VCS Operations（VCS 操作）\n\n→ Create Git Repository… \n\n→ 选择当前项目的根目录（注意是在src 同级目录，即：在 gitTest 目录创建git仓库）：\n\n在目录中查看，验证成功创建 git 仓库：\n\n此时，项目根目录下的文件还没有交给 git 版本控制管理\n\n\n将项目添加至Git管理后，可以从IDEA的工具栏上看到Git操作的按钮：\n\n3、忽略文件和目录在当前项目的根目录下创建 .gitignore 文件，把需要忽略的文件和目录编辑进去：\n\n我们可以使用 maven 编译一下当前项目，就会出现 target 目录，可以更好的看到后面添加和提交等效果：\n\n4、添加到暂存区其实 IDEA 可以不需要添加到暂存区直接提交的（简化了步骤），\n如果我们需要添加到暂存区可以右键当前项目 → GIt 选项 → Add ：\n\n在目录中可以看到允许被提交的文件状态变为 + 号了，即添加到了暂存区：\n\n5、提交文件提交的方式地方有很多：\n可以右键项目 → Git 选项 → Commit…\n\n也可以使用 Git 按钮提交：\n\n还可以在 VCS 中选择 Commit…\n\n这些提交的效果是一样的，在弹出的对话框中添加提交日志信息 →  commit：\n\n如果需要看到目录，可以在提交界面的 Group by 按钮中勾选 Model 和 Directory：\n现在项目中添加一个 配置文件 jdbc.properties，再次提交，勾选 Model 和 Directory 后可以看到要提交的文件在哪个目录中：\n\n6、推送到远程仓库在码云创建一个新的远程仓库 gitTest：\n\n这里不初始化 readme 文件，不然后面需要解决第一此推送或拉取，本地仓库有文件冲突，需要强制拉取解决冲突\n\n\n在idea 中右键项目 → Git → Push\n或者 VCS 中 push\n或者 找到 Push 按钮：\n\n选择定义 Define remote（远程仓库），添加远程仓库地址：\n\n点击 push 推送本地仓库到远程仓库：\n \n推送成功后查看远程仓库：\n\n7、从远程仓库克隆工程到本地选择从VCS 克隆工程：\n\n\n填写远程仓库地址，选择保存路径：\n\nTrust Project：\n\n克隆成功：\n\n8、从远程拉取代码我们可以打开前面 gitTest 项目\n\n因为这两个本地仓库都是关联的同一个远程仓库，所以可以模拟两个用户操作同一个项目：\n\n注意区分两个本地仓库，前面我们自己创建的叫 gitTest， 后面克隆下来的叫 git-test\n\n\n在 gitTest 项目中：\n添加 UserService 接口：\n\n→ 提交到本地仓库：\n\n→ 推送到远程仓库：\n\n查看远程仓库，推送成功：\n\n在 git-test 项目中：\n点击 Update Project 选项拉取代码到本地，或者点击选择 Pull 选项也可以将远程仓库的代码拉取到本地：\n\n练习：\n在 gitTest 项目中修改 jdbc.properties 文件的内容，并推送到远程仓库\n在 git-test 项目中拉取远程仓库中修该的内容\n9、版本对比每一次提交都都会产生新的版本，我们可以使用 idea 来比较不同的版本文件的区别：\n例如我们想要查看  jdbc.properties 文件不同版本的区别：\n打开  jdbc.properties 文件，在文件中右键 → Git 选项 →  Compare with Revision…（比较版本信息）：\n\n选择一个版本比较差异：\n\n为了看到效果，我提交了两次，\n第一次提交 jdbc.username \n第二次提交 jdbc.userpassword\n\n\n左边是选择的版本内容，右边是最新的内容：\n\n10、创建分支可以在 VCS 中 选择  New Branch… 选项来创建分支：\n\n填写要创建的分支名称：\n\n勾选 Checkout branch 表示创建 a1 分支，并且切换到 a1 分支:\n\n\n创建并切换成功：\n\n切换成功以后代码没有变化，是因为当前 a1 分支和 master 分支的状态是一样的\n11、切换分支可以在底部 Git 选项中，右键想要切换的分支，选择 Checkout 切换分支\n\n也可以在顶部 VCS 中选中 Branchs…  选项，找到想要切换的分支，然后 Checkout 即可：\n\n12、分支合并我们可以在 b1 分支上开发，提交并推送到远程仓库，然后在 master 分支上操作，将 b1 分支合并到 master 分支：\n在 b1 分支中的  User 类中添加 username 属性：\n\n提交并推送到远程仓库（可以同时操作）：\n\n推送到远程仓库：\n\n切换到 master 分支，此时的 User 用户是没有 username 属性的：\n\n在顶部 VCS 中选中 Merge…  选项:\n\n选择合并本地的 a1 分支即可（origin&#x2F;a1 是远程的分支）：\n\n合并成功：\n\n第六章 使用 SSH 协议传输数据1、Git 支持的传输协议由于 Git 的远程仓库不在本地，当我们在使用远程仓库时（例如克隆、拉取、推送）就会涉及到数据的网络传输，Git 支持多种数据传输协议：\n\n本地协议（Local）\nHTTPS 协议\nSSH（Secure Shell）协议\nGit 协议\n\n我们前面的操作都是基于 HTTPS 协议传输的，而码云支持两种传输协议：\n\n2、什么是 SSH 协议SSH 是 Sercure Shell（安全外壳协议）的缩写，由 IETE 的网络小组（Network Working Group）制定；\nSSH 是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议；利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题\n由于本地 Git 仓库和远程仓库之间的传输是通过 SSH 加密的，所以必须要让远程仓库服务器认证你的 SSH key，在此之前，必须要先生成 SSH key；\n使用 SSH 协议通信时，推荐使用基于密钥的验证方式，我们需要先为自己创建一对密钥（公钥和私钥），并将公钥放在需要访问的服务器上。\n解析：\n其实前面我们使用 https 协议传输的时候，它是基于我们码云的账户和密码验证的，我们后面的操作之所以不需要每次输入用户名和密码，是因为第一次操作时验证了用户名和密码，然后将用户名和密码凭证保存在了我们的计算机上，我们可以查看到：\n控制面板 → 用户账户 → 管理 Windows 凭据\n\n普通凭据中就可以看到，我们的 码云账户和密码永久保存在了计算机上：\n\n3、生成密钥在使用密钥之前我们可以尝试复制一个 SSH 协议的远程仓库地址克隆远程仓库，结果肯定是不行的\n前面我们了解了 Https 协议是基于用户名和密码验证的，而 SSH 协议传输数据是基于一对密钥验证的，所以我们要给自己生成一对密钥\n可以使用 GitBash 工具生成公钥和私钥：\n任位置打开 GitBash，执行命令：\n\nssh-keygen -t rsa 命令：生成公钥和私钥\n一路回车，执行完成后后 windows 本地用户 .ssh 目录中生成如下名称的公钥和私钥\n\n\n4、服务器配置公钥私钥就保存在当前用户的 .ssh 目录中即可，我们需要将公钥的内容复制下来，在远程仓库中配置公钥：\n复制公钥内容：\n\n码云配置公钥：\n右边账户信息下拉框，选择 设置：\n\n在安全设置中，选择 SSH公钥，粘贴公钥 → 确定：\n\n验证账户密码后，添加成功：\n\n5、使用 SSH 协议当我们在服务器添加好公钥之后，就可以使用 SSH 协议传输数据了：\n复制远程仓库的 SSH 地址：\n\n使用 SSH 协议克隆远程仓库到本地：\n\n第七章 常用命令查询1、新建代码库 git init\n创建（初始化）空仓库，由git接管，文件的改动（修改、删除）都能监测到\n例外情况：doc等办公文档可以监测到文件大小改变，无非监测到具体内容改变无法监测到二进制文件内部内容信息的改变，只能监测文件大小改变所以说git比较适合纯文本类文件版本控制（txt,md）\n\n常见的二进制文件：\n图片、视频、音频、办公文档（doc、xls）\n# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n\n什么是本地仓库？\n\n在你的电脑通过git init就是初始化了一个本地仓库\n\n\n什么是远程仓库？\n\n就是你在gitee或者github等在线开源网站里面创建一个仓库称为远程仓库\n\n\n什么是工作区？\n\n就是你写作的文件目录，这里面我们称为工作区\n\n\n什么是暂存盘？\n\n什么是版本库？\n\n\n2、配置 git configGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;\n\n\n\n3、增加&#x2F;删除文件 git add&#x2F;git rm# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .$ git add -A # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n\n\n\n4、代码提交 git commit# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n\n提交一个版本的步骤\n先看是否存在仓库，没有使用git init 创建仓库\n\ngit add 添加到暂存盘\n\ngit commit 提交一个版本\n\n\ngit commit –amend 的作用用于修改最近一次的提交，包括：\n\n修改提交信息（commit message）\n添加遗漏的文件到上一次提交中\n修改提交的内容（比如你刚提交完，发现漏改了一行代码）\n\n⚠️ 注意：只能修改尚未推送到远程仓库的最新提交。如果已经推送，修改后需要强制推送（git push --force），这可能影响协作，需谨慎！\n5、分支#修改主分支名为main git config --global init.defaultBranch main# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n\n\n6、标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]\n\n git show\n \n7、查看信息 status,log,reflog,blame,show,diffgit status\n查看状态\n\n可以查看\n\n那些文件被修改了？\n增加了那些文件？\n删除了那些文件？\n是否有修改？（提交了版本之后）\n\n\n对于二进制类型文件，只能监测文件是否被修改，或者被删除，具体改了什么不清楚\n\n比如doc文件、git只能知道它被修改了，不知道改了什么内容\n除了doc还有mp4、jpg、gif等等非文本文件。\ngit diff\ngit diff [file]显示暂存区和工作区的差异\n\ngit diff –cached [file]或者git diff –staged [file]\n\n\n显示暂存区和上一次提交(commit)的差异\ngit show\ngit show命令是Git的一个强大命令，它用于显示Git仓库中的各种对象的详细信息。这些对象可以是提交、分支、标签、或者具体的文件。\n\ngit blame\ngit blame 是Git 命令，用于显示文件中每行代码的最后修改版本及作者信息，帮助追踪代码变更历史。\n\n运行 git blame &lt;文件路径&gt; 可显示指定文件的每行代码最后一次修改的提交信息（作者、时间、代码内容）。\n\n例如：git blame app.js\n\n\ngit stash\ngit stash是git中用于临时保存工作目录和暂存区未提交的修改的命令，允许用户切换到干净的工作区处理其他的任务，后续可以恢复这些修改\n\n保存修改，将所有未提交的更改存入栈，恢复工作区至最新状态。\n\n查看条目 git stash list 列出所有储藏条目（如stash@{0}为最新）\n\n恢复修改：git stash pop：应用并删除最新的储藏条目\n\n\ngit stash apply ：应用指定条目但不删除\n\n删除条目：git stash drop  移除指定条目\n\n测试步骤\n\n\ngit clone 远程仓库hello9-15\n\n\n\n再本地工作区随便修改一下（注意不要添加暂存和保存版本）\n\n\n\n然后再远程仓库手动修改一下1.txt文件，并提交一个版本\n\n\n\n然后执行git pull拉起远程仓库的数据，发现报错了，拒绝拉起\n\n\n\n此时使用git stash将工作区存储起来\n\n\n\n然后再使用git pull拉去，这个时候允许拉去了\n\n\n\n然后想起恢复刚才的内容，使用git stash list 查看，使用git stash pop恢复\n\n\n\n手动解决冲突，git add -A\n\n\n\n完成\n\n\n\n\n\n# 显示有变更的文件$ git status\t#查看状态# 显示当前分支的版本历史(看历史版本到当前版本的日志)$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交(查看所有历史版本信息)#注意这里查看的是一个短的版本号，例如 da213db$ git reflog\n\ngit blame\n \n8、远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n\n\n\ngit pull# -u选项安全模式git push -u origin main\n\ngit pull 和 git fetch 的区别：git fetch 和 git pull 都用于从远程仓库获取最新数据，但它们的行为有本质区别：\n\n✅ git fetch —— 仅下载，不合并\n作用：从远程仓库下载最新的提交、分支、标签等对象到本地仓库，但不会自动合并或修改你当前的工作区和分支。\n\ngit fetch origin\n\n\n下载远程所有更新（如 origin/main, origin/feature 等），存储在本地的远程跟踪分支（如 origin/main）。\n你的本地分支（如 main）不会被改动。\n你可以先用 git log、git diff 查看远程变更，再决定是否合并。\n\n🔹 安全！推荐在不确定远程变更内容时使用。\n📌 示例：\ngit fetch origingit log main..origin/main   # 查看远程有而本地没有的提交git diff main origin/main   # 查看具体差异git merge origin/main       # 手动合并（可选）\n\n\n✅ git pull —— 下载 + 自动合并\n作用：git fetch + git merge 的组合命令。它会先从远程拉取最新数据，然后自动尝试合并到你当前所在的本地分支。\n\ngit pull origin main# 等价于：git fetch origingit merge origin/main\n\n\n如果远程和本地没有冲突，会自动快进（fast-forward）或创建合并提交。\n如果有冲突，会暂停并提示你手动解决冲突。\n\n⚠️ 可能直接修改你的工作区！在未保存或未提交本地修改时容易出问题。\n\n刷新远程仓库——成功上传同步\n \n \n9、撤销修改工作区撤销修改\n\n在工作区修改了文件\n\n\n\n\n使用git status 查看那些文件被修改了\n使用git checkout – 被恢复的文件\n\n$ git status$ git checkout – readme.txt   &#x2F;&#x2F; 或者   git restore readme.txt\n暂存盘撤销修改\n\n在工作区修改了文件\n\n\n\n\n将被修改了文件添加到暂存盘\n使用git status查看那些文件被修改了\n使用git reset HEAD 被恢复的文件\n使用git checkout – 被恢复的文件\n\n方法1\n$ git status$ git reset HEAD readme.txt$ git checkout -- readme.txt\n\n方法2\ngit restore --staged readme.txtgit restore readme.txt\n\n注意：先修改一下文件，然后使用git add 将修改过后的文件添加到暂存盘，然后做上面的练习\n版本回退\ngit reset –hard HEAD^   回退上一个版本\n\ngit reset –hard 版本号可以使用git reflog 查看版本号\n\ngit revert 通过用一次新的commit来回滚之前的commit\n\n操作步骤\n\n\n\n\n初始化一个仓库，并且新建1.txt\n在1.txt中输入111，提交版本1\n在1.txt中输入222，提交版本2\n执行git revert HEAD 撤销最后操作生成新的版本\n也可以撤销指定的版本生成新版本\n\n\ngit revert 和 git reset的区别\n\ngit revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n\ngit reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n\n\n\n\n删除文件撤销注意只要这个文件添加过一次版本，那么你将永远无非删除它。\n\n\n在工作区永久性删除文件\n\n\n\n\n使用git checkout – 被删除的文件或者 git restore 被删错的文件\n\n$ rm readme.txt                           rm 删除文件的意思 (linux命令)$ git checkout – readme.txt        恢复文件\n\nrm  linux下删除命令\nmkdir  linux下创建文件夹命令\ngit rm 不但会把工作区里面的文件删除，还会把版本库里面的文件也删除，做到彻底移除掉这个文件\n\n# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n\n回退到上个版本\ngit reset –hard HEAD^\n\n–hard  一种模式，表示完整恢复数据HEAD   表示当前的^          回退一个版本，^^表示上一个的上个版本\n回退到指定的版本\ngit reset –hard 版本号\n\n版本号可以通过git reflog来查\ngit stash \n克隆码云仓库\ngit stash\ngit stash list\ngit pull\ngit stash pop\n保留双方修改\ngit add -A\n \n10、其他# 生成一个可供发布的压缩包$ git archive\n\n\n\n\n\n11、小结$ git init                                                  # 初始化本地git仓库（创建新仓库）$ git config --global user.name &quot;xxx&quot;                       # 配置用户名$ git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件$ git config --global color.ui true                         # git status等命令自动着色$ git config --global color.status auto$ git config --global color.diff auto$ git config --global color.branch auto$ git config --global color.interactive auto$ git config --global --unset http.proxy                    # remove  proxy configuration on git$ git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库$ git status                                                # 查看当前版本状态（是否修改）$ git add xyz                                               # 添加xyz文件至index$ git add .                                                 # 增加当前子目录下所有更改过的文件至index$ git commit -m &#x27;xxx&#x27;                                       # 提交$ git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）$ git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步$ git rm xxx                                                # 删除index中的文件$ git rm -r *                                               # 递归删除$ git log                                                   # 显示提交日志$ git log -1                                                # 显示1行日志 -n为n行$ git log -5$ git log --stat                                            # 显示提交日志及相关变动文件$ git log -p -m$ git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容$ git show dfb02                                            # 可只用commitid的前几位$ git show HEAD                                             # 显示HEAD提交日志$ git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本$ git tag                                                   # 显示已存在的tag$ git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag$ git show v2.0                                             # 显示v2.0的日志及详细内容$ git log v2.0                                              # 显示v2.0的日志$ git diff                                                  # 显示所有未添加至index的变更$ git diff --cached                                         # 显示所有已添加index但还未commit的变更$ git diff HEAD^                                            # 比较与上一个版本的差异$ git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异$ git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的$ git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容$ git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）$ git branch                                                # 显示本地分支$ git branch --contains 50089                               # 显示包含提交50089的分支$ git branch -a                                             # 显示所有分支$ git branch -r                                             # 显示所有原创分支$ git branch --merged                                       # 显示所有已合并到当前分支的分支$ git branch --no-merged                                    # 显示所有未合并到当前分支的分支$ git branch -m master master_copy                          # 本地分支改名$ git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出$ git checkout -b master master_copy                        # 上面的完整版$ git checkout features/performance                         # 检出已存在的features/performance分支$ git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支$ git checkout v2.0                                         # 检出版本v2.0$ git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出$ git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）$ git merge origin/master                                   # 合并远程master分支至当前分支$ git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改$ git push origin master                                    # 将当前分支push到远程master分支$ git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支$ git push --tags                                           # 把所有tag推送到远程仓库$ git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支$ git mv README README2                                     # 重命名文件README为README2$ git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）$ git rebase$ git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）$ git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933$ git ls-files                                              # 列出git index包含的文件$ git show-branch                                           # 图示当前分支历史$ git show-branch --all                                     # 图示所有分支历史$ git whatchanged                                           # 显示提交历史对应的文件修改$ git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818$ git ls-tree HEAD                                          # 内部命令：显示某个git对象$ git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH$ git reflog                                                # 显示所有提交，包括孤立节点$ git show HEAD@&#123;5&#125;$ git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态$ git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志$ git show HEAD~3$ git show -s --pretty=raw 2be7fcb476$ git stash                                                 # 暂存当前修改，将所有至为HEAD状态$ git stash list                                            # 查看所有暂存$ git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存$ git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存$ git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”$ git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT$ git gc$ git fsck$ git archive\t\t\t\t\t\t\t\t\t\t\t\t# 生成一个可供发布的压缩包\n\ngit revert 和 git reset的区别\ngit revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\ngit reset --hard HEAD^git revert HEAD\n\n\n\n先准备3个版本\n \ngit reset --hard HEAD^\n\n \ngit revert HEAD\n\n \ngit revert \ngit add -A\ngit revert –continue\n","tags":["Git#文章标签"]}]