[{"title":"Git作业_0917","url":"/2025/09/17/Git%E4%BD%9C%E4%B8%9A_0917/","content":"一、主观题\ngit pull 和 git fetch的区别？\n\ngit pull —— 下载 + 自动合并\n 作用：git fetch + git merge 的组合命令。它会先从远程拉取最新数据，然后自动尝试合并到你当前所在的本地分支。\n可能直接修改你的工作区！在未保存或未提交本地修改时容易出问题。\ngit fetch —— 仅下载，不合并\n作用：从远程仓库下载最新的提交、分支、标签等对象到本地仓库，但不会自动合并或修改你当前的工作区和分支。\n\n两个历史不相同的仓库如何git pull 并且 git push到远程仓库？\n\n直接使用git pull 无法拉取远程仓库版本信息，因为是本地和远程仓库是不同的独立仓库，要拉取必须使用 --allow-unrelated-histories参数允许合并无关历史\n 如：\ngit pull origin main --allow-unrelated-histories\n\n合并后解决可能的冲突，再 git push 即可。\n\n请解释一下git 的相关概念、工作区、暂存盘、版本库、远程仓库， 介绍它们的关系是什么？操作流程是什么？git概念：Git 是一个开源的分布式版本控制系统，用于追踪文件变更、协作开发、版本回退等。\n工作区：正在编辑文件的目录，就是你的项目文件夹\n暂存盘：临时区域，用于存放你准备提交（commit）的文件变更。\n版本库：本地仓库，保存项目完整历史记录的地方，位于项目根目录下的 .git 文件夹中。\n远程仓库：托管在服务器上的 Git 仓库，如 GitHub、Gitee、GitLab 等平台上的项目仓库。\n关系：\n\n工作区 → 暂存区：git add\n暂存区 → 本地版本库：git commit\n本地版本库 ↔ 远程仓库：git push &#x2F; git pull &#x2F; git fetch\n远程仓库 → 本地版本库 → 工作区：git clone（首次拉取整个项目）\n\n流程：\n# 1. 在工作区修改文件（如：edit index.html）# 2. 查看当前状态（可选）git status# 3. 把修改添加到暂存区git add index.html# 或添加所有改动：git add .# 4. 提交到本地版本库git commit -m &quot;描述你的修改，例如：更新首页布局&quot;# 5. 推送到远程仓库（如 origin 的 main 分支）git push origin main\n\n\n\n\n\n假如现在项目有一个报错，通过报错提示我定位到具体的文件，但是我现在弄清楚这个错误是谁导致的，git怎么做？使用命令git blame 文件名\n显示指定文件的每行代码最后一次修改的提交信息（作者、时间、代码内容）。\n\n我想知道工作区和暂存盘的区别？git使用什么命令合适？工作区：正在编辑文件的目录，就是你的项目文件夹\n暂存盘：一个临时区域，用于存放你准备提交（commit）的文件变更。\n使用命令：\ngit diff              # 查看工作区与暂存区差异git diff --cached     # 查看暂存区与版本库差异git diff HEAD         # 查看工作区与版本库差异\n\n\n\n\n\n我在做项目实现一个功能，我试了好几个方案，都不理想，最后我权衡下来，觉得还是方案2可行性高，打算从方案2继续研究下去。请问你接下来git怎么操作比较合适？多方案选择回溯，应使用命令git reset回退到指定提交：\ngit reset --hard 版本号  # 彻底回溯到方案2\n\n\n\n文件1.txt\n版本1：111\n版本2：222\n版本3：333\n版本4：444\n目前在版本4，需要回到版本2\n方法1.使用硬回滚\ngit reset –hard 版本2的版本号\n方法2.使用命令git revert\ngit revert 版本3的版本号修改文件：222增强优化git revert  --continuegit add -A\n\n\n\n\n\n\n\n我在项目因为我对项目有洁癖，被我不小心删除了一个config文件，请问我怎么找回来？工作区撤销修改：\n\ngit status 查看修改的文件\n使用命令恢复：git checkout -- 被恢复的文件\n\n暂存盘撤销修改：\n\ngit reset HEAD 被恢复的文件\ngit checkout -- 被恢复的文件\n\n已提交：\ngit checkout 版本号 -- 文件  # 从历史版本恢复\n\n\n\n纠正：\ngit checkout 版本号 -- 文件  # 从历史版本恢复#或者git restore 版本号 -- 文件\n\n彻底删除后无法找回：git rm config\n\n我有个项目打算使用git做分布式管理， 但是当我提交一个版本的时候居然不能提交，请问有几种可能导致不能提交？\n\n\n代码不规范，写错：git commit -m （没有描述）\n\n没有配置邮箱或账号\n\n没有添加暂存\n\n\n\n我有个项目是多人协作的，我完成了一个功能，组长催促我赶紧上传到远程，我于是保存版本后，开始使用git push上传，但不能成功上传，请问有几种可能导致不能推送到远程？\n仓库别名，地址写错\n\n没有推送权限（ssh没有配置公钥，远程分支保护策略（如main分支需PR才能合并））\n\n远程仓库有最新的版本，不允许提交（先拉取下来再推送）\n\n两个历史不相同的仓库（需添加参数 –allow-unrelated-histories）\n\n网络问题\n\n文件大小超限（如GitHub限制100MB）\n\n\n\n练习成语接龙游戏，自己找搭档配合练习， 不想练就把整个过程文字描述一下。\ngit pull拉取远程仓库最新的提交和分支信息，\n\n在本地进行修改添加文件内容，\n\n使用git push提交至远程仓库，\n\n提交不了则使用git stash保存工作区内容，使用git pull拉取最新提交版本信息，在本地解决冲突后，git add保存解决冲突后的版本，git commit提交一个版本，最后git push到远程仓库\ngit pull                          # 拉取远程更新（可能冲突）git stash                         # 保存本地未提交修改git pull                          # 成功拉取git stash pop                     # 恢复并合并，手动解决冲突git add .                         # 标记冲突已解决git commit -m &quot;fix: resolve conflict&quot;git push origin main              # 推送\n\n\n练习分支管理、查看分支、删除分支、添加分支、切换分支、创建切换分支\n\n\n操作\n命令\n\n\n\n查看本地分支\ngit branch\n\n\n查看详细分支\ngit branch -v\n\n\n查看所有分支\ngit branch -a\n\n\n创建分支\ngit branch dev\n\n\n切换分支\ngit switch dev 或 git checkout dev\n\n\n创建+切换\ngit switch -c dev 或 git checkout -b dev\n\n\n合并分支\ngit merge dev\n\n\n删除分支（安全）\ngit branch -d dev\n\n\n强制删除分支\ngit branch -D dev\n\n\n\n⚠️ 注意：\n\n不能删除当前所在分支。\n-D 是强制删除，即使未合并也可删，不适用于远程分支（远程分支需 git push origin --delete dev）。\n\n\n\n练习抓取远程分支、远程修改默认分支git switch -c bug origin/bug\n\n \n\n再练习一遍git  stash的操作\n1.工作区修改文件（不要添加暂存和保存版本）\n2.远程仓库修改文件并提交版本\n3.执行git pull报错，拒绝拉取\n4.执行git stash 存储工作区\n5.执行git pull，允许拉取\n6.使用git stash list 查看，使用git stash pop恢复\n7.手动解决冲突，git add -A\n\n \n\ngit branch -d 和 git branch -D的区别？git branch -d 分支名：删除已合并的分支\ngit branch -D 分支名：强制删除（无论是否合并），可以删除远程分支\n\n❗ 两者都不能删除当前所在分支！ \n❗ 远程分支删除命令是：git push origin --delete dev\n\n\n.gitignore文件有什么作用？.gitignore 作用：上传忽略名单\n可以在.gitignore文件中添加文件夹，指定文件或者指定类型的文件\n# 通用模板示例*.log.DS_Storenode_modules/# 排除特定文件夹但保留必要文件!/logs/important.log# 环境变量文件.env*.secret\n\n\n\n\n\ngit log和 git reflog的区别？git log：查看历史版本到当前版本的日志（完整提交信息）\ngit reflog：查看所有历史版本信息（简写哈希+操作动作）\n查看的是一个短的版本号，例如 da213db\n\n\n二、 今晚默写和语音题\ngit仓库中的https和ssh协议的区别?（默写+语音朗读）\nhttps协议在推送的时候会弹出登录框，输入仓库托管网站（gitee或者github等）的账户和密码，输入成功后，我们的操作系统会自动记住登录状态，下一次推送不需要再输入账号和密码\n\nssh协议需要自己生成公钥，并且和仓库托管网站登录账户进行绑定，即可。绑定成功后，也是可以免密码登录推送的。\n\n\n\n请介绍推送本地仓库到远程的过程？（默写+语音朗读）# 添加暂存盘git add -A# 提交一个版本git commit  -m “描述文字”# 添加远程仓库别名git remote add origin 仓库地址# 推送到远程仓库git push -u origin main\n\n答案在下面的网址http://47.110.66.96/helper/guide/git.html#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF\n三、 明天早上默写和语音题\ngit rebase 和 git merge的区别？（默写+面试提问）\ngit rebase 和 git merge 都是用来“整合分支”的工具，但它们的实现方式、历史记录结构、适用场景完全不同。\nmerge 是“合并”，保留完整历史分支结构； rebase 是“变基”，把你的提交“挪到”目标分支最新提交之后，让历史线性整洁。\n\n如何解决提交版本产生冲突？（默写+面试提问）\n\n多人同时修改同一文件的同一区域\n执行 git pull&#x2F;git merge&#x2F;git rebase 时\n分支合并时存在不兼容的修改\n\n\n解决：\n\n使用git status命令查看冲突的文件。\n\n打开冲突文件，手动解决冲突并选择要保留的更改。\n\n使用git add命令将解决冲突后的文件标记为已解决。\n\n使用git commit命令提交解决冲突的结果\n\n推送到远程仓库：git push origin main\n\n\n\n请介绍推送本地仓库到远程的过程？（默写+面试提问）# 添加暂存盘git add -A# 提交一个版本git commit  -m “描述文字”# 添加远程仓库别名git remote add origin 仓库地址# 推送到远程仓库git push -u origin main\n\n\n\n请介绍git多人远程协作的流程？（默写+面试提问）\n克隆远程仓库\n\n首先，每个开发者需要将远程仓库克隆到本地：\ngit clone &lt;远程仓库URL&gt;\n\n\n创建分支\n\n为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：\ngit checkout -b &lt;分支名&gt;\n\n\n开发与提交\n\n在本地分支上进行开发，完成后提交更改：\ngit add .git commit -m &quot;提交信息&quot;\n\n\n推送分支\n\n将本地分支推送到远程仓库：\ngit push origin &lt;分支名&gt;\n\n\n创建 Pull Request (PR)\n\n在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。\n\n代码审查\n\n团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。\n\n合并 Pull Request (PR)\n\n审查通过后，将 PR 合并到主分支。\n\n同步主分支\n\n合并后，开发者应拉取最新的主分支到本地，保持同步：\ngit checkout maingit pull origin main\n\n\n删除已合并的分支\n\n合并完成后，可以删除远程和本地的已合并分支：\ngit push origin --delete &lt;分支名&gt;git branch -d &lt;分支名&gt;\n\n\n处理冲突\n\n如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：\ngit add &lt;冲突文件&gt;git commit -m &quot;解决冲突&quot;\n\n\n持续集成\n\n许多团队使用 CI&#x2F;CD 工具（如 Jenkins、GitHub Actions）自动测试和部署代码，确保每次合并后的代码质量。\n\n定期同步\n\n开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。\n总结:\n多人协作的关键在于：\n使用分支隔离开发\n通过 PR 进行代码审查\n定期同步主分支\n及时解决冲突\n\n\n","categories":["Git"],"tags":["Git"]},{"title":"Git作业_0916","url":"/2025/09/16/Git%E4%BD%9C%E4%B8%9A_0916/","content":"一、主观题\ngit stash 练习，练习步骤\n\n \n1.创建并克隆仓库：\n \n \n2.本地修改1.txt文件\n  \n3.远程修改1.txt文件，并提交版本\n  \n4.执行git pull 报错 （因本地有未提交修改，与远程冲突）\n \n5.执行git stash存储工作区修改，使用git stash list查看存储栈\n  \n6.执行git pull 拉取远程最新版本（此时本地无修改，可顺利合并）\n \n7.使用git stash pop 恢复之前暂存的修改（自动尝试合并，若冲突需手动解决）\n  \n8.手动编辑冲突文件，解决冲突后执行 git add -A 标记为已解决\n \n9.提交合并结果并上传远程仓库 git push\n \n2.     git show有什么作用？git show 命令用于显示 Git 仓库中对象（如提交 commit、标签 tag、文件 blob 等）的详细信息。默认显示最近一次提交的元数据和变更内容。\n是查看历史变更和对象内容的核心命令。\n3.     git blame 有什么作用？git blame 用于逐行显示文件中每行代码的最后修改者、提交哈希、修改时间和具体内容，帮助追踪代码变更历史和责任归属。\n运行 git blame &lt;文件路径&gt; 可直观看到每行的“责任人”和修改上下文。\n对代码审查、Bug 追溯、交接维护非常有用。\n4.     再练习一遍撤销还原操作4.1 工作区撤销（丢弃工作区未暂存的修改）\n\n\n在工作区修改了文件\n\n使用git status 查看那些文件被修改了\n \n\n使用以下任一命令丢弃修改，恢复到最近一次提交的状态：\n使用git checkout – 被恢复的文件\n\n\ngit statusgit checkout -- readme.txt// 或者git restore readme.txt\n \n \n4.2  暂存盘软撤销（取消暂存，保留工作区内容）\n\n\n在工作区修改文件\n使用 git add 添加到暂存区\n使用 git status 查看状态\n取消暂存（但保留工作区内容）：\n\n方法1（传统）：\ngit statusgit reset HEAD readme.txt\t# 取消暂存git checkout -- readme.txt\t# 丢弃工作区修改（可选）\n\n方法2（推荐，Git 2.23+）:\ngit restore --staged readme.txt\t\t# 取消暂存git restore readme.txt\t\t\t# 丢弃工作区修改（可选）\n\n注意：先修改一下文件，然后使用git add 将修改过后的文件添加到暂存盘，然后做上面的练习\n\n1.工作区修改文件，添加至暂存区：\n \n2.使用git status查看查看状态：\n\n使用 git reset HEAD 文件名 取消暂存 + git checkout -- 文件名 丢弃修改：\n  \n4.3  暂存盘硬撤销（恢复修改前的工作区内容）（取消暂存并丢弃工作区修改）\n将被修改了文件添加到暂存盘# 假设文件已修改并 add 到暂存区git restore --staged 1.txt\t# 取消暂存git restore 1.txt\t\t# 丢弃工作区所有修改，恢复到 HEAD 状态\n\n \n4.2  版本软回滚（保留工作区和暂存区内容，仅移动 HEAD）\n git reset –soft 短版本号\n 目标：回滚到 22222 提交（3bfdc42），但保留当前 1.txt 的所有内容（包括 33333）\ngit reset --soft 3bfdc42\n\n此时提交历史回到 3bfdc42，但工作区和暂存区保持不变，可重新 commit。\n \n4.3  版本硬回滚（工作区内容也恢复）（工作区、暂存区、HEAD 全部回退）\n git reset –hard 短版本号\n目标：彻底回滚到 11111 提交（2acb598），工作区内容也恢复成那时的样子\n⚠️ 此操作不可逆！未提交的修改将永久丢失。\n \n4.4 恢复恢复刚才的 33333 提交,找回被 reset –hard 删除的提交\n使用 git reflog 查看 HEAD 移动历史，找到被删除提交的哈希：\ngit refloggit reset --hard 8e1f554\t# 恢复到指定提交\n\n \n5.     git reset 和 git revert的区别？\ngit revert：创建一个新的提交来“撤销”旧提交的变更，原提交历史保留。安全，适用于共享分支。示例：git revert &lt;commit-id&gt; 会生成一个反向提交。\n\ngit reset：将 HEAD、暂存区、工作区重置到指定提交，之后的提交会被“丢弃”（可通过 reflog 恢复）。会改写历史，仅适用于本地或未推送分支。\n三种模式：\n\n--soft：仅移动 HEAD\n--mixed（默认）：移动 HEAD + 重置暂存区\n--hard：移动 HEAD + 重置暂存区 + 重置工作区\n\n\n\n git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n6.     练习git revert，假设有4个版本，我将回滚到版本2，然后合并修改之后新增版本2增强版，如何实现？查看提交历史：git log --oneline\n找到要撤销的提交（如版本3和版本4），执行：\ngit revert &lt;版本4的commit-id&gt;git revert &lt;版本3的commit-id&gt;\n\n这会生成两个新提交，撤销版本3和4的变更，此时代码状态等同于“版本2”，但历史保留版本3、4、revert1、revert2。\n在此基础上继续开发“版本2增强版”，修改后提交：\n# 修改文件git add .git commit -m &quot;feat: 版本2增强版&quot;\n\n⚠️ 注意：git reset --hard 是直接回退历史，不适用于协作场景。revert 才是协作推荐方式。\n7.     git 可以同时支持几种仓库地址？Git可以同时支持多种仓库地址，比如HTTPS和SSH\n 可以在本地仓库中使用git remote add命令为同一个远程仓库添加多个地址\n8.     在gitee上克隆别人的仓库，默认克隆了几个分支？是否默认创建了远程仓库别名？你能否往这个仓库推送你的版本？\n默认只克隆默认分支（通常是 main 或 master）。\n\n自动创建远程别名 origin。\n\n默认无推送权限（除非你是仓库协作者或拥有者）需要开发者权限。需 Fork 后克隆自己的仓库，修改后提交 Pull Request。\n\n\n9.     一个文件添加到了git仓库，那么我删除这个文件，怎么恢复它？假如我想彻底从git仓库删除这个文件，该怎么做？ 恢复已删除的文件（从最近提交中恢复）：\ngit checkout -- 文件名# 或git restore 文件名\n\n彻底从 Git 仓库删除文件（停止追踪并删除工作区文件）：\ngit rm 文件名git commit -m &quot;删除文件&quot;\n\n若只想停止追踪但保留工作区文件：\ngit rm --cached 文件名git commit -m &quot;停止追踪文件&quot;\n\n git rm 不但会把工作区里面的文件删除，还会把版本库里面的文件也删除，做到彻底移除掉这个文件\n10.      练习远程仓库、新增远程仓库、删除远程仓库、查看以及查看详细远程仓库# 克隆远程仓库git clone 仓库地址# 添加新远程仓库git remote add 别名 仓库地址# 查看所有远程仓库（简略）git remote -v# 查看某个远程仓库详细信息git remote show 别名# 删除远程仓库配置git remote rm 别名\n\n11.      git pull和git push的区别？\ngit pull：从远程仓库拉取最新提交并自动合并到当前分支。相当于 git fetch + git merge。\ngit push：将本地提交推送到远程仓库，更新远程分支。\n\n12.      git push -u 和git push -f 的区别是什么？ -u （或 --set-upstream）以非常安全的模式提交到远程，\n​\t比如远 程早一个版本，它会提示你先git pull 拉取下来\n-f 强制覆盖模式，强制推送，覆盖远程分支历史。危险操作！会丢弃远程分支上其他人的提交。\n 更安全替代：--force-with-lease（仅在远程未更新时强制推送）\n13.      假如我从远程克隆了一个项目，然后我想给这个项目贡献自己的代码？你的理解你应该接下来怎么办？需要修改\n\nFork 项目到自己的账号下（如果是开源项目）。\n克隆自己的 Fork：git clone 自己的仓库地址\n创建新分支开发：git checkout -b feature/xxx\n修改、提交：git add . &amp;&amp; git commit -m &quot;message&quot;\n推送到自己的远程：git push origin feature/xxx\n在网页端发起 Pull Request（PR）到原项目。\n等待审核合并。\n\n14.      我能不能 不经过git add 直接 git commit 提交一个版本？不行，在 Git 中必须先将变更(git add)添加到暂存区(Stage&#x2F;Index)，然后才能提交(git commit)。这是 Git 的基本工作流程。\n15.      有哪些指令可以知道git 仓库改动的信息？\ngit status：查看工作区和暂存区状态（修改、新增、删除）\ngit diff：查看工作区与暂存区差异\ngit diff --cached：查看暂存区与 HEAD 差异\ngit log：查看提交历史\ngit log -p：查看提交历史及每次变更详情\ngit reflog：查看 HEAD 移动记录（包括 reset、checkout 等）\ngit show &lt;commit&gt;：查看某次提交的详情\ngit blame &lt;file&gt;：查看文件每行最后修改者\n\n16.      我有一个项目，想要git来做版本控制管理，第一步应该做什么？初始化本地 Git 仓库，使用命令git init，生成 .git 目录。\n 然后添加文件并首次提交：\ngit add .git commit -m &quot;Initial commit&quot;\n\n\n\n17.      我有一个项目，5个人开发，你应该怎么做，才能确保这个5个可以互相协作开发不出乱子？你的计划是什么？ 协作规范：\n\n使用远程仓库（如 GitHub&#x2F;GitLab&#x2F;Gitee）作为中央仓库。\n每人 Fork 或克隆仓库到本地。\n基于分支开发：\nmain/master 分支保护，禁止直接推送。\n新功能&#x2F;修复在 feature/xxx 或 fix/xxx 分支开发。\n\n\n每日开始前：git pull origin main 同步主干。\n开发完成后：推送分支到远程，发起 Pull Request&#x2F;Merge Request。\nCode Review：团队成员审核代码后合并。\n解决冲突：拉取最新主干，合并到自己分支解决冲突后再提 PR。\n使用 .gitignore 忽略临时文件。\n提交信息规范：清晰描述变更内容。\n\n18.      早上9点公司例会，组长讨论了每个人今日的任务，你分到了一些bug修改，共10条bug，请问今天这一天你打算怎么安排修改？晚上下班前组长要求你们每个人提交今天的任务，你又该怎么做？安排：\n\n从主干拉取最新代码：git pull origin main\n为这组 Bug 创建独立分支：git checkout -b fix/bug-set-20250917\n逐个修复 Bug，每个 Bug 修复后单独提交（原子提交）：\n\n# 修复 bug1git add .git commit -m &quot;fix: 修复用户登录失败问题 #123&quot;# 修复 bug2git add .git commit -m &quot;fix: 修复购物车数量计算错误 #124&quot;...\n\n晚上下班前：\n\n推送分支：git push origin fix/bug-set-20250917\n\n在 Git 平台发起 Merge Request &#x2F; Pull Request 到 main 分支\n\n通知组长或相关同事进行 Code Review\n\n不要直接合并到主干（除非流程允许）\n\n\n19.      接上面，假如你在修改上面的bug时，发现第5个bug，仍然存在问题，你现在想到另一种解决办法，你打算怎么样？不要直接在原提交上修改。\n在当前分支继续修改代码，测试新方案。\n新增一个提交：\n git add .git commit -m &quot;fix: 优化第5个bug的解决方案，改用XX方法&quot;\n\n如果原提交有误，可考虑：\n\ngit commit --amend：如果尚未推送，可修改上一次提交。\n或使用 git revert 撤销原修复提交，再提交新方案（适用于已推送场景）。\n\n避免使用 git reset 修改历史，以免影响协作。\n20.      练习从远程克隆仓库到本地，然后做一些修改，修改后提交到远程仓库，顺利提交成功后，再练习本地修改后，再提交到远程，此时远程已经有人修改了比你早提交了版本，你提交不了，发生冲突了，你该如何解决后，提交到远程。 手动解决冲突：编辑冲突文件，删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt;、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记，保留正确内容。\n标记冲突已解决：\ngit add .git commit -m &quot;Merge remote changes and resolve conflicts&quot;\n\n再次推送：\ngit push origin main\n\n\n\n二、     今晚默写和语音题1.     如何创建和合并分支？（默写+语音朗读）创建分支：\n#新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]\n\n合并分支：\n#合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]\n\n\n\n2.     如何将本地仓库与远程仓库同步？（默写+语音朗读）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n答案在下面的网址\nhttp://47.110.66.96/helper/guide/git.html#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF\n三、     明天早上默写和语音题1.     如何解决合并冲突？（默写+面试提问）合并冲突发生在合并分支时，当两个分支的相同部分产生了不同的更改时，解决合并冲突一般步骤如下：\n使用git status命令查看冲突的文件。\n打开冲突文件，手动解决冲突并选择要保留的更改。\n使用git add命令将解决冲突后的文件标记为已解决。\n使用git commit命令提交解决冲突的结果\n2.     如何将本地仓库与远程仓库同步？（默写+面试提问）使用git fetch或git pull命令从远程仓库下载最新的提交和分支信息。\n然后，使用git merge命令或git rebase命令将本地分支与远程分支合并。\n最后，使用git push命令将本地提交推送到远程仓库。\n3.     如何创建和合并分支？（默写+面试提问）使用git branch命令创建新分支，例如git branch bug。\n创建分支后，使用git checkout命令切换到新分支，例如git checkout bug。\n要将分支合并到当前分支，可以使用git merge命令，例如git merge dev。\n4.     请介绍git多人远程协作的流程？（默写+面试提问）\n克隆远程仓库\n\n首先，每个开发者需要将远程仓库克隆到本地：\ngit clone &lt;远程仓库URL&gt;\n\n\n创建分支\n\n为了隔离开发工作，开发者应基于主分支（如 main 或 master）创建新分支：\ngit checkout -b &lt;分支名&gt;\n\n\n开发与提交\n\n在本地分支上进行开发，完成后提交更改：\ngit add .git commit -m &quot;提交信息&quot;\n\n\n推送分支\n\n将本地分支推送到远程仓库：\ngit push origin &lt;分支名&gt;\n\n\n创建 Pull Request (PR)\n\n在远程仓库（如 GitHub、GitLab）上，基于推送的分支创建 PR，请求将更改合并到主分支。\n\n代码审查\n\n团队成员审查 PR，提出修改建议。开发者根据反馈更新代码，并推送新的提交。\n\n合并 Pull Request (PR)\n\n审查通过后，将 PR 合并到主分支。\n\n同步主分支\n\n合并后，开发者应拉取最新的主分支到本地，保持同步：\ngit checkout maingit pull origin main\n\n\n删除已合并的分支\n\n合并完成后，可以删除远程和本地的已合并分支：\ngit push origin --delete &lt;分支名&gt;git branch -d &lt;分支名&gt;\n\n\n处理冲突\n\n如果多人修改了同一文件，可能会产生冲突。解决冲突后，标记冲突已解决并提交：\ngit add &lt;冲突文件&gt;git commit -m &quot;解决冲突&quot;\n\n\n持续集成\n\n许多团队使用 CI&#x2F;CD 工具（如 Jenkins、GitHub Actions）自动测试和部署代码，确保每次合并后的代码质量。\n\n定期同步\n\n开发者应定期拉取主分支，保持本地代码与远程仓库同步，减少冲突。\n总结:\n多人协作的关键在于：\n使用分支隔离开发\n通过 PR 进行代码审查\n定期同步主分支\n及时解决冲突\n","categories":["Git"],"tags":["Git"]},{"title":"Git学习笔记(总)","url":"/2025/09/17/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%80%BB)/","content":"第一章 概述1、Git 历史同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。\n到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标：\n• 速度\n• 简单的设计\n• 对非线性开发模式的强力支持（允许上千个并行开发的分支）\n• 完全分布式\n• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）\n2、Git 定义Git 是一个开源的分布式版本控制系统（Distributed Version Control System，简称 DVCS），仓库类型分为：本地仓库和远程仓库：\n\n**本地仓库：**开发人员自己电脑上的 Git 仓库\n**远程仓库：**是在远程服务器上的 Git 仓库\n\n/*Git 是目前世界上最先进、最流行的版本控制系统，可以快速高效地处理从很小到非常大的项目版本管理。它没有中央服务器的概念，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了，\n\n\n\n下图就是分布式版本控制工具管理方式：\n \n\nClone：克隆，就是将远程仓库复制到本地\nPush：推送，就是将本地仓库代码上传到远程仓库\nPull：拉取，就是将远程仓库代码下载到本地仓库\n\n特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性\n3、Git 特性和优势Git 之所以快速和高效，主要依赖于它的如下两个特性： \n\n直接记录快照，而非差异比较\n近乎所有操作都是本地执行，不需要联网\n\n特性一：git的记录快照\nGit 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git  不再重新存储该文件，而是只保留一个链接指向之前存储的文件。\n\n/*解析：version1：文件A、B、Cversion2：A 和 C 更新为 A1 C1，  B 没有更新，不备份version3：C1 更新为 C2，  A1 和 B 没有更新，不备份version4：A1 B 更新为 A2 B1，  C2 没有更新，不备份...\n\n优缺点：\n\n缺点：占用磁盘空间较大 \n优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。\n特点：空间换时间\n\n特性二：在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 \n特性： \n\n\n断网后依旧可以在本地对项目进行版本管理 \n联网后，把本地修改的记录同步到云端服务器即可\n\n\nGit的优势还有：\n\n尽可能添加数据而不是删除或修改数据\n分支操作非常快捷流畅\n与 Linux 命令全面兼容\n\nGit 应用场景\n写作（作家、演说家、编剧）\n程序开发\n起草法律条款\n写学术论文\n\n4、Git 与 SVN 比较SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。\n下图就是标准的集中式版本控制工具管理方式：\n\n集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。\nsvn：传统的版本控制系统是基于差异的版本控制（每次记录的是变化的内容），它们存储的是一组基本文件和每个文件随时间逐步累积的差异。\n\n/*解析：初始版本1 中有三个文件 A B C升级到版本2：在版本2中记录的是文件A变化的内容 🔺1  和 文件C变化的内容 🔺1升级到版本3：在版本3中记录文件c的变化内容 🔺2...切换到版本3，需要在初始文件 A 应用一次差异，在初始文件 C 上应用2次差异如果是切换版本5，需要在初始文件 A 上应用2次差异，在初始文件 B 上应用2次差异，在初始文件 C 上应用2次差异\n\n优缺点：\n\n好处：节省磁盘空间\n缺点：耗时、效率低 在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。\n\n集中式和分布式版本控制系统的区别？集中式SVN，分布式git，区别如下：\n集中式的缺点：\n\n必须联网才能工作\n\n中央服务器出问题了，就没法工作\n\n分支速度慢\n\n\n分布式的优点：\n\n不需要联网，也可以工作。\n没有中央服务，每台自己就是服务器。\n没有全局分支，自己的服务器可以创建n个分支，速度极快。\n\ngit和svn的区别\n1.Git 是分布式的，SVN集中式2.Git 把内容按元数据方式存储，而 SVN 是按文件3.Git 分支和 SVN 的分支不同4.Git 没有一个全局的版本号，而 SVN 有5.Git 的内容完整性要优于 SVN\n\n5、Git 中的三个区域使用 Git 管理的项目，拥有三个区域，分别是：\n\n工作区：本地处理工作的区域（写代码，修改代码）\n暂存区：已完成的工作临时存放区域， 等待被提交\nGit 仓库：最终的存放区域\n\n\n解析：\n\n工作区就是电脑里能看到的目录，存放项目或者文件的目录；\n在这个工作目录中的 .git 隐藏文件夹才是版本库；\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n当我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，git commit就是往master分支上提交更改。\n可以简单理解为，需要提交的文件修改后通通放到暂存区，然后，一次性将暂存区的所有修改提交到分支。\n\n\n6、Git 中的三种状态使用 Git 管理的项目，拥有三个状态，分别是：\n\nmodified（已修改）：表示修改了文件，但还没 将修改的结果放到暂存区\nstaged（已暂存）：表示对已修改文件的当前版本做了标记，让它包含在下次提交的列表中\ncommitted（已提交）：表示文件已经安全地保存 在本地的 Git 仓库中\n\n注意：\n\n工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。 \n如果文件已修改并放入暂存区，就属于已暂存状态。 \n如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。\n\n7、Git 和代码托管中心代码托管中心的作用是：维护远程库\n局域网环境下：gitlab 服务器（可以自己搭建的服务器）\n联网环境下：github 和 码云(gitee)\n注意：\n\ngit 和 github 是两个完全没有关系的概念，\n\ngit 是版本控制工具，管理本地仓库\nGitHub 是远程仓库托管中心\n\n\nGit 与 GitHub 区别？git是一个版本控制系统，而github是一个在线开源托管网站。你可以使用git上传源码到github开源网站上去。\n8、Git 工作流程一般工作流程如下：\n\n从远程仓库中克隆 Git 资源作为本地仓库；\n\n从本地仓库中 checkout 代码到工作区，然后进行代码修改；\n\n在提交前先将代码提交到暂存区；\n\n提交到本地仓库，本地仓库中保存修改的各个历史版本；\n\n在修改完成后，需要和团队成员共享代码时，可以将代码 push 到远程仓库（git仓库）。\n\n\n下图展示了 Git 的工作流程：\n\n9、本地库和远程库作用是协作开发\n9.1 团队内部协作\n\n9.2 跨团队协作\n\n第二章 环境准备最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。由于开发机大多数情况都是windows，所以这里讲解windows下的git的安装及使用\n1、Git1.1 软件下载下载地址：https://git-scm.com/download\n\n\n淘宝镜像下载安装\n\nhttps://npm.taobao.org/mirrors/git-for-windows/\n\n安装方式\n因为git是命令行工具，默认安装再C盘，不要装作含中文的目录下，建议一路下一步安装\n\n1.2 软件安装git的安装一路点击“下一步”，使用默认的选项即可\n安装详解：\n\n安装 git for windows\n\n\n\n选择安装路径：使用非中文没有空格的目录\n\n\n\n选择组件：默认\n\n\n选项解析：\n\nAdditional icons ： 否创建图标\n\nOn the Desktop ：在桌面\n\nWindows Explorer integration：集成右键功能\n\nGit Bash Here\nGit GUI Here\n\nGit LFS (Large File Support)：git大文件支持\nAssociate .git* configuration files with the default text editorAssociate .sh files to be run with Bash：打开 git 配置文件的默认文本编辑器\n\n\n选择开始目录文件：默认\n\n\n\n选择默认文本编辑器：使用默认的 vim 编辑器\n\n\n\n初始化分支名称：默认\n\n\n解析：\n\nLet Git decide：让 git 决定\n\n.Let Git use its default branch name (currently: “master”) for the initial branchin newly created repositories. The Git project intends to change this default toa more inclusive name in the near future.\n\n让 git 使用初始化生成的分支，默认名称为 master…\n\n\n调整环境变量：可以选择第一项，也可以使用默认的推荐选项（第二项）\n\n\n解析：\n\nUse Git from Git Bash only:\n\n这是最多的选择，将不会改变你的环境，但是只能在 git bash 中执行 git 命令\n\nGit from the command line and also from 3rd-party software\n\n推荐，这个选项只给你的path添加了一些最小的git包装器，可以从 git bash 中使用git，也可以从命令提示符等以及任何第三方软件中寻找 git\n\nuse Git and optional Unix tools from the Command Prompt\n\n警告：这个选项会修改 path，覆盖 windows的一些命令，如“查找” 和 “排序”…  不推荐\n\n\n\n选择可知行文件：默认自带的 ssh.exe\n\n\n解析：\n\nUse bundled OpenSSH：使用自带的 ssh.exe（可执行文件）\n\nThis uses ssh.exe that comes with Git.)\n\nUse external OpenSSH：使用外部的可执行文件\n\nNEW!This uses an external ssh.exe.Git will not install its own OpenSSH(and related) binaries but use them as found on the PATH.\n\n\n\n选择传输协议：默认\n\n\n解析：\n\nUse the openSSL library\n\n使用通用的 openSSL 库建立连接，推荐\n\nUse the native Windows Secure Channel library\n\n本地windows安全通道连接有一定的局限性，不推荐使用\n\n\n\n配置文本结束符：默认\n\n\n解析：\n\ncheckout Windows-style, commit Unix-style line endings\n\nGit will convert LF to CRLF when checking out text files. When committingtext files,CRLF will be converted to LF. For cross-platform projects,this is the recommended setting on Windows (“core.autocrIf” is set to “true”).\n\n检出文件时将 LF 转换为 CRLF, 提交时将 CRLF 转换为 LF（windows 和 Unix 系统换行符不一样，这个选项会帮我们做转换）\nCheckout as-is, commit Unix-style line endings\n\nGit will not perform any conversion when checking out text files. When committing text files,CRLF will be converted to LF.For cross-platform projects,this is the recommended setting on Unix (“core.autocrlf” is set to “input”).\n\nCheckout as-is, commit as-is\n\nGit will not perform any conversions when checking out or committingtext files. Choosing this option is not recommended for cross-platformprojects (“core.autocrlf” is set to “false”).\n\n\n\n配置 git 终端：默认\n\n\n解析：\n\nUse MinTTY (the default terminal of MSYS2)\n\nGit Bash will use MinTTY as terminal emulator, which sports a resizable window,non-rectangular selections and a Unicode font. Windows console programs(suchas interactive Python) must be launched via ‘winpty&#96; to work in MinTTY.\n\n使用 git 自带的默认终端（推荐，命令和 linux 命令兼容）\nuse Windows’ default console window\n\nGit will use the default console window of Windows (“cmd.exe”), which works wellwith Win32 console programs such as interactive Python or node.js, but has avery limited default scroll-back, needs to be configured to use a Unicode font inorder to display non-ASCII characters correctly, and prior to Windows 10 itswindow was not freely resizable and it only allowed rectangular text selections.\n\n使用 windows 默认的的命令提示符（可能会有命令冲突，不推荐）\n\n\n选择 git pull 默认行为：默认\n\n\n\n启用授权管理器：默认\n\n\n\n启用文件缓存：默认\n\n\n\n最后是一些新的功能，可以不勾选，直接 Install 安装\n\n\n\n安装成功\n\n最后取消勾选”View Release Notes（视图版本说明，不需要）” → finish\n\n\n检测是否安装成功\n\n任意位置右键，有 Git GUI Here 和 Git Bash Here  表示安装成功\n\n验证安装成功\n\nwin菜单 打开运行命令\n\n\n\n打开 CMD 命名窗口\n\n\n\n在命令行中输入  git –version 然后会打印出版本号\n\n\n\n安装成功\n\n\n\n2、TortoiseGit2.1 软件介绍TortoiseGit 其实是一款开源的git的版本控制系统，也叫海龟git。TortoiseGit提供了人性化的图形化界面，不用像Git一样输入许多语句，像git init、git add、git commit这些语句就通通不用记了。轻松使用鼠标，就可以完成代码的提交和上传。对于使用本地Git的新手来说，TortoiseGit更加简便，更加容易上手。\n2.2 软件下载地址：https://tortoisegit.org/download/\n\n\n2.3 软件安装TortoiseGit 安装一路点击“下一步”，使用默认的选项即可\n安装详解：\n\n下一步\n\n\n\n下一步\n\n\n\n客户端选择推荐的 “基于Putty…, 更好的与 windows 集成”，下一步：\n\n\n\n自定义安装路径，下一步：\n\n\n\ninstall，安装\n\n\n\n取消勾选，完成\n\n\n2.4 安装中文语言包中文语言包并不是必选项。可以根据个人情况来选择安装。\n\n点击中文语言语言安装包，直接下一步完成即可\n在 TortoiseGit 的设置中可以选择语言：\n\n\n3、代码托管服务3.1 概述前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。\n知名远程仓库网站gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub\n码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快\nGitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务\n内网仓库gitlab是使用java开发的一个内网仓库\n3.2 创建 GitHub账号访问 github 官方网站https://github.com/，注册账号\n第一步：Sign up\n\n第二步：填入注册信息\n\n账号：24932***8@qq.com\n密码：p***\n用户名：pan0506\n\n\n第三步：注册成功\n选择免费版本，忽略兴趣选项，注册成功后自动登入githhub\n\n注册成功后点击 Create Repository 就可以创建远程仓库了\n3.3 创建gitee账号推荐使用：由于服务器在国内，所以相比于GitHub，码云速度会更快\n访问码云官方网站https://gitee.com/，选择注册：\n\n填入注册信息\n\n用户名：pan0506\n邮箱：343268***@qq.com\n密码：p***\n\n\n3.4 创建Git远程仓库登录成功后即可创建 “我的仓库”\n\n填写仓库名称（其他选项默认即可），点击创建\n\n初始化 readme 文件（可以不需要）：\n\n设置仓库开源：\n\n完成：\n\n每个Git远程仓库都会对应一个网络地址，可以点击克隆&#x2F;下载按钮弹出窗口并点击复制按钮获得这个网络地址：\n\n当前创建的远程仓库对应的地址为：\nhttps://gitee.com/pan0506/my-repo1.git\n3.5 设置其他仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。\n在 【管理】选项 \n→ 仓库成员管理 \n→ 开发者（当前仓库除了创建的人是管理员，其他用户一般都是开发人员） \n→ 添加仓库成员\n→ 邀请用户：\n\n邀请的方式有多种，可以通过链接邀请，也可以直接添加：\n\n注意：\n直接添加可以输入其他用户的个性邮箱或者注册时的用户名（必须是存在的用户）：\n\n点击添加后提交，会将邀请信息发送到对方的用户邮箱，对方同意后，即可参与项目开发，即：代码的下载、修改、推送等操纵\n第三章 GitBash管理文件版本1、 本地仓库操作1.1 初始化本地仓库1.1.1 获取方式获取（初始化）git 仓库的方式有两种：\n\n将尚未进行版本控制的本地目录转换为 Git 仓库\n从其它服务器克隆一个已存在的 Git 仓库（后面演示）\n\n以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓\n1.1.2 命令# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n\n\nLinux 常用命令\n\n清屏命令：clear\n快捷键：Ctrl + L\n重启终端：reset\n\n1.1.3 步骤如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：\n\n在项目目录中，通过鼠标右键打开“Git Bash”\n执行 git init 命令将当前的目录转化为 Git 仓库\n\n在工作空间新建一个 gitRepository 目录，测试 git 操作：\n在当前 gitRepository 目录中新建仓库1：repo1 \n在当前目录 repo1  中右键  →  Git Bash Here，打开 git 命令行窗口\n输入 git init 命令初始化本地仓库\n\n注意：\n\ngit init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，\n里面包含了初始的必要 文件，这些文件是 Git 仓库的必要组成部分。\n.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要轻易修改\n\n概念：\n\n版本库：“.git”目录就是版本库，将来文件都需要保存到版本库中。\n工作目录：包含 “.git”目录的目录，也就是.git目录的上一级目录就是工作目录。\n只有工作目录中的文件才能保存到版本库中。\n\n1.2 配置用户信息1.2.1 签名形式设置自己的用户名和邮件地址（设置签名）。通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作，\n例如：\n\n用户名：pan\nEmail 地址：pan0506@cc.com\n\n注意：\n\n用户名可以和邮箱名称不一致，邮箱也可以是不存在的\n这个签名（用户名和邮箱）的作用：是区分开发人员的身份\n这里的设置的签名和登录远程仓库（GitHub 或 码云）的账号密码没有任何关系，可以是不存在的用户名和邮箱\n\n1.2.2 查看配置项查看配置信息： git config --list\n\n解析：\n\n我们发现这里面并没有用户信息，所以需要我们去配置用户信息\n\n1.2.3 命令用户的信息可以设置为两个级别\n\n仓库级别（也叫项目级别）：仅在当前本地仓库范围有效\n\n命令：\n\ngit config user.name &quot;pan_pro&quot; 命令设置仓库级别用户名（pro表示项目级别）\ngit config user.email &quot;pan0506@cc.com&quot;  命令设置邮箱\n使用  git config --list 或者  cat .git/config  命令查看 配置的信息\n\n\n\n全局范围（也叫系统用户级别）：登录当前操作系统的用户范围\n\n命令：\n\ngit config --global user.name &quot;pan_glb&quot; 设置全局范围用户名（gib表示全局配置）\ngit config --global user.email &quot;pan0506@cc.com&quot;  设置全范围别邮箱\n使用  git config --list 或者 cat ~/.gitconfig：查看当前系统用户家目录（c&#x2F;users&#x2F;cc&#x2F;.gitconfig）中保存的信息。\n\n\n（~ 表示当前系统用户的家目录：c&#x2F;user&#x2F;cc）\n\n1.2.4 签名的优先级就近原则：\n\n项目级别优先于系统用户级别，二者都有时采用项目级别的签名\n如果只有系统用户级别的签名，就以系统用户级别的签名为准\n\n注意：\n\n仓库级别和全局级别，必须存在一个，不允许二者都没有\n\n1.2.5 小结在 linux 系统中，git 的命令都是以 git 开头（主命令），后面跟其他的命令，\n例如：git config，表示配置命令\n还可以在命令后面使用 --添加一些参数，\n例如：git config --golbal，表示全局配置 \n1.3 查看状态（status）1.3.1 准备测试文件在当前目录中新建一个 test.txt 文件用于测试基本操作\n\n1.3.2 命令可以使用 git status 命令查看文件处于什么状态\n\n解析：\n\n没有未追踪文件：\n\non branch master：表示当前在 master 分支上\nno commits yet：没有任何提交\nnothing to commit ：没有可以提交的东西\n(create&#x2F;copy files and use “git add” to track)：使用 git add 命令追踪创建或者复制的文件（即使用 git 管理文件）\n\n有未追踪文件：\n\n Untracked files: 未追踪文件 (use “git add …” to include in what will be committed)：使用git add包含到将要提交的文件（保存到暂存区）    test.txt   ：文件名称\n nothing added to commit but untracked files present (use “git add” to track)：没有添加提交但是有未追踪的文件\n\n\n使用 git status 输出的状态报告很详细，但有些繁琐。\n如果希望以精简的方式显示文件的状态，可以使用 git status -s 或者  git status --short命令，\n其中 -s 是 --short 的简写形式，\n如果有未跟踪文件，前面有红色的 ?? 标记\n\n1.4 跟踪文件1.4.1 添加到暂存区（add）使用命令 git add 开始跟踪文件（即：将文件添加到暂存区），然后查看状态\n\n解析：\n\nChanges to be committed:  改变成将要提交的文件（保存到暂存区的文件）(use “git rm –cached …” to unstage)：可以使用 git rm --cached 取消文件跟踪  new file:   test.txt\n\n1.4.1 取消跟踪（rm）使用命令 git rm --cached 文件名 命令取消跟踪文件（从暂存区删除文件，本地工作区文件还在，不是删除本地文件）\n\n1.5 提交更新（commit）使用 git commit 命令提交文件\n提交的方式有两种\n\ngit commit 文件，进入 vim 编辑器，编辑日志信息\ngit commit -m &quot;message&quot; 文件，在命令中添加日志message，直接提交\n\n1.5.1 第一种方式git commit 文件，进入 vim 编辑器，编辑日志信息\n环境准备：将 test.txt 文件添加到暂存区（跟踪文件）\n\n操作步骤：\n\n输入 git commit test.txt 命令， 进入 vim 编辑器\n\n\n\n进入 vim 编辑器\n\n\n\n在 vim 编辑器中输入提交日志内容\n\n步骤：\n\n:set nu 命令可以显示行号\na  或者 i 命令切换为编辑模式，编辑日志内容\nEsc 退出编辑模式\n:wq + 回车，保存退出\n\n\n\n提交成功信息\n\n\n解析：\n\n[master (root-commit)  e549da4]：表示在master主干根提交\nfirst commit, new file test.txt：提交的日志信息\n1 file changed, 1 insertion(+)：1个文件变化，1行内容（文本中的内容）\n\n\n查询状态\n\n\n解析：\n\nnothing to commit, working tree clean: 没有可以提交的，工作树很干净\n\n1.5.2 第二种方式git commit -m &quot;message&quot; 文件，在命令中添加日志message，直接提交\n环境准备：\n\n修改文件内容（可以手动修改，也可以使用命令修改）\n\n命令修改步骤：\n\nvim test.txt  命令进入文件\n:set nu 命令显示行号\na 命令切换为编辑模式，修改内容\nEsc 退出编辑\n:wq + 回车 保存并退出文件\n\n\n\n修改后查看状态\n\n\n解析\n\nChanges not staged for commit:  没有暂存到可以提交的区域\n(use “git add …” to update what will be committed) ： 使用git add 命令 更新 到准备提交的区域\n(use “git restore …” to discard changes in working directory)  ： 使用git restore 命令取消修改文件\nmodified:   test.txt    修改的文件\nno changes added to commit (use “git add” and&#x2F;or “git commit -a”)   ：可以先add 再commit，也可以直接commit\n\n\n先执行 git add\n\n\n出现了两行警告，解析：\n\nwarning: LF will be replaced by CRLF in test.txt.   行末（换行符）LF 将会被转换为 CRLFThe file will have its original line endings in your working directory  不会修改工作空间的文件行末\n\n\n查看状态\n\n\n解析：\n\nChanges to be committed:  变为可提交的文件(use “git restore –staged …” to unstage)：可以使用 git restore 命令取消跟踪  modified:   test.txt  修改的文件\n\n在命令中添加日志信息，直接提交：\n输入命令： git commit -m &quot;second commit,modify test.txt&quot; test.txt\n\n1.6 综合练习：将java工程提交到版本库1.6.0 需求将 springbootShiro 项目提交到本地仓库，忽略不需要提交的文件\n1.6.1 初始化本地仓库新建 repo2 目录，复制需要版本控制的 springbootShiro 到当前目录，\n执行git init 命令，初始化本地仓库：\n\n1.6.2 忽略文件或目录在此工程中，并不是所有文件都需要保存到版本库中的，\n例如 target 目录是编译后的目录，这个目录及目录下的文件就可以忽略。\nGit解决这个问题很简单，在Git工作区的根目录下创建一个特殊的 .gitignore 文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n步骤：\n\n工作区间的根目录中创建  .gitignore 文件\n编辑内容，填写忽略的文件名称（springbootShiro目录下的target目录）\n\n\n注意文件中的内容：\n\nspringbootShiro/target 表示忽略 springbootShiro 目录下的 taget 文件和 target 目录\nspringbootShiro/target/ 表示忽略 springbootShiro 目录下的 target 目录（不包括 target 文件）\n\n拓展：\n忽略文件语法规范：\n\n\n空行或是以 # 开头的行，即注释行将被忽略。\n\n可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。\n\n可以在后面添加正斜杠 / 来忽略文件夹，例如 build/c 即忽略 build文件夹。\n\n可以使用 ! 来否定忽略，即比如在前面用了 *.apk ，然后使用 !a.apk ，则这个 a.apk 不会被忽略。\n\n* 用来匹配零个或多个字符，如 *.[oa] 忽略所有以 .o或  .a 结尾\n\n*~ 忽略所有以 ~ 结尾的文件（这种文件通常被许多编辑器标记为临时文件）；\n\n[] 用来匹配括号内的任一字符，如 [abc] ，也可以在括号内加连接符，如 [0-9] 匹配0至9的数； \n\n? 用来匹配单个字符。\n\n\n\n看个例子：\n*.a      \t\t// 表示忽略 .a 文件!lib.a   \t\t// 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件/TODO    \t\t// 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODObuild/\t\t\t// 忽略 build/ 文件夹下的所有文件doc/*.txt\t\t// 忽略 doc/notes.txt, 不包括 doc/server/arch.txtdoc/**/*.pdf    // 忽略在 doc/  directory 下的所有的 .pdf 文件 \n\n\n\n\n\n1.6.3 添加到暂存区执行 git add . 命令，添加当前目录下的所有文件（夹）\n\n git add . 命令 表示添加当前目录下的所有文件（夹）添加到暂存区\n 注意：也可以进入到指定目录（cd  springbootShiro）执行 git add . 命令\n\n\n查看 springbootShiro 目录发现，target 目录已经被忽略，没有添加到暂存区\n\n1.6.4 提交到本地仓库执行git commit -m &quot;日志信息&quot; 命令提交\n\n提交命令不使用文件名称，默认提交当前所有暂存区的文件\n\n\n查看 springbootShiro 目录，发现此时 target 目录是被忽略的，没有提交到本地仓库：\n\n2、远程仓库操作回顾Git工作流程\n前面通过命令或者 TortoiseGit 操作的都是本地仓库是，接下来我们要操作远程仓库，示意图：\n一般工作流程如下：\n\n从远程仓库中克隆 Git 资源作为本地仓库。\n\n从本地仓库中 checkout 代码到工作区，然后进行代码修改\n\n在提交前先将代码提交到暂存区。\n\n提交到本地仓库，本地仓库中保存修改的各个历史版本。\n\n在修改完成后，需要和团队成员共享代码时，可以将代码 push 到远程仓库（git仓库）。\n\n\n下图展示了 Git 的工作流程：\n\n2.1 克隆远程仓库克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。\n可以通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地\n在存放的目录中打开 GitBash 窗口，输入命令：git clone 远程仓库地址：\n\n2.2 查看远程仓库如果想查看已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字\ngit remote 命令：在克隆的仓库中查看远程仓库服务器名称：\n\n解析：\n\n前面，我们克隆了远程仓库 myRepo1 到本地，其实这个远程仓库和本地仓库已经建立起关联关系，\n在这个克隆的远程仓库中执行 git remote 命令就能查询当前本地仓库和哪个远程仓库服务器（默认名称origin）建立了关联\n\ngit remote -v 命令可以列出远程仓库地址信息：\n\n解析：\n\n通过这个命令列出了远程仓库的地址信息\nfetch：表示获取远程仓库链接的地址，即：可以从远程仓库获取代码\npush：表示推送本地仓库代码到远程仓库的地址，即：可以将本地仓库的代码推送到远程仓库\n\n如果我们想要查看更详细的信息，可以使用 git remote show origin\n\n**注意：**如果是本地仓库没有和远程仓库建立关联，那么输入查看命令是没有信息显示的，例如在前面我们自己创建的本地仓库 repo1 中查看：\n\n2.3 添加远程仓库对于我们本地创建的Git仓库 repo1，是没有和远程仓库建立联系的，我们可以添加到指定的远程服务器上\ngit remote add &lt;shortname&gt; &lt;url&gt; 命令：添加一个新的远程 Git 仓库，同时指定一个可以引用的简写，\n示例：将本地仓库 repo1 添加到远程仓库（即：将本地仓库关联到远程仓库）\n在码云上新建一个远程仓库repo1（远程仓库和本地仓库名称可以不一致，但是建议保持一致）：\n\n创建后，初始化 readme 文件和 设置为开源仓库\n\n在本地仓库 repo1 中打开 GitBash，执行git remote add &lt;remote-name&gt; &lt;url&gt; 命令:\n\nshortname：通常使用默认的 origin，也可以自定义名称\nurl：远程仓库的地址\n\n\n添加成功后，就能查询到远程仓库的信息了\n练习：创建远程仓库 repo2，并将本地仓库 repo2 添加到该远程仓库\n2.4 拉取远程仓库代码：git pull从远程仓库拉取代码的命令有两个：get pull  和 get fetch\ngit pull &lt;remote-name&gt; &lt;branch-name&gt; 命令：是从远程仓库的指定分支获取最新版本并 merge（合并）到本地仓库\n注意：\n\n如果，当前本地仓库有文件，那么从原仓库拉取文件会报错：\nfatal: refusing to merge unrelated histories \n\n\n解析：\n\n因为本地仓库有文件，从远程仓库拉取文件下来，可能会覆盖当前的文件，所以拉取失败\n\n解决方式：\n\n在拉取的命令后面添加参数选项：–allow-unrelated-histories\n表示强制拉取，并合并到本地仓库\n\n执行强制拉取并合并到本地的命令后会进入到日志界面，不需要填写日志的话直接:wq! 保存推出即可\n\n拉取成功：\n\n2.5 拉取远程仓库代码：git fetch环境准备：将本地仓库 repo1 删除，重新初始化，并关联远程仓库repo1\n\ngit fetch 或者 git fetch origin master 命令：从远程仓库抓取文件\n\n执行完命令抓取命令后，远程仓库的的文件已经以二进制的文件形式抓取到本地仓库（.git 目录下的 objects 目录中）\n但是不会 merge 到本地工作空间（即：没有合并到工作空间中，不会显示）\n\n\n上面抓取的结果我们可以看到抓取到的分支是 origin&#x2F;master，\n需要执行 git merge origin/master 命令 ，将同步到本地仓库的文件 merge（合并）到本地工作空间\n\npull 和 fetch 的区别：\n\n\ngit pull 命令相当于  git fetch + git merge 两个命令的结合\n\n建议使用 git fetch 命令获取远程仓库文件，因为：\n\n\ngit fetch是将远程主机的最新内容拉到本地，用户检查后决定是否合并到分支中，而git pull则是将远程主机的最新内容拉下来直接合并即：git pull &#x3D; git fetch + git merge，可能产生冲突需要手动解决 \n\n当本地仓库存在文件时，从远程仓库拉取数据会报错，解决方式：\n\n添加：–allow-unrelated-histories 参数\n\n2.6 移除远程仓库日常工作中：可能会因为一些原因想要移除一个远程仓库 \n注意：移除远程仓库只是从本地移除远程仓库的记录，并不会真正影响到远程仓库\n可以使用 git remote rm &lt;remote-name&gt; 命令移除远程仓库\n\n2.7 推送到远程仓库前面我们将本地仓库 repo2 关联到远程仓库后，本地仓库中的文件并没有推送到远程仓库中\n推送本地仓库的文件到远程仓库之前要先拉取远程仓库的代码，这里我们的本地仓库有文件，所以需要先强制拉取文件：\n\n强制拉取命令：git pull origin master --allow-unrelated-histories\n\n\n通过git push &lt;remmote-name&gt; &lt;branch-name&gt; 命令将本地仓库的文件推送到远程仓库：\n\n第一次推送的时候需要输入码云的用户名和密码\n\n\n推送成功，本地仓库的文件和目录已经同步到了远程仓库中：\n\n小结：\n\n修改本地文件后，可以通过git push &lt;remmote-name&gt; &lt;branch-name&gt; 命令来同步到远程仓库\n\n3、Git 分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。\n3.1 查看分支分支有两种，一种是本地仓库分支，另一种是远程仓库的分支\n接下来操作 repo2 仓库，来查看分支：\n查看分支的命令：\n\ngit branch 命令：列出所有本地分支\ngit branch -r 命令：列出所有远程分支\ngit branch -a 命令：列出所有本地分支和远程分支\n\n效果如下：\n\n3.2 创建分支创建本地仓库分支，后面可以推送到远程仓库：\n命令：\n\ngit branch &lt;branch-name&gt; 命令：在本地仓库创建一个分支\n\n\n解析：\n\n上面的命令创建了两个分支：a1、a2，加上默认创建的 master 分支，查询结果有三个分支\n\n3.3 切换分支命令：\n\ngit checkout &lt;branch-name&gt; 命令：切换到指定的分支\n\n\n解析：\n\n上面的命令将当前的分支从 master 切换到 a1 分支\n查看分支：标 * 号的分支表示当前分支，或者通过行末括号中的名称也能分辨当前属于哪个分支\n\n3.4 推送至远程仓库分支命令\n\ngit push &lt;remote-name&gt; &lt;branch-name&gt; 命令：将本地分支推送至远程仓库分支\n\n\n练习：将 a2 分支推送到远程仓库分支\n解析：\n\n查看远程仓库中的 a1、a2分支，我们发现，a1、a2分支中的内容和 master 分支中的内容一样，\n原因： a1、a2 分支是在 master 分支的基础上创建出来的，随着我们在不同的分支上开发，修改内容，不同分支的代码会产生差异\n\n3.5 合并分支命令：\n\ngit merge &lt;branch-name&gt; 命令：将指定分支的内容合并到当前分支\n\n例如我们当前在 a1 分支下新增了一个文件 user.txt\n\n当我们切换到 master 分支后发现，master 分支下并没有 User.txt\n\n在当前 master 分支下，执行 git merge a1 命令即可将 a1 分支的文件合并到当前 master 分支下：\n\n注意：\n有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 在合并的时候就会提示会提示文件冲突，合并失败；\n此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决\n示例：\n在 master 分支下修改 User.txt 文件 → 添加缓存区  → 提交到本地仓库：\n\n切换到 a1 分支，修改 User.txt 文件 → 添加缓存区  → 提交到本地仓库：\n\n切换回 master 分支，将 a1 分支合并到 master 分支：\n\n解析：\n\nCONFLICT (content): Merge conflict in User.txt \t\t【表示合并内容发生冲突】Automatic merge failed; fix conflicts and then commit the result.\t\t【自动合并失败】\n行末的分支  (master|MERGING)  表示 master 分支在合并时发生错误\n\n打开 User.txt 查看内容发现，在合并时这里面多了很多多余的内容\n\n需要我们手动解决冲突内容（删除不需要的内容，保留需要内容），然后添加暂存区，提交到本地仓库即可：\n\n3.6 推送到远程将我们在本地仓库分支修改或者添加的文件推送到远程分支中：\n命令：\n\ngit push &lt;remote-name&gt; &lt;branch-name&gt; 命令：将本地分支的内容推送到指定远程分支\n\n\n查看远程仓库的分支，验证推送成功\n3.7 删除分支删除本地分支命令：\n\ngit branch -d &lt;branch-name&gt; 命令：删除指定的分支\n\n\n如果要删除的分支中进行了一些开发动作（比如修改了文件没有推送到远程仓库中），此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D\n示例：\n\n此时：本地仓库 a1 分支修改的内容没有推送到远程仓库，不能直接通过 git branch -d &lt;branch-name&gt; 命令直接删除 a1 分支，可以将命令中的-d参数改为-D 强制删除；\n切换到 master 分支删除 a1：\n\n如果要删除远程仓库中的分支，可以使用命令\n\ngit push &lt;remote-name&gt; –d &lt;branch-name&gt; 命令：可以删除指定的远程仓库：\n\n\n执行命令后查看远程仓库分支，验证删除成功\n4、Git 标签像其他版本控制系统（vcs）一样，GIt可以给历史中某一个提交打上标签，以示重要；比较有代表的就是使用这个功能来标记发布节点（v1.0，v2.0 等）；\n标签指的是某个分支某个特定时间点的状态，通过标签，可以很方便的切换到标记时的状态\n4.1 列出已有标签命令：\n\ngit tag 命令：列出当前标签\n\n示例（当前本地仓库还没有标签）：\n\n4.2 创建标签命令：\n\ngit tag &lt;tag-name&gt; 命令：用来创建一个标签\n\n示例：创建两个标签\n\n标签的作用是用来记录状态（版本）的，所以通常使用 v 开头来标签\n\n\n 也可以通过\n\ngit show &lt;tag-name&gt; 命令：来显示标签的详细信息\n\n\n解析：\n\n详细信息中列出了：提交的标识字符串、作者（用户）信息、提交的日期信息等等\n\n4.3 推送到远程仓库和前面的推送分支命令类似：\n\ngit push &lt;remote-name&gt; &lt;tag-name&gt; 命令：将指定本地标签推送到远程仓库\n\n\n注意：\n\n当前 v1.0 和 v1.1 两个标签标记的内容是一样的\n\n4.4 检出标签通常情况下会新建一个分支，指向某个标签：\n\ngit checkout -b &lt;branch-name&gt; &lt;tag-name&gt; 命令：用于创建一个新的分支，并检出指定标签到这个分支\n\n\n执行完命令后会切换到创建的 a3 分支，这个分支的内容就是前面 v1.0 版本的内容，在这个版本中我们可以继续开发，例如：添加 login.txt 文件：\n\n开发完成后，可以再创建一个标签，标记为 v2.0 版本，提交到远程仓库\n\n小结：\n\n标签通常再一些重要的节点使用，例如发布的时候，下次更新或者升级完成后发布的时候…\n\n4.5 删除标签删除标签分为删除本地标签和远程标签：\n\ngit tag -d &lt;tag-name&gt; 命令：用于删除指定的本地标签；\ngit push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; 命令：用户伤处指定的远程标签，                              \n注意：语法中 :refs/tags/ 是固定写法\n\n \n第四章 TortoiseGit管理文件版本1、本地仓库操作1.1 初始化本地仓库新建仓库3：repo3，在目录中右键选择：”Git create repository here…” (在这里创建版本库)\n\n默认不勾选：”Make it Bare(No working directories)” （表示：制作纯版本库）\n\n初始化本地仓库成功：\n\n1.2 添加文件当前工作目录中新增一个 aaa.txt 文件\n\n选中文件，右键 → TortoiseGit  → Add\n\n添加成功：\n\n添加（到缓存区）成功后，文件会有一个蓝色 + 号：\n\n1.3 提交文件选中已追踪（添加到缓存区）的文件，右键选择 Git commit → &quot;master&quot;... 将文件提交到版本库中：\n\n填写提交日志信息，点击 commit 按钮提交：\n\n提交成功后，文件的状态为绿色√号\n1.4 修改文件被版本库管理的文件不可避免的发生修改，此时只需要直接对文件修改即可，修改完毕后需要将修改的文件提交到版本库。\n修改文件（修改后文件会变为红色感叹号）：\n\n选中修改后的文件，右键提交：\n\n添加提交日志信息，提交：\n\n提交成功成功后，文件状态由红色 ! 号变为绿色 √ 号。\n1.5 查看修改历史在开发过程中可能会经常查看代码的修改历史，或者叫做修改日志。来查看某个版本是谁修改的，什么时间修改的，修改了哪些内容。\n可以选中文件，右键选择 “show log（显示日志）” ：\n\n查看修改历史：\n\n1.6 差异比较当文件内容修改后，需要和修改之前对比一下修改了哪些内容，此时可以使用“比较差异功能”\n修改文件内容：\n\n选择” Diff（比较差异）”\n\n对比修改后的内容：\n\n1.7 还原修改当文件修改后不想把修改的内容提交，还想还原到未修改之前的状态。\n此时可以使用 “Revert（还原）” 功能\n\n点击 “Ok” 还原\n\n还原成功！\n注意：\n\n此操作会撤销所有未提交的修改，所以做还原操作是需要慎重慎重！！！\n\n1.8 删除文件需要删除无用的文件时可以使用git提供的删除功能直接将文件从版本库中删除。\n\n1.9 综合练习：将java工程提交到版本库将 springbootShiro  工程复制到工作区中，提交到版本库中，并且忽略 target 目录\n1.9.1 忽略文件或目录选中要忽略的文件&#x2F;目录，右键 → TortoiseGit →  add to ignore list （添加到忽略列表）\n\n选择 忽略的类型和  .gitignore 文件存放的位置（默认即可）：\n\n完成后在工作空间的根目录多出一个.gitignore文件，这个文件就是文件忽略文件，当然也可以手工编辑。其中的内容就是把 springbootShiro 中的 target 目录忽略掉。\n\n1.9.2 添加暂存区将工程和忽略文件添加到暂存区：\n\n勾选需要添加的文件（这里默认全选），点击ok\n\n点击ok，完成暂存区添加\n1.9.3 提交代码先将 选中项目 和 .gitignore 文件\n右键然后提交代码：\n\n提交成功后查看工程里面的文件，发现 target 目录没有提交到版本库\n\n输入提交日志，点击 commit 提交按钮\n\n查看 springbootShiro 目录，验证 target 目录是否被忽略\n2、远程仓库操作2.1 克隆远程仓库克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。\n在码云上创建一个远程仓库 myRepo2（readme初始化，开源仓库）：\n\n在存放目录中右键 → Git clone…，复制远程仓库的地址到 URL 选项中 → Ok:\n\n克隆成功：\n\n2.2 查看远程仓库在克隆的仓库中右键 → TortoiseGit → settings\n然后，在设置的 Remote 中可以看到远程仓库服务器名称，点击名称，显示远程仓库地址：\n\n2.3 添加远程仓库同样我们，也可以通过 TortoiseGit  将本地仓库添加到远程仓库：\n在码云新建远程仓库： repo3\n\n在本地仓库 repo3 中右键 → settings\n然后在 Remote 中填入名称和 URL → 确定即可：\n\n名称自定义，通常使用 Origin \nurl：远程仓库地址\nPush Url：远程仓库地址（暂时可以不填写）\nPutty Key：这里使用 https 协议传输，不需要填\n\n\n“是否从新添加的远程服务器获取分支” ，选 “是”\n\n默认ok\n\n成功后 close\n\n完成后可以使用 GitBash 命令查看，验证是否添加成功\n2.4 推送到远程仓库将本地仓库的文件推送到远程仓库\n→ 在工作区间中右键 TortoiseGit → push  推送\n\n→ 填写要推送到哪个分支 → ok\n\n出现异常：\n\n异常原因解析：\n在推送的之前要先拉取远程仓库的代码，以防止覆盖，我们的本地仓库有文件，所有要强制拉取，可以使用 git 命令强制拉取（快速简单）\n\n然后重新推送：\n\n到远程仓库查看，验证是否推送成功\n\n2.5 TortoiseGit拉取右键 TortoiseGit → pull → Ok\n\n注意：\n\n如果本地仓库有文件，在使用 TortoiseGit 拉取文件时，同样可会报错\n可以使用 GitBash 的命令强制拉取后，再使用 TortoiseGit 操作（使用 git 命令的方式解决方便快速）\n\n2.6 移除远程仓库在本地仓库的工作空间右键 → TortoiseGit → Settings \nRemote → 选中远程服务器名称（origin） → remove → 确定：\n\n移除之后，可以只用 GitBash 的查看命令，验证是否移除\n3、分支操作上面如果将本地仓库repo3 的远程仓库移除了，这里需要重新添加上，演示本地仓库和远程仓库的分支操作\n3.1 创建分支右键 → TortoiseGit → Create Branch… （创建分支）\n\n填写分支名称，选择分支状态：Base on（默认基于 master 分支，创建出来的分支和 master 分支状态一致）\n\n3.2 切换分支右键 → TortoiseGit → Switch&#x2F;Checkout… （切换分支）\n\n选择分支 → Ok 即可切换\n\n切换后的操作和之前命令操作是一样的\n3.3 合并分支在房前 master 分支下右键 → TortoiseGit → merge… （合并分支）\n\n选择要合并的分支 → Ok 即可\n\n3.4 推送到远程仓库选择 push 选项：\n\n选择要推送的分支，定义远程分支的名称（一般和本地分支名称保持一致）\n\n推送成功后可以在远程仓库查看\n\n4、标签操作略\n第五章 在 idea 中使用 Git在实际开发中，我们都是在开发工具 idea 中开发的，在开发完成之后可以直接在 idea 中完成 git 的相关操作，比如提交代码、推送到远程仓库等等。\n1、配置Git老版本的 IntelliJ IDEA 如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径；\n最新版本会帮我们自动找到 Git 的安装路径；\n点击Test 按钮 测试是否正确配置，如果是正确的则会提示安装的 Git 的版本信息\n\n2、创建工程并添加至Git环境准备：\n创建一个新的 Module：gitTest（maven版的普通Java项目即可）：\n\n添加一些开发的内容：\n\n将当前项目添加到 Git 其实就是在项目的根目录下添加 git 仓库：\n\n在 Idea 上方的 VSC 选项中选择： VCS Operations（VCS 操作）\n\n→ Create Git Repository… \n\n→ 选择当前项目的根目录（注意是在src 同级目录，即：在 gitTest 目录创建git仓库）：\n\n在目录中查看，验证成功创建 git 仓库：\n\n此时，项目根目录下的文件还没有交给 git 版本控制管理\n\n\n将项目添加至Git管理后，可以从IDEA的工具栏上看到Git操作的按钮：\n\n3、忽略文件和目录在当前项目的根目录下创建 .gitignore 文件，把需要忽略的文件和目录编辑进去：\n\n我们可以使用 maven 编译一下当前项目，就会出现 target 目录，可以更好的看到后面添加和提交等效果：\n\n4、添加到暂存区其实 IDEA 可以不需要添加到暂存区直接提交的（简化了步骤），\n如果我们需要添加到暂存区可以右键当前项目 → GIt 选项 → Add ：\n\n在目录中可以看到允许被提交的文件状态变为 + 号了，即添加到了暂存区：\n\n5、提交文件提交的方式地方有很多：\n可以右键项目 → Git 选项 → Commit…\n\n也可以使用 Git 按钮提交：\n\n还可以在 VCS 中选择 Commit…\n\n这些提交的效果是一样的，在弹出的对话框中添加提交日志信息 →  commit：\n\n如果需要看到目录，可以在提交界面的 Group by 按钮中勾选 Model 和 Directory：\n现在项目中添加一个 配置文件 jdbc.properties，再次提交，勾选 Model 和 Directory 后可以看到要提交的文件在哪个目录中：\n\n6、推送到远程仓库在码云创建一个新的远程仓库 gitTest：\n\n这里不初始化 readme 文件，不然后面需要解决第一此推送或拉取，本地仓库有文件冲突，需要强制拉取解决冲突\n\n\n在idea 中右键项目 → Git → Push\n或者 VCS 中 push\n或者 找到 Push 按钮：\n\n选择定义 Define remote（远程仓库），添加远程仓库地址：\n\n点击 push 推送本地仓库到远程仓库：\n \n推送成功后查看远程仓库：\n\n7、从远程仓库克隆工程到本地选择从VCS 克隆工程：\n\n\n填写远程仓库地址，选择保存路径：\n\nTrust Project：\n\n克隆成功：\n\n8、从远程拉取代码我们可以打开前面 gitTest 项目\n\n因为这两个本地仓库都是关联的同一个远程仓库，所以可以模拟两个用户操作同一个项目：\n\n注意区分两个本地仓库，前面我们自己创建的叫 gitTest， 后面克隆下来的叫 git-test\n\n\n在 gitTest 项目中：\n添加 UserService 接口：\n\n→ 提交到本地仓库：\n\n→ 推送到远程仓库：\n\n查看远程仓库，推送成功：\n\n在 git-test 项目中：\n点击 Update Project 选项拉取代码到本地，或者点击选择 Pull 选项也可以将远程仓库的代码拉取到本地：\n\n练习：\n在 gitTest 项目中修改 jdbc.properties 文件的内容，并推送到远程仓库\n在 git-test 项目中拉取远程仓库中修该的内容\n9、版本对比每一次提交都都会产生新的版本，我们可以使用 idea 来比较不同的版本文件的区别：\n例如我们想要查看  jdbc.properties 文件不同版本的区别：\n打开  jdbc.properties 文件，在文件中右键 → Git 选项 →  Compare with Revision…（比较版本信息）：\n\n选择一个版本比较差异：\n\n为了看到效果，我提交了两次，\n第一次提交 jdbc.username \n第二次提交 jdbc.userpassword\n\n\n左边是选择的版本内容，右边是最新的内容：\n\n10、创建分支可以在 VCS 中 选择  New Branch… 选项来创建分支：\n\n填写要创建的分支名称：\n\n勾选 Checkout branch 表示创建 a1 分支，并且切换到 a1 分支:\n\n\n创建并切换成功：\n\n切换成功以后代码没有变化，是因为当前 a1 分支和 master 分支的状态是一样的\n11、切换分支可以在底部 Git 选项中，右键想要切换的分支，选择 Checkout 切换分支\n\n也可以在顶部 VCS 中选中 Branchs…  选项，找到想要切换的分支，然后 Checkout 即可：\n\n12、分支合并我们可以在 b1 分支上开发，提交并推送到远程仓库，然后在 master 分支上操作，将 b1 分支合并到 master 分支：\n在 b1 分支中的  User 类中添加 username 属性：\n\n提交并推送到远程仓库（可以同时操作）：\n\n推送到远程仓库：\n\n切换到 master 分支，此时的 User 用户是没有 username 属性的：\n\n在顶部 VCS 中选中 Merge…  选项:\n\n选择合并本地的 a1 分支即可（origin&#x2F;a1 是远程的分支）：\n\n合并成功：\n\n第六章 使用 SSH 协议传输数据1、Git 支持的传输协议由于 Git 的远程仓库不在本地，当我们在使用远程仓库时（例如克隆、拉取、推送）就会涉及到数据的网络传输，Git 支持多种数据传输协议：\n\n本地协议（Local）\nHTTPS 协议\nSSH（Secure Shell）协议\nGit 协议\n\n我们前面的操作都是基于 HTTPS 协议传输的，而码云支持两种传输协议：\n\n2、什么是 SSH 协议SSH 是 Sercure Shell（安全外壳协议）的缩写，由 IETE 的网络小组（Network Working Group）制定；\nSSH 是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议；利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题\n由于本地 Git 仓库和远程仓库之间的传输是通过 SSH 加密的，所以必须要让远程仓库服务器认证你的 SSH key，在此之前，必须要先生成 SSH key；\n使用 SSH 协议通信时，推荐使用基于密钥的验证方式，我们需要先为自己创建一对密钥（公钥和私钥），并将公钥放在需要访问的服务器上。\n解析：\n其实前面我们使用 https 协议传输的时候，它是基于我们码云的账户和密码验证的，我们后面的操作之所以不需要每次输入用户名和密码，是因为第一次操作时验证了用户名和密码，然后将用户名和密码凭证保存在了我们的计算机上，我们可以查看到：\n控制面板 → 用户账户 → 管理 Windows 凭据\n\n普通凭据中就可以看到，我们的 码云账户和密码永久保存在了计算机上：\n\n3、生成密钥在使用密钥之前我们可以尝试复制一个 SSH 协议的远程仓库地址克隆远程仓库，结果肯定是不行的\n前面我们了解了 Https 协议是基于用户名和密码验证的，而 SSH 协议传输数据是基于一对密钥验证的，所以我们要给自己生成一对密钥\n可以使用 GitBash 工具生成公钥和私钥：\n任位置打开 GitBash，执行命令：\n\nssh-keygen -t rsa 命令：生成公钥和私钥\n一路回车，执行完成后后 windows 本地用户 .ssh 目录中生成如下名称的公钥和私钥\n\n\n4、服务器配置公钥私钥就保存在当前用户的 .ssh 目录中即可，我们需要将公钥的内容复制下来，在远程仓库中配置公钥：\n复制公钥内容：\n\n码云配置公钥：\n右边账户信息下拉框，选择 设置：\n\n在安全设置中，选择 SSH公钥，粘贴公钥 → 确定：\n\n验证账户密码后，添加成功：\n\n5、使用 SSH 协议当我们在服务器添加好公钥之后，就可以使用 SSH 协议传输数据了：\n复制远程仓库的 SSH 地址：\n\n使用 SSH 协议克隆远程仓库到本地：\n\n第七章 常用命令查询1、新建代码库 git init\n创建（初始化）空仓库，由git接管，文件的改动（修改、删除）都能监测到\n例外情况：doc等办公文档可以监测到文件大小改变，无非监测到具体内容改变无法监测到二进制文件内部内容信息的改变，只能监测文件大小改变所以说git比较适合纯文本类文件版本控制（txt,md）\n\n常见的二进制文件：\n图片、视频、音频、办公文档（doc、xls）\n# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n\n什么是本地仓库？\n\n在你的电脑通过git init就是初始化了一个本地仓库\n\n\n什么是远程仓库？\n\n就是你在gitee或者github等在线开源网站里面创建一个仓库称为远程仓库\n\n\n什么是工作区？\n\n就是你写作的文件目录，这里面我们称为工作区\n\n\n什么是暂存盘？\n\n什么是版本库？\n\n\n2、配置 git configGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;\n\n\n\n3、增加&#x2F;删除文件 git add&#x2F;git rm# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .$ git add -A # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n\n\n\n4、代码提交 git commit# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n\n提交一个版本的步骤\n先看是否存在仓库，没有使用git init 创建仓库\n\ngit add 添加到暂存盘\n\ngit commit 提交一个版本\n\n\ngit commit –amend 的作用用于修改最近一次的提交，包括：\n\n修改提交信息（commit message）\n添加遗漏的文件到上一次提交中\n修改提交的内容（比如你刚提交完，发现漏改了一行代码）\n\n⚠️ 注意：只能修改尚未推送到远程仓库的最新提交。如果已经推送，修改后需要强制推送（git push --force），这可能影响协作，需谨慎！\n5、分支#修改主分支名为main git config --global init.defaultBranch main# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n\n\n6、标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]\n\n git show\n \n7、查看信息 status,log,reflog,blame,show,diffgit status\n查看状态\n\n可以查看\n\n那些文件被修改了？\n增加了那些文件？\n删除了那些文件？\n是否有修改？（提交了版本之后）\n\n\n对于二进制类型文件，只能监测文件是否被修改，或者被删除，具体改了什么不清楚\n\n比如doc文件、git只能知道它被修改了，不知道改了什么内容\n除了doc还有mp4、jpg、gif等等非文本文件。\ngit diff\ngit diff [file]显示暂存区和工作区的差异\n\ngit diff –cached [file]或者git diff –staged [file]\n\n\n显示暂存区和上一次提交(commit)的差异\ngit show\ngit show命令是Git的一个强大命令，它用于显示Git仓库中的各种对象的详细信息。这些对象可以是提交、分支、标签、或者具体的文件。\n\ngit blame\ngit blame 是Git 命令，用于显示文件中每行代码的最后修改版本及作者信息，帮助追踪代码变更历史。\n\n运行 git blame &lt;文件路径&gt; 可显示指定文件的每行代码最后一次修改的提交信息（作者、时间、代码内容）。\n\n例如：git blame app.js\n\n\ngit stash\ngit stash是git中用于临时保存工作目录和暂存区未提交的修改的命令，允许用户切换到干净的工作区处理其他的任务，后续可以恢复这些修改\n\n保存修改，将所有未提交的更改存入栈，恢复工作区至最新状态。\n\n查看条目 git stash list 列出所有储藏条目（如stash@{0}为最新）\n\n恢复修改：git stash pop：应用并删除最新的储藏条目\n\n\ngit stash apply ：应用指定条目但不删除\n\n删除条目：git stash drop  移除指定条目\n\n测试步骤\n\n\ngit clone 远程仓库hello9-15\n\n\n\n再本地工作区随便修改一下（注意不要添加暂存和保存版本）\n\n\n\n然后再远程仓库手动修改一下1.txt文件，并提交一个版本\n\n\n\n然后执行git pull拉起远程仓库的数据，发现报错了，拒绝拉起\n\n\n\n此时使用git stash将工作区存储起来\n\n\n\n然后再使用git pull拉去，这个时候允许拉去了\n\n\n\n然后想起恢复刚才的内容，使用git stash list 查看，使用git stash pop恢复\n\n\n\n手动解决冲突，git add -A\n\n\n\n完成\n\n\n\n\n\n# 显示有变更的文件$ git status\t#查看状态# 显示当前分支的版本历史(看历史版本到当前版本的日志)$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交(查看所有历史版本信息)#注意这里查看的是一个短的版本号，例如 da213db$ git reflog\n\ngit blame\n \n8、远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n\n\n\ngit pull# -u选项安全模式git push -u origin main\n\n\n\ngit pull 和 git fetch 的区别：git fetch 和 git pull 都用于从远程仓库获取最新数据，但它们的行为有本质区别：\n\n✅ git fetch —— 仅下载，不合并\n作用：从远程仓库下载最新的提交、分支、标签等对象到本地仓库，但不会自动合并或修改你当前的工作区和分支。\n\ngit fetch origin\n\n\n下载远程所有更新（如 origin/main, origin/feature 等），存储在本地的远程跟踪分支（如 origin/main）。\n你的本地分支（如 main）不会被改动。\n你可以先用 git log、git diff 查看远程变更，再决定是否合并。\n\n🔹 安全！推荐在不确定远程变更内容时使用。\n📌 示例：\ngit fetch origingit log main..origin/main   # 查看远程有而本地没有的提交git diff main origin/main   # 查看具体差异git merge origin/main       # 手动合并（可选）\n\n\n✅ git pull —— 下载 + 自动合并\n作用：git fetch + git merge 的组合命令。它会先从远程拉取最新数据，然后自动尝试合并到你当前所在的本地分支。\n\ngit pull origin main# 等价于：git fetch origingit merge origin/main\n\n\n如果远程和本地没有冲突，会自动快进（fast-forward）或创建合并提交。\n如果有冲突，会暂停并提示你手动解决冲突。\n\n⚠️ 可能直接修改你的工作区！在未保存或未提交本地修改时容易出问题。\n\n刷新远程仓库——成功上传同步\n \n \n9、撤销修改工作区撤销修改\n在工作区修改了文件\n\n\n使用git status 查看那些文件被修改了\n使用git checkout – 被恢复的文件\n\n$ git status$ git checkout – readme.txt   &#x2F;&#x2F; 或者   git restore readme.txt\n暂存盘撤销修改\n\n在工作区修改了文件\n\n\n\n\n将被修改了文件添加到暂存盘\n使用git status查看那些文件被修改了\n使用git reset HEAD 被恢复的文件\n使用git checkout – 被恢复的文件\n\n方法1\n$ git status$ git reset HEAD readme.txt$ git checkout -- readme.txt\n\n方法2\ngit restore --staged readme.txtgit restore readme.txt\n\n注意：先修改一下文件，然后使用git add 将修改过后的文件添加到暂存盘，然后做上面的练习\n版本回退\ngit reset –hard HEAD^   回退上一个版本\n\ngit reset –hard 版本号可以使用git reflog 查看版本号\n\ngit revert 通过用一次新的commit来回滚之前的commit\n\n操作步骤\n\n\n\n\n初始化一个仓库，并且新建1.txt\n在1.txt中输入111，提交版本1\n在1.txt中输入222，提交版本2\n执行git revert HEAD 撤销最后操作生成新的版本\n也可以撤销指定的版本生成新版本\n\n\ngit revert 和 git reset的区别\n\ngit revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；\n\ngit reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\n\n\n\n\n删除文件撤销注意只要这个文件添加过一次版本，那么你将永远无非删除它。\n\n\n在工作区永久性删除文件\n\n\n\n\n使用git checkout – 被删除的文件或者 git restore 被删错的文件\n\n$ rm readme.txt                           rm 删除文件的意思 (linux命令)$ git checkout – readme.txt        恢复文件\n\nrm  linux下删除命令\nmkdir  linux下创建文件夹命令\ngit rm 不但会把工作区里面的文件删除，还会把版本库里面的文件也删除，做到彻底移除掉这个文件\n\n# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n\n回退到上个版本\ngit reset –hard HEAD^\n\n–hard  一种模式，表示完整恢复数据HEAD   表示当前的^          回退一个版本，^^表示上一个的上个版本\n回退到指定的版本\ngit reset –hard 版本号\n\n版本号可以通过git reflog来查\ngit stash \n克隆码云仓库\ngit stash\ngit stash list\ngit pull\ngit stash pop\n保留双方修改\ngit add -A\n \n10、其他# 生成一个可供发布的压缩包$ git archive\n\n\n\n\n\n11、小结$ git init                                                  # 初始化本地git仓库（创建新仓库）$ git config --global user.name &quot;xxx&quot;                       # 配置用户名$ git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件$ git config --global color.ui true                         # git status等命令自动着色$ git config --global color.status auto$ git config --global color.diff auto$ git config --global color.branch auto$ git config --global color.interactive auto$ git config --global --unset http.proxy                    # remove  proxy configuration on git$ git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库$ git status                                                # 查看当前版本状态（是否修改）$ git add xyz                                               # 添加xyz文件至index$ git add .                                                 # 增加当前子目录下所有更改过的文件至index$ git commit -m &#x27;xxx&#x27;                                       # 提交$ git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）$ git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步$ git rm xxx                                                # 删除index中的文件$ git rm -r *                                               # 递归删除$ git log                                                   # 显示提交日志$ git log -1                                                # 显示1行日志 -n为n行$ git log -5$ git log --stat                                            # 显示提交日志及相关变动文件$ git log -p -m$ git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容$ git show dfb02                                            # 可只用commitid的前几位$ git show HEAD                                             # 显示HEAD提交日志$ git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本$ git tag                                                   # 显示已存在的tag$ git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag$ git show v2.0                                             # 显示v2.0的日志及详细内容$ git log v2.0                                              # 显示v2.0的日志$ git diff                                                  # 显示所有未添加至index的变更$ git diff --cached                                         # 显示所有已添加index但还未commit的变更$ git diff HEAD^                                            # 比较与上一个版本的差异$ git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异$ git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的$ git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容$ git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）$ git branch                                                # 显示本地分支$ git branch --contains 50089                               # 显示包含提交50089的分支$ git branch -a                                             # 显示所有分支$ git branch -r                                             # 显示所有原创分支$ git branch --merged                                       # 显示所有已合并到当前分支的分支$ git branch --no-merged                                    # 显示所有未合并到当前分支的分支$ git branch -m master master_copy                          # 本地分支改名$ git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出$ git checkout -b master master_copy                        # 上面的完整版$ git checkout features/performance                         # 检出已存在的features/performance分支$ git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支$ git checkout v2.0                                         # 检出版本v2.0$ git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出$ git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）$ git merge origin/master                                   # 合并远程master分支至当前分支$ git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改$ git push origin master                                    # 将当前分支push到远程master分支$ git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支$ git push --tags                                           # 把所有tag推送到远程仓库$ git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支$ git mv README README2                                     # 重命名文件README为README2$ git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）$ git rebase$ git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）$ git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933$ git ls-files                                              # 列出git index包含的文件$ git show-branch                                           # 图示当前分支历史$ git show-branch --all                                     # 图示所有分支历史$ git whatchanged                                           # 显示提交历史对应的文件修改$ git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818$ git ls-tree HEAD                                          # 内部命令：显示某个git对象$ git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH$ git reflog                                                # 显示所有提交，包括孤立节点$ git show HEAD@&#123;5&#125;$ git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态$ git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志$ git show HEAD~3$ git show -s --pretty=raw 2be7fcb476$ git stash                                                 # 暂存当前修改，将所有至为HEAD状态$ git stash list                                            # 查看所有暂存$ git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存$ git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存$ git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”$ git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT$ git gc$ git fsck$ git archive\t\t\t\t\t\t\t\t\t\t\t\t# 生成一个可供发布的压缩包\n\ngit revert 和 git reset的区别\ngit revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除\ngit reset --hard HEAD^git revert HEAD\n\n\n\n先准备3个版本\n \ngit reset --hard HEAD^\n\n \ngit revert HEAD\n\n \ngit revert \ngit add -A\ngit revert –continue\n","categories":["Git"],"tags":["Git"]},{"title":"git笔记_0915","url":"/2025/09/17/git%E7%AC%94%E8%AE%B0_0915/","content":" \n 注意：避免在 仓库 创建 仓库项目（套娃） \n修改分支名：\ngit config –global init.defaultBranch master\ngit config –global init.defaultBranch main \n删除.git文件夹后更新 仓库 gti inir 成功\n \n第一步：配置用户名\ngit config --global user.name &quot;shuning&quot; \n\n第二步：配置邮箱\ngit config --global user.email &quot;sn2978@foxmail.com&quot;\n\n第三步：配置git打开的编辑器\ngit config\n# 设置编辑器为记事本，默认是linux的VIM编辑器，注意你确认您的记事本在C盘路径下git config --global core.editor &quot;C:/Windows/notepad.exe&quot;\n\n \ngit clonegit clone git@gitee.com:vant-contrib&#x2F;vant.git\n冲突可以在后面取别名\n\n先配置SSH公钥\n \n \ngit add \ngit commit提交版本\ngit commit -m “描述”\n \n注意：必须先提交到暂存add，之后提交commit\nGit 如何初始化并提交仓库？\n检查是否已初始化：查看是否存在 .git 文件夹。  \n\n有 → 可直接使用 Git 命令管理；  \n无 → 需执行 git init 初始化仓库。\n\n\n添加文件到暂存区：使用 git add &lt;文件名&gt; 或 git add . 添加所有文件。\n\n提交到本地仓库：使用 git commit -m &quot;提交描述&quot; 提交修改。\n\n（可选）关联远程仓库并推送：git remote add origin &lt;远程地址&gt;git push -u origin &lt;分支名&gt;\n\n\n📌 核心命令三步走：git init → git add . → git commit -m &quot;xxx&quot;\n \n \n","categories":["Git"],"tags":["Git"]},{"title":"Git作业_0918","url":"/2025/09/18/Git%E4%BD%9C%E4%B8%9A_0918/","content":"一、主观题1. 你会使用 Git 吗？（以面试者的口吻回答，要详细）Git 是一个分布式版本控制系统，能在工作中高效管理代码版本、协作开发和解决冲突。\n核心能力：\n\n日常操作：使用 git clone 复制远程仓库，git add 和 git commit 提交更改，git push/pull 同步远程代码，以及 git branch/merge 管理分支。\n高级功能：用 git stash 暂存未完成的工作，用 git rebase 整理提交历史，并通过 git reflog 恢复误操作。\n例如，在团队协作中，创建 feature 分支开发新功能，完成后通过 PR 合并到 main 分支。\n\n\n场景经验：曾处理过代码冲突：手动编辑冲突文件 → git add 标记解决 → git commit 完成合并。我还配置过 .gitignore 忽略编译文件（如 target/），确保仓库整洁。\n\n2. 列举工作中常用的几个 git 命令？（以面试者的口吻回答，要详细）工作中最常用的 Git 命令包括：\n\ngit status：查看工作区和暂存区状态。例如修改文件后运行它，会显示 modified: file.txt，提示未提交的变更。\n**git add -A**或者git add .：将所有变更添加到暂存区。若只添加特定文件，用 git add file.txt。\ngit commit -m &quot;message&quot;：提交暂存区的变更到本地仓库。例如 git commit -m &quot;修复登录逻辑&quot; 会生成一个带描述的新版本。\ngit push origin main：推送本地提交到远程仓库的 main 分支。首次推送需关联分支：git push -u origin main。\ngit pull：拉取远程最新代码并自动合并（等价于 git fetch + git merge）。若本地有未提交变更，需先用 git stash 暂存。\ngit checkout -b feature：创建并切换到新分支（如 feature）。完成后用 git merge feature 合并回主分支。\n\n3. 简单介绍一下 Git 的工作流程（以面试者的口吻回答，要详细）Git 的标准工作流程分为五步：\n\n克隆仓库：用 git clone 仓库地址 下载远程仓库到本地。\n创建分支：基于 main 分支新建开发分支：git checkout -b dev。\n开发与提交：在工作区修改代码 → git add -A 添加到暂存区 → git commit -m &quot;描述&quot; 提交到本地仓库。\n同步远程：定期 git pull origin main 拉取团队更新，避免冲突；开发完成后 git push origin dev 推送分支。\n合并与部署：提交 PR&#x2F;MR 请求将 dev 合并到 main，通过代码审核后部署到生产环境。\n\n4. Git 是用什么语言编写的？Git 主要使用 C 语言编写，部分脚本用 Shell 和 Perl 实现。C 语言的高效性使 Git 能快速处理大型项目（如 Linux 内核）。\n5. 什么是 git stash? 什么是 git stash drop？\ngit stash：\n临时保存工作区的未提交变更，方便切换分支或拉取代码。例如：\ngit stash        # 保存变更git pull         # 拉取远程代码git stash pop    # 恢复变更\n\ngit stash drop：删除指定的暂存条目。\n\n例如 git stash drop stash@&#123;0&#125; 删除第一次保存的内容。\n与 git stash pop（恢复后自动删除）不同，drop 只删除不恢复。\n\n\n\n6. 我提交版本是写了版本描述，发现写的不好，想修改，怎么修改？使用 git commit --amend 修改最近一次提交的描述：\ngit commit --amend -m &quot;新描述&quot;  # 直接替换描述\n\n若需修改提交内容，先更新文件 → git add -A → 再运行git commit --amend\n注意：若已推送到远程，需强制推送（git push --force），但可能影响团队协作，应谨慎使用。\n7. 大公司的分支一般有哪些分支？ 这些分支的工作流程是什么？大公司常用 Git Flow 分支模型：\n\n分支类型：\nmain&#x2F;master：生产环境代码，仅存放稳定版本。\ndevelop：集成分支，合并所有新功能。\nfeature/*：功能分支，从 develop 分出，开发完成后合并回 develop。\nrelease/*：预发布分支，用于测试和修复 Bug，合并到 main 和 develop。\nhotfix/*：热修复分支，从 main 分出，紧急修复生产环境问题。\n\n\n工作流程：\n新功能在 feature/login 分支开发。\n完成 → 提交 PR 合并到 develop。\n测试通过 → 从 develop 创建 release/v1.0 分支。\n预发布测试 → 合并到 main 并打标签（git tag v1.0）。\n生产环境 Bug → 从 main 创建 hotfix/issue1，修复后合并回 main 和 develop。\n\n\n\n8. 练习一下分支合并（没有冲突和有冲突）\n无冲突合并：\ngit checkout main         # 切换到目标分支git merge feature-login   # 合并 feature-login 分支git push origin main      # 推送合并结果\n\n若两分支无重叠修改，Git 自动完成合并（Fast-forward）。\n\n有冲突合并：\n\n合并时报错：CONFLICT (content): Merge conflict in file.txt。\n\n打开冲突文件，手动解决（删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记）。\n\n标记解决：\ngit add file.txt      # 添加解决后的文件git commit -m &quot;解决合并冲突&quot;  # 完成合并\n\n\n\n9. 练习一下抓取远程分支和推送指定的分支到远程\n抓取远程分支：\ngit fetch origin         # 获取远程所有分支信息git checkout -b dev origin/dev  # 创建本地分支并关联远程分支\n\n推送指定分支：\ngit push origin dev  # 推送本地 dev 分支到远程 dev\n\n10. 什么是 clone 克隆、branch 分支和 fork 复刻？区别是什么？\nClone（克隆）：复制远程仓库到本地，如 git clone https://gitee.com/project.git，创建完整的本地副本。\n\nBranch（分支）：在仓库内创建独立开发线，如 git branch feature，用于隔离开发新功能。\n\nFork（复刻）：在代码平台（如 Gitee）复制他人仓库到自己的账户，创建独立新仓库，用于贡献开源项目。\n\n区别：\n\n\n\n操作\n范围\n目的\n\n\n\nClone\n本地\n获取代码到本地\n\n\nBranch\n仓库内\n并行开发新功能\n\n\nFork\n平台账户之间\n独立修改并提交回原项目\n\n\n\n\n11. 练习 git fetch 拉取，然后和 git pull 对比\ngit fetch：\ngit fetch origin   # 仅下载远程更新到本地仓库，不修改工作区git merge origin/main   # 手动合并到当前分支\n\n\n适用场景：需先检查远程变更再合并。\n\n\ngit pull：\ngit pull origin main   # 自动下载并合并远程 main 分支\n\n\n等价于 git fetch + git merge，但可能直接引入冲突。\n\n\n对比：\n\nfetch 安全可控；pull 便捷但风险更高（尤其本地有未提交变更时）。\n\n\n\n12. 练习 git rebase 变基合并，然后和 git merge 对比\ngit rebase：\ngit checkout featuregit rebase main   # 将 feature 的提交移到 main 分支顶部\n\n\n结果：历史线性整洁（无合并提交）。\n风险：重写历史，需避免在公共分支使用。\n\n\ngit merge：\ngit checkout maingit merge feature   # 创建合并提交\n\n\n结果：保留分支历史（有分叉和合并点）。\n\n\n对比：\n\n\n\n操作\n历史记录\n适用场景\n\n\n\nrebase\n线性、简洁\n私有分支整理提交\n\n\nmerge\n保留分支拓扑\n公共分支合并\n\n\n\n\n13. Python 的特点是什么？Python 的核心特点包括：\n\n简洁易读：语法接近英语，如 if age &gt; 18:。\n解释型语言：无需编译，直接运行（如 python script.py）。\n跨平台：支持 Windows、Linux、macOS。\n丰富的库：标准库（如 os、json）和第三方库（如 numpy、requests）。\n动态类型：变量类型在运行时确定（如 name = &quot;Alice&quot;）。\n多范式：支持面向对象、函数式编程。\n\n14. python 单行和多行注释是什么？单行注释：以 # 开头\n# 单行注释\n\n多行注释：用三引号 &#39;&#39;&#39; 或 &quot;&quot;&quot;\n&#x27;&#x27;&#x27;多行注释第二行&#x27;&#x27;&#x27;\n\n\n\n\n\n15. 使用 python 写一个 年龄判断、如果年龄大于 18 输出成年、否则输出未成年age = int(input(&quot;请输入年龄: &quot;))  if age &gt; 18:    print(&quot;成年&quot;)else:    print(&quot;未成年&quot;)\n\n\n\n\n\n16. python 有哪些数字类型？Python 的数字类型包括：\n\nint（整数）：如 5, -10。\nfloat（浮点数）：如 3.14, -0.5。\ncomplex（复数）：如 1+2j。\n\n17.python 字符串支持几种写法？字符串支持多种写法：\n\n单引号：&#39;Hello&#39;\n双引号：&quot;World&quot;\n三引号（多行）：\n\n18. 下面代码输出了什么？ \nstr=&#x27;123456789&#x27;\t\tprint(str)\t\t\t#123456789print(str[0:-1])\t#12345678print(str[0])\t\t#1print(str[2:5])\t\t#345print(str[2:])\t\t#3456789print(str[1:5:2])\t#24print(str*2)\t\t#123456789123456789print(str+&#x27;你好&#x27;)\t  #123456789你好\n\n\n\n[:] 是复制整个字符串\n[::-1] 是反转字符串（你之前例子中学过）\n[start:end:step] 中：\nstart 默认是开头（正向为0，反向为-1）\nend 默认是结尾（正向为len，反向为开头）\nstep 为负数时，方向反转！\n\n\n\n\n二、进阶题1. python最基础：写一个猜单价的游戏，提示用户输入一个单价，然后告诉用户价钱高了或者小了，直到用户输入准确的单价，结束，最后统计用户猜了几步。# 设置正确单价price = 80count = 0print(&quot;欢迎参加猜单价游戏！&quot;)print(&quot;-------------------&quot;)while True:    # 获取用户输入    guess = float(input(&quot;请输入您猜测的单价: &quot;))    count += 1        # 判断猜测结果    if guess &gt; price:        print(&quot;猜高了，试试低一点的价钱&quot;)    elif guess &lt; price:        print(&quot;猜低了，试试高一点的价钱&quot;)    else:        print(&quot;恭喜您！正确答案是80，您猜对了！&quot;)        print(&quot;您总共猜了&quot;, count, &quot;次&quot;)        break\n\n\n\n三、 明天默写和面试题运维班1. 你知道 OSI 七层网络模型吗？OSI（开放系统互联）模型是网络通信的标准化框架，分为七层：\n\n物理层：传输原始比特流（如网线、光纤）\n数据链路层：节点间数据传输（MAC地址、交换机）\n网络层：路由选择和寻址（IP协议、路由器）\n传输层：端到端连接管理（TCP&#x2F;UDP协议）\n会话层：建立和维护会话\n表示层：数据格式转换和加密\n应用层：用户接口（HTTP&#x2F;FTP&#x2F;SMTP协议）\n\n2. 请说下 TCP 协议和 UDP 协议的区别。\n\n\n特性\nTCP\nUDP\n\n\n\n连接方式\n面向连接（三次握手）\n无连接\n\n\n可靠性\n可靠传输（确认重传）\n尽力交付（可能丢包）\n\n\n顺序保障\n保证数据顺序\n不保证顺序\n\n\n速度\n较慢\n较快\n\n\n头部大小\n20-60字节\n8字节\n\n\n适用场景\n文件传输、网页浏览、邮件\n视频流、在线游戏、DNS查询\n\n\n3. 你知道哪些常用的端口号？\n21：FTP（文件传输）\n22：SSH（安全远程登录）\n25：SMTP（邮件发送）\n53：DNS（域名解析）\n80：HTTP（网页访问）\n110：POP3（邮件接收）\n143：IMAP（邮件同步）\n443：HTTPS（安全网页）\n3306：MySQL数据库\n3389：远程桌面协议(RDP)\n\n4. 为什么我们不使用 root 账户？\n安全风险：\n单点故障：root 泄露等于系统完全失守\n恶意命令：rm -rf / 等破坏性命令无阻拦\n\n\n最小权限原则：\n普通用户需 sudo 提权执行特权操作\n操作审计（/var/log/auth.log 记录 sudo 操作）\n\n\n防误操作：\n避免意外修改系统关键文件（如 /etc）\n防止误删系统文件导致宕机\n\n\n安全纵深防御：\n攻击者突破普通账户仍需提权\n提供二次防护机会（如监控异常 sudo 请求）\n\n\n\n答案在：http://47.110.66.96/helper 运维部分鸿蒙班\nvue 的生命周期有哪些？\n\n2. vue 的组件有哪些通讯？3. vue 的 key 作用？4. vue 的常见指令有哪些？","categories":["Git"],"tags":["Git"]},{"title":"Linux面试题","url":"/2025/09/18/Linux%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"理论基础1、面Linux系统比Windows系统好在哪里？其它问法： 你为什么选择学习Linux？你觉得企业为什么选择Linux系统？而不选择Windows系统？\nLinux开源，并且大多数的发行版本免费，其中甚至包括了部分企业级的服务器版本。同时由于开源的特性，其安全问题会更透明，社区能够快速的发现并修复漏洞，整体安全性较高，在服务器场景中往往有更好的表现。另一方面，其开源特性使得有更丰富的版本选择，可以根据不同的需求进行剪裁和定制。在多用户多任务方面，Linux支持多用户同时登录并执行各自的任务，同时权限管理严格，资源分配合理。而且因为可以选择舍弃图形化界面，使得其资源占用更低。当然，Windows也不是没有优势的，其在图形化界面、办公软件的兼容性、游戏的支持上就比Linux好得多。\n\n扩展： \n\n我们常说的开源免费并不是同一个概念：开源：软件产品的源代码对公众开放，任何人都可以查看、使用、修改以及分发其源代码。免费：可以自由的运行程序、自由的学习并修改程序、自由的复制并向他人分发软件副本、自由的发行修改版。但是这并不意味着开源软件必须免费，如：Red Hat Enterprise Linux（RHEL，红帽企业版）；同时也不意味着免费必须开源，如：Adobe Acrobat Reader DC。\n这个知识点背诵时，首先记住Linux系统对比Windows最大的优势就是开源，因此可以从这一条开始扩展。\n首先说出价格的问题，你可以认为一个开源的产品，总有其免费版本，大不了别人就拿源代码编译一下就是了；然后说出开源会带来的社区优势，即有更多的人去维护它，安全性会更好，同时也意味着你可以修改它做定制化。\n到这里就说出一半了，然后再从Linux系统的多用户和可以舍弃图形化界面这点上说下，就答完了。\n\n2、IP地址 和 域名的关系是什么？其它问法： 域名是什么？\nIP 地址是计算机在网络上的唯一标识符，类似于门牌号。域名则是互联网上主机或者网络服务的一种易于记忆、具有层次结构的名称标识。IP 地址与域名互相映射，1个域名对应1个IP 地址，1个 IP 地址对应多个域名。\n\n扩展： \n\nIP地址分两种，一种是IPv4，占用4字节，格式是由点（.）隔开的4组十进制数，每组范围0至255；一种是IPv6，占用16字节，格式是由冒号（:）隔开的8组十六进制数组成，同时为了简洁可以省略全是0的组的书写和将多个全是0的组缩写成一对冒号（::）。域名的真正看法则是应该由右至左看，首先看到的是可以被省略的点(.)，这个被称之为根域名；然后是我们常见的顶级域名，如：com、org 等；再然后是二级域名，这个级别的域名才是我们可以正常获取的级别，如：baidu、aliyun 等；之后的按照顺序，有三级域名、四级域名，这些域名都是由上级域名再分配而得到的。\n这个知识点背诵时，首先要记住的有两点：\n1、 IP地址相当于我们计算机在网络上的“门牌号”。\n2、 域名其实可以理解成 IP 地址的一个别名或者代称，它与 IP 地址一一对应，而一个 IP 地址是可能有多个别名或者代称的。\n\n3、DNS 服务器是什么？其它问法： DNS 是什么？域名如何和 IP 地址 转换的？\nDNS 服务器是在网络上提供将域名转换为对应 IP 地址的一种服务设备。其核心作用就是提供域名解析服务，而域名解析就是将域名转换为对应 IP 地址。\n\n扩展： \n\n当我们访问一个域名时，会首先查询本机的 hosts 文件中有没有对应的转换关系，如果没有则会尝试请求对应的DNS服务器。而当DNS服务器解析不出来时，将会尝试请求更上一级域名的DNS服务器，并将结果记录。如果都查询不到，则网页就会出现域名解析错误的提示页面。\n这个知识点背诵时，要记住的有1点，DNS是指域名解析服务，将域名转换为 IP 地址的一种服务。\n\n4、为什么IP地址到现在还没有分配完？其它问法：IP 地址的分配方案是什么？\n在IPv4 地址紧张的当下，私有IP地址范围（如10.0.0.0/8、172.16.0.0/12和192.168.0.0/16等）被广泛使用于内部网络。当内部网络设备需要与公网通信时，会利用NAT技术将私有IP地址映射到公共IP地址上。通过这种方式极大地增加了单个公共IPv4地址可以支持的内部设备数量。而运营商则使用大规模的NAT系统，允许大量用户共享一个或几个公网IPv4地址，这样也同样减缓了IP短缺的问题。\n\n\n\n扩展： \n\n除此之外，云计算和数据中心采用了虚拟化技术，多个虚拟机可以在单个物理服务器上运行并共享该服务器的单个或少量公网IPv4地址，从而节省了地址资源。\n这个知识点背诵时，要记住的核心概念是 NAT，通过它将我们内网IP地址转换为公网IP地址。这就好像从原本的点对点的传递物品，变成了现在的先传送到中转站A，然后由中转站A送到目标地址的中转站B，最后从中转站B再送到目标地点一样。这样每个地址所要记录的就只有自己下面的地址和其它中转站了，而其它中转站下面的我们并不需要记录。\n\n5、你知道OSI七层网络模型吗？其它问法：请说下OSI七层网络模型。请说下交换机是属于哪一层的设备。\nOSI七层网络模型其层次从下至上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。其中物理层是最底层，是用于规范数据在物理媒介上传输的规范的一层。其次是数据链路层，其负责将电信号转换为我们的数据并校验，同时负责了物理层面的选择转发的设备（地址管理和访问控制）。然后是网络层，负责选择将数据发送到哪台设备上。传输层则是数据到了我们系统中，开始确认接收信息的服务端口，TCP和UDP就是这一层的。会话层则是我们服务对通信的管理。表示层则将我们的数据转换为对应的格式。最后则是应用层，开始处理我们的业务。\n\n扩展： \n\nOSI七层网络模型的具体实现如下：物理层：双绞线电缆、光纤电缆、RJ45（网线接口和水晶头）等数据链路层：以太网协议、Wi-Fi协议、MAC地址等，物理设备有二层交换机等网络层：IPv4协议、IPv6协议、ICMP协议等，物理设备有三层交换机、路由器等传输层：TCP协议、UDP协议等会话层：数据库连接池、Session等表示层：HTTP头信息中的Content-Encoding、MIME类型等应用层：HTTP协议、FTP协议、SSH协议等\n这个知识点背诵时，需要理解网络信息的传输流程。\n在传输时，肯定是光电信号的，这里有关的是物理层，然后将光电信号转成数据的是数据链路层，再由网络层将数据发送到你电脑上，由传输层决定是哪个服务，然后开启服务会话，这里处于会话层，由表示层将二进制数据转换为对应的具体格式数据，并由应用层最后处理。\n\n6、请说下TCP协议和UDP协议的区别。其它问法：你知道TCP协议和UDP协议吗？\nTCP协议是传输控制协议，UDP协议是用户数据报协议。TCP协议通过三次握手四次挥手和其它方案确保了数据的可靠性和完整性，而UDP协议则没有这一点。TCP协议同时还有完善的流量控制和拥塞控制机制，而UDP协议也没有。但是TCP协议的这些机制带来了更高的开销和延迟以及更低的吞吐量，而UDP协议则是有更低的延迟和更高的吞吐量。基于以上特点，TCP协议更适合需要高可靠性的服务，比如：网页、电子邮件、文件传输；而UDP协议则更适合实时性要求高但可以接受数据丢失的一些服务，比如：语音通话、实时流媒体等。\n\n扩展： \n\nTCP协议还会对每个数据段赋予序列号，并按序传输和重组，以确保数据的正确顺序。同时，还会根据接收端处理能力动态调整发送速率，避免接收方无法处理而丢包的情况。而UDP协议没有复杂的确认机制，会产生一定程度的丢包或乱序的情况。不过同时，UDP协议还支持多播和广播，以实现支持向多个目的地一次性发送数据报文的功能。\n这个知识点背诵时，首先要明确一个名词，即：TCP的“三次握手，四次挥手”。这个功能实现了TCP协议关于传输的可靠性和完整性。\n在这个点上进行反向扩展就可以得到UDP协议没有这一点，同时也不保证可靠性和完整性这一点。\n然后再是根据这多出的步骤得到TCP协议的开销会比UDP大。\n最终得到它们分别的适用场景。\n\n请说下TCP连接的流程。\n其它问法：你知道三次握手四次挥手吗？\nTCP的连接需要经历三次握手、传输数据和结束的四次挥手。首先，当需要建立TCP连接时，会向目标发送一个请求报文，目标接收后，会回复一个带有同意标志的请求报文，然后我们则回复一个同意报文过去，三次握手就结束了。当需要结束连接时，会首先发送一个结束报文到对方那边去，对方接收后，会先回复一个确认报文，等对方连接的剩余工作完成后，再发送一个结束报文，而这边接收到结束报文后就会回复一个确认报文，至此，TCP连接就结束了。\n\n扩展： \n\n下面是TCP连接的“三次握手，四次挥手”的完整版：1、 第一次握手：SYN客户端（Client）想要与服务器（Server）建立连接时，它会发送一个带有SYN标志的TCP报文段给服务器。在这个报文中，客户端会随机生成一个序列号seq（X），这个序列号将作为本次连接中所有从客户端发出的数据的起始序号。2、 第二次握手：SYN + ACK服务器接收到客户端的SYN报文后，如果同意建立连接，则回复一个带有SYN和ACK标志的TCP报文段。服务器同样也会生成一个自己的序列号seq（Y），并且确认号ACK设置为客户端的序列号加1（即seq(X)+1），表示期望接收客户端的下一个数据报文从该序列号开始。3、 第三次握手：ACK客户端收到服务器的SYN + ACK报文后，会再向服务器发送一个ACK确认报文。此时，客户端的确认号ACK设置为服务器的序列号加1（即seq(Y)+1），表示已收到并确认了服务器的SYN报文。同时，客户端也会继续发送自己的数据，或者等待服务器的数据传输开始。至此，TCP连接已经建立完成，双方可以开始进行双向的数据传输。三次握手确保了双方都已准备好，并且双方对彼此的初始序列号进行了同步，这有助于后续数据包的可靠传输和顺序控制。1、 第一次挥手：FIN当某一方（假设是客户端）完成数据传输或决定断开连接时，它会发送一个带有FIN标志的TCP报文段给另一方（服务器），表示“我已无数据要发送”。此时，客户端进入FIN-WAIT-1状态。2、 第二次挥手：ACK服务器收到客户端发来的FIN报文后，确认并回复一个带有ACK标志的报文，确认号ACK设置为接收到的序列号加1。这表示服务器已经收到了客户端的关闭请求，并且自身可能还有数据需要发送完。服务器这时进入CLOSE-WAIT状态，而客户端则进入FIN-WAIT-2状态，等待服务器的FIN报文。3、 第三次挥手：FIN服务器发送完所有剩余的数据后，也会发出一个FIN报文，通知客户端它也已经没有数据要发送了。这时服务器进入LAST-ACK状态。4、 第四次挥手：ACK客户端收到服务器的FIN报文后，同样会回应一个ACK确认报文，确认号ACK设置为服务器FIN报文中的序列号加1。然后客户端进入TIME-WAIT状态，等待一段时间确保服务器接收到了这个确认报文。这段时间过后，客户端才会真正关闭连接。服务器在收到客户端的最后一个ACK报文后，立即进入CLOSED状态，结束连接。客户端在TIME-WAIT状态保持一段时间是为了防止最后的ACK报文丢失，若该ACK未到达服务器，服务器会重新发送FIN报文，客户端可以在TIME-WAIT期间再次确认。经过这个时间后，客户端确认连接已经完全关闭，最终也进入CLOSED状态。\n这个知识点背诵时，需要记住的一点是，不是直接开始传也不是直接断的，不是你说开始就代表你同意接收数据了。\n因此问得互相问一次，各回答一次，然后其中“三次握手”中的目标的回答和询问一起发送了，因此是“三次握手”。\n而“四次挥手”也是一样的，因此结束和同意也要互相确认，同时，结束时，同意结束和我发送结束因为有可能不是同时的，所以要分两次。因此是“四次挥手。”\n\n7、你知道哪些常用的端口号？其它问法： HTTP 和HTTPS 的端口号分别是多少？SSH 的端口号是多少？MySQL 的端口号是多少？\nHTTP 协议使用的默认端口号为80；HTTPS 协议默认使用的端口号为443；SSH 协议默认使用的端口号为22；FTP 协议默认使用的端口号为21；MySQL 默认使用的端口号为3306。\n\n扩展： \n\n其它的如：Redis 默认使用的端口号是：6379；SMTP 默认使用的端口号是：25\n这个知识点就没什么好说的了，就是单纯的背。\n\n8、HTTPS 中的 S 是什么意思？其它问法： 你知道 SSL 吗？你知道 TLS 吗？\nHTTPS中的“S”代表“Secure”（安全），它表明该连接使用了安全套接字层（SSL）或其后继者传输层安全（TLS）协议来加密和保护通信数据。SSL（Secure Sockets Layer）是一种早期的网络安全协议，用于在互联网上实现客户端与服务器之间的信息加密、身份验证以及消息完整性校验。随着技术发展，SSL逐渐被TLS（Transport Layer Security）协议取代，但为了保持兼容性和普遍认知，许多场合仍沿用SSL的说法。总之，SSL/TLS都是用于保障信息安全的方案。\n\n扩展： \n\n其中，SSL&#x2F;TLS的加密流程基本上是如下的：1、 客户端向服务端发送请求连接，同时携带上客户端支持的TLS版本、加密套件列表和一个随机数。2、 服务端接收后响应一个最高兼容的 TLS 版本、一个选定的加密套件和另一个随机数。同时发送服务器的数字证书给客户端，数字证书包含了服务器的身份信息和由受信任的证书颁发机构（CA）签名的公钥。3、客户端接收后验证证书是否有效，没有过期、签发者可信和域名匹配，然后使用CA的公钥验证服务器证书的签名。4、然后根据双方协商的秘钥交换算法，客户端可能需要产生一个随机数并通过服务器证书中的公钥加密后发往服务器；或者双方直接通过非对称加密算法交换随机数据以计算共享密钥。5、客户端和服务器各自利用接收到的信息以及之前自己生成的随机数，通过密钥导出函数生成一个对话密钥，此密钥将用于后续的对称加密通信。6、双方交换Finished消息，这些消息使用刚才生成的对话密钥进行加密，以验证握手过程中没有被篡改或监听。当对方成功解密并校验Finished消息后，握手阶段结束。7、一旦握手完成，客户端和服务器开始使用协商好的对称加密算法、哈希算法以及消息认证码（MAC）来加密和解密应用层数据（比如HTTP请求和响应）。所有后续通信都将受到保护，确保数据隐私性和完整性。\n这个知识点背诵时，要记住的核心概念是HTTPS中的S意为安全。然后从安全这个意思进行扩展，得到SSL&#x2F;TLS这个概念是解决安全性的问题的。\n\n日常使用1、你用的是什么发行版本？其它问法： 你了解发行版本吗？\n我使用的是CentOS7 这个发行版本。其它发行版本我还知道Ubuntu、Debian。国产的depin，红旗等\n\n扩展： \n\n我们最常用的Linux两大系分别是：Red Hat系和 Debian 系。其中Red Hat系主要客户群体是企业，因此更注重稳定性和一致性。而Debian 系的主要客户群体是需要图形化界面的桌面用户、开发者和需要高度可定制化系统的组织，因此更注重新功能、广泛的软件包库和灵活的定制性。同时，这两大系的包管理系统、更新策略、系统配置和系统管理是不一样的。\n这题其实就是问你用的 Linux 是哪个版本的，不过 Linux 不同于 Windows 只有一家公司的，Linux 有好几家公司的，所以这里说的是发行版本。\n\n2、你用的是图形化界面的还是命令行界面的？其它问法： 你用的是带桌面的？还是不带桌面的？你是在哪里操作Linux系统的？\n我是使用的命令行界面的CentOS7。\n\n扩展： \n\n在系统中运行的图形化界面会占用较多的资源。在现代Windows10或11中，纯净安装且仅启动基本图形界面服务时，空载状态下的内存占用通常从几百MB到1GB左右不等，实际情况下只会是远大于这个大小。而在Linux系统中，轻量级桌面环境在无额外加载项的情况下，可能需要占用几十MB至几百MB的内存，而功能更全面的桌面环境在纯净启动时，内存占用可能会达到几百MB至上GB，实际情况也是只会大于这个大小。同时这也意味着舍弃了图形化界面之后至少可以节省下来数百MB的内存空间。而对于Redis而言，在键平均占用8字节（8个英文字符），值平均占用32字节（32个英文字符）的情况下每百MB可以额外多存储近3百万个键值对。\n这题其实就是问你平时使用 Linux 的操作风格。\n但是首先，我们要知道桌面UI会消耗大量的系统资源，而服务器是不需要桌面UI的，因此，正统服务器一般选择的都是命令行界面的。\n另一方面，在使用上，桌面UI大幅度的简化了一些我们的命令行操作。这也意味着，桌面UI版的技术门槛是比命令行界面版的低一些的。同时，你会命令行版本的，在使用桌面UI版时再不济也可以使用终端操作，可是反过来却不一定行。\n结合这两点，企业选择时，会命令行的会优于只会桌面UI的。\n\n3、你有用虚拟机吗？用的是哪种?其它问法：你Linux系统是安装在实体机上还是虚拟机上？你有用过VM吗？\n我有使用虚拟机，当时学习Linux的时候就是安装在VMware Workstation虚拟机上跑的。\n\n扩展： \n\n常见的虚拟机除了上述的VMware Workstation Pro外，还有：Oracle VirtualBox\n这题其实就是问你平时有没有使用过虚拟机，他们是有使用虚拟机的场景的。\n\n4、你是通过什么方式连接的Linux系统的？其它问法： 你知道SSH吗？如何从Windows上连接Linux？\n我平时是使用第三方的软件Xshell进行连接的，它走的是SSH协议，同时在没有这款软件或者不能使用的情况下，我会使用CMD中的ssh命令进行连接。\n\n扩展： \n\nSSH（Secure Shell）是一种网络协议，主要用于提供安全的远程登录和命令行管理服务。它允许用户通过加密通道在不安全的网络上进行安全的数据传输，并且可以执行远程服务器上的命令、传输文件以及与其他网络服务交互。\n这题的核心问题其实是你有没有办法从远程连接到你的Linux系统，答案就是SSH协议。这里你要确保你回答到了SSH协议才能得分。\n因为我们是使用虚拟机去练习的Linux系统，因此我们可以直接对Linux系统进行操作，但现实场景却更多的是Linux服务器压根不在你身边，你必须使用你手头上的设备去连接它，操作它。\n而平时最常用的Xshell只是具体的解决方案中的一种，它还是基于SSH协议的，而如果你只回答了Xshell，那么就会被认为你只是会用这个工具，而非知道其连接的底层协议。\n\n用户和权限为什么我们不使用root账户？其它问法：你觉得直接使用 root 账户好吗？\n在 Linux 系统中，root 账户是系统最高权限的管理员，拥有着对系统的完全访问权限。如果我们直接使用 root 账户，从安全角度来说有着巨大的安全风险。另外，因为权限过大，因此也有着误操作的风险。\n\n扩展： \n\n如果了解安全审计，也可以加上：从安全审计的角度出发，可以更好的跟踪用户的操作，同时也符合最小权限原则。\n这个知识点背诵时，首先记住 root 是在 Linux 系统中什么都能做的管理员，在这个基础上进行扩展。\n比如：安全角度，误操作角度 等。\n\n知识点小结1、mkdir 命令（创建目录）\n基础操作：如何一次性创建多级目录（如 a/b/c）？ \n\nmkdir -p a/b/c（-p 递归创建父目录）。\n\n\n权限控制：mkdir -m 750 dir 的作用是什么？ \n\n创建目录 dir，权限为 所有者读&#x2F;写&#x2F;执行，组用户读&#x2F;执行，其他用户无权限（数字权限 750）。\n\n\n防报错创建：创建已存在的目录会报错，如何避免？ \n\nmkdir -p existing_dir（-p 若目录存在则跳过，不报错）。\n\n\n批量创建：如何同时创建 dir1、dir2、dir3 三个目录？ \n\nmkdir dir1 dir2 dir3（空格分隔多个目录名）。\n\n\n对比 rmdir：rmdir 能删除非空目录吗？为什么？ \n\n不能！rmdir 仅删除空目录；非空目录需用 rm -r 递归删除。\n\n\n\n2、touch 命令（创建空文件&#x2F;改时间）\n空文件创建：如何快速创建空文件 test.txt？ \n\ntouch test.txt。\n\n\n批量创建：如何同时创建 file1.log 和 file2.conf？ \n\ntouch file1.log file2.conf（空格分隔）。\n\n\n修改时间：已有文件 data.csv，如何更新其“修改时间”为当前时间？ \n\ntouch data.csv（更新访问时间和修改时间）。\n\n\n父目录问题：尝试用 touch dir/file.txt 创建文件（父目录 dir 不存在），会怎样？ \n\n报错 No such file or directory；需先建父目录（mkdir -p dir）或用 touch -p？不，touch 无 -p，必须先建目录。\n\n\n对比 echo：touch 和 echo &quot;&quot; &gt; file 哪种创建的文件更小？ \n\ntouch 创建的文件大小为0（纯空文件）；echo 会写入空行，文件大小至少1字节（含换行符）。\n\n\n\n3、cat 命令（查看&#x2F;合并文件）\n显示行号：查看 test.log 并显示行号，命令是什么？ \n\ncat -n test.log（-n 显示行号）。\n\n\n合并文件：如何将 fileA.txt 和 fileB.txt 合并到 fileC.txt？\n\ncat fileA.txt fileB.txt &gt; fileC.txt（重定向输出）。\n\n\n交互创建：用 cat 交互创建 hello.txt，输入 Hello Linux! 后如何结束？ \n\n按 Ctrl + D 终止输入。\n\n\n对比 more：查看大文件时，为什么更推荐 more 而非 cat？ \n\ncat 会一次性输出所有内容，大文件会刷屏；more 支持分页查看，更友好。\n\n\n管道应用：cat /etc/passwd | grep &quot;root&quot; 有什么作用？ \n\n查看 /etc/passwd 中包含 root 的行（筛选用户信息）。\n\n\n\n4、more 命令（分页查看）\n翻页操作：用 more 查看大文件时，如何翻页、回退、退出？ \n\n空格（翻页）、b（回退一页）、q（退出）。\n\n\n指定起始行：从第20行开始查看 file.txt，命令是什么？ \n\nmore +20 file.txt。\n\n\n对比 less：less 比 more 强在哪里？ \n\nless 支持 前后翻页（如 ↑↓ 键），还能搜索内容；more 只能向后翻页。\n\n\n管道结合：ls -lR / | more 有什么效果？ \n\n分页查看根目录下所有文件的详细信息（递归显示，避免刷屏）。\n\n\n错误提示：用 more 查看不存在的文件，会出现什么提示？ \n\n报错 more: cannot open [文件名] for reading: No such file or directory。\n\n\n\n5、cp 命令（复制文件&#x2F;目录）\n递归复制：如何复制目录 src 及其子文件到 dest？ \n\ncp -r src dest（-r 递归处理子目录）。\n\n\n保留属性：复制文件时，如何保留原文件的权限、时间戳？ \n\ncp -p source.txt target.txt（-p 保留属性）。\n\n\n交互复制：复制 file.txt 到 file_backup.txt 时，若目标文件已存在，如何让系统提示是否覆盖？ \n\ncp -i file.txt file_backup.txt（-i 交互模式）。\n\n\n对比 mv：cp 和 mv 的核心区别是什么？ \n\ncp 是复制（文件&#x2F;目录保留两份）；mv 是移动&#x2F;重命名（原文件消失）。\n\n\n复制软链接：如何复制符号链接文件本身（而非指向的源文件）？ \n\ncp -d link.txt new_link.txt（-d 保留软链接属性）。\n\n\n\n6、mv 命令（移动&#x2F;重命名）\n重命名文件：如何将 a.txt 重命名为 b.txt？ \n\nmv a.txt b.txt。\n\n\n批量移动：如何将 file1、file2 同时移动到 target_dir？ \n\nmv file1 file2 target_dir/（空格分隔文件，目标目录结尾加 /）。\n\n\n防覆盖保护：移动文件时，若目标目录已有同名文件，如何避免直接覆盖？ \n\nmv -i source.txt target_dir/（-i 交互模式，提示确认）。\n\n\n对比 cp+rm：为什么 mv 比“cp 后 rm”更高效？ \n\nmv 是移动文件指针（仅改路径），无需复制数据；cp+rm 需复制+删除，耗时更长。\n\n\n通配符移动：如何将当前目录所有 .log 文件移动到 log_dir？ \n\nmv .log log_dir/（通配符匹配，批量移动）。\n\n\n\n7、rm 命令（删除文件&#x2F;目录）\n递归删目录：如何删除目录 dir 及其所有子内容（包括非空目录）？ \n\nrm -r dir（-r 递归删除）。\n\n\n强制删除：如何不提示，直接删除只读文件 readme.txt？ \n\nrm -f readme.txt（-f 强制删除，忽略权限和存在性检查）。\n\n\n致命风险：为什么说 rm -rf / 极其危险？如何避免？ \n\n会递归强制删除根目录下所有文件（系统崩溃）！生产环境需：① 加交互（-i）；② 用别名覆盖 rm（如 alias rm=&#39;rm -i&#39;）。\n\n\n对比 rmdir：rmdir 能删除非空目录吗？怎么解决？ \n\n不能！非空目录需用 rm -r；若要删空目录，rmdir 更安全（避免误删内容）。\n\n\n交互删除：删除文件时，如何每次都提示确认？ \n\nrm -i file.txt（-i 交互模式，强制提示）。\n\n\n\n8、which 命令（查找命令路径）\n查找命令路径：如何查看 ls 命令的绝对路径？ \n\nwhich ls（输出如 /bin/ls）。\n\n\n内置命令问题：执行 which cd 为什么找不到结果？ \n\ncd 是 Shell 内置命令（非外部可执行文件），which 只查外部命令；可通过 type cd 查看内置属性。\n\n\n对比 whereis：which 和 whereis 查找范围有何不同？ \n\nwhich 只查 可执行文件路径；whereis 还查 手册页、源文件（如 whereis ls 会显示二进制、手册、源文件位置）。\n\n\n验证安装：如何快速判断系统是否安装了 gcc 编译器？ \n\nwhich gcc：若输出路径，说明已安装；否则未安装。\n\n\n隐藏文件查找：which 能查找隐藏文件吗？为什么？ \n\n不能！which 只查 PATH 环境变量指定的目录 中的文件，隐藏文件不在 PATH 里（或需全路径调用）。\n\n\n\n9、find 命令（强大查找）\n按名查找：如何在当前目录及子目录中，查找名为 test.txt 的文件？ \n\nfind . -name &quot;test.txt&quot;（. 表示当前目录，-name 匹配名称）。\n\n\n按大小查找：如何查找系统中大于100MB的日志文件（.log 结尾）？ \n\nfind / -type f -name &quot;.log&quot; -size +100M（-type f 指文件，+100M 大于100MB）。\n\n\n按时间查找：如何查找 /home 下7天内修改过的文件？ \n\nfind /home -type f -mtime -7（-mtime -7 表示7天内修改，+7 是7天前）。\n\n\n对比 grep：find 和 grep 的核心区别是什么？ \n\nfind 找 文件本身（按名称、类型、属性等）grep 找 文件内容（按文本匹配）。\n\n\n查找并删除：如何查找 .tmp 结尾的文件并直接删除？ \n\nfind . -name &quot;.tmp&quot; -exec rm -f &#123;&#125; \\;（-exec 执行删除，&#123;&#125; 代指找到的文件）。\n\n\n\n10、grep 命令\n正则与选项：  \n\n如何忽略大小写查找 error？（grep -i &quot;error&quot; file）  \n如何反向过滤空行和注释行？（grep -v -E &quot;^#|^$&quot; file，解释 -v 和正则）  \n区别 -E 和 -G：哪个支持扩展正则（如 |）？（-E 支持扩展正则，无需转义 |；-G 是基本正则，需转义）\n\n\n场景延伸：  \n\n从 ifconfig 输出中提取所有 IPv4 地址，命令是什么？（ifconfig | grep -E -o &quot;\\b([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;\\b&quot;）  \ngrep 和 find 的核心区别？（grep 查文件内容，find 查文件属性&#x2F;名称）\n\n\n\n11、wc 命令\n统计类型：  \n\nwc -l、-w、-c 分别统计什么？（行、单词、字节）  \n如何统计当前目录下 .log 文件的个数？（ls | grep &quot;\\.log$&quot; | wc -l）\n\n\n管道结合：  \n\n结合 grep，统计 app.log 中含 error 的行数？（grep &quot;error&quot; app.log | wc -l）\n\n\n\n12、tail 命令\n实时跟踪：  \n\n实时监控日志文件 app.log 的命令？（tail -f app.log）  \n跟踪时如何退出？（Ctrl + C）\n\n\n选项辨析：  \n\n显示文件最后10行的命令？（tail -n 10 file 或 tail -10 file，-n 可省略）  \ntail 和 head 的应用场景？（tail 看最新日志，head 看配置文件开头）\n\n\n\n13、head 命令\n基础操作：  \n\n显示文件前5行的命令？（head -n 5 file 或 head -5 file）  \n如何跳过首行，显示后续内容？（head -n +2 file，或结合 tail：tail -n +2 file）\n\n\n对比思考：  \n\nhead -n -1 file 有什么作用？（删除文件最后一行，-1 表示“倒数第1行”）\n\n\n\n14、管道符 |\n核心原理：  \n\n管道的作用是什么？（连接命令，前命令 stdout 传后命令 stdin）  \n为什么 ls | rm 无效？（rm 不读 stdin，读命令行参数）\n\n\n进阶用法：  \n\n如何让错误信息也进入管道？（cmd 2&gt;&amp;1 | grep &quot;error&quot;，解释 2&gt;&amp;1）  \n对比 | 和 xargs：何时用 xargs？（处理不支持 stdin 的命令，如 find . -name &quot;.txt&quot; | xargs rm）\n\n\n\n15、echo 命令\n转义与输出：  \n\n输出带换行的内容，命令是什么？（echo -e &quot;Line1\\nLine2&quot;，解释 -e 启用转义）  \n如何输出环境变量 HOME 的值？（echo $HOME）\n\n\n对比辨析：  \n\necho 和 printf 的区别？（printf 格式更灵活，支持对齐；echo 更简单，依赖系统实现）\n\n\n\n16、反引号 `（命令替换）\n基础用法：  \n\n反引号的作用？（将命令结果作为参数&#x2F;变量值，如 dir=date +%F&#96;&#96;）  \n推荐用 $() 而非反引号的原因？（$() 支持嵌套，如 echo &quot;当前目录: $(pwd)&quot;；反引号嵌套需转义，易出错）\n\n\n实践场景：  \n\n如何用反引号批量删除 .tmp 文件？（rm -f ls .tmp&#96;&#96;，但需注意文件名含空格的风险）\n\n\n\n17、重定向符（&gt;、&gt;&gt;、2&gt;、&amp;&gt;）\n符号辨析：  \n\n&gt; 和 &gt;&gt; 的区别？（覆盖写入 vs 追加写入）  \n如何将错误信息单独写入文件？（cmd 2&gt; error.log，解释 2 代表 stderr）  \n&amp;&gt; 的作用？（同时重定向 stdout 和 stderr 到同一文件）\n\n\n安全实践：  \n\n如何“静默”执行命令（丢弃所有输出）？（cmd &amp;&gt; /dev/null，/dev/null 是“黑洞设备”）\n\n\n\n18、vi&#x2F;vim 编辑器\n模式切换：  \n\nvi&#x2F;vim 的三种模式是什么？如何切换？（命令模式 ESC、插入模式 i/I/a/A、末行模式 :）  \n保存并退出的命令？（末行模式 :wq；强制退出 :q! 不保存）\n\n\n核心操作：  \n\n全局替换所有 old 为 new 的命令？（末行模式 :%s/old/new/g，% 代表全文，g 代表全局）  \n如何快速跳转到第50行？（命令模式 50G 或末行模式 :50）  \n异常退出后，如何恢复文件？（vim -r file 恢复交换文件）\n\n\n\n19、awk 命令\n字段处理：  \n\n提取 /etc/passwd 的用户名和 Shell（第1、7列），命令是什么？（awk -F: &#39;&#123;print $1, $7&#125;&#39; /etc/passwd，-F: 指定分隔符）  \nNR、NF 分别代表什么？（NR 是当前行号，NF 是当前行字段数）\n\n\n计算与逻辑：  \n\n计算 nums.txt（每行一个数字）的总和？（awk &#39;&#123;sum+=$1&#125; END&#123;print sum&#125;&#39; nums.txt）  \n筛选 score.txt 中分数&gt;90的行？（awk &#39;$3 &gt; 90 &#123;print $0&#125;&#39; score.txt）\n\n\n对比延伸：  \n\nawk 和 grep 的区别？（grep 按行匹配，awk 按字段处理，支持计算和逻辑）\n\n\n\n20、yum 源\n本地 yum 源搭建步骤：  \n\n① 挂载镜像（mount /dev/cdrom /media/cdrom）；\n② 编辑 repo 文件（/etc/yum.repos.d/local.repo，配置baseurl=file:///media/cdrom）；\n③ 清理缓存（yum clean all）；\n④ 生成缓存（yum makecache）。\n\n\nyum 与 apt 的核心区别：  \n\nyum 用于 RPM 包管理（CentOS&#x2F;RHEL），apt 用于 deb 包管理（Ubuntu&#x2F;Debian）；命令语法和仓库格式不同。\n\n\n如何临时禁用某个 yum 仓库？  \n\nyum-config-manager --disable 仓库名（需安装 yum-utils），或直接编辑 repo 文件将 enabled=1 改为 0。\n\n\nyum 缓存的作用及清理命令：  \n\n缓存已下载的包，加速重复安装；清理命令 yum clean all，重建缓存 yum makecache。\n\n\n解决 yum 依赖冲突的思路：  \n\n① 用 yum deplist 包名 查看依赖；\n\n② 尝试 yum update 冲突包 升级；\n\n③ 手动下载依赖包离线安装，或强制降级（yum downgrade 包名）。\n\n\n\n\n21、软件安装和卸载\nyum 安装 vs 编译安装： \n\nyum 自动处理依赖，快捷但版本固定；编译安装可自定义参数（如 ./configure --prefix），但需手动解决依赖。\n\n\n彻底卸载软件（含配置文件）的方法：  \n\nyum remove 包名 保留配置文件，yum erase 包名 彻底删除；或手动清理 /etc/ 下的配置目录。\n\n\n离线安装 RPM 包的命令及注意事项：  \n\nyum localinstall 包.rpm（自动处理依赖）；需确保依赖包已下载，或提前用 yum downloader --resolve 包名 下载依赖。\n\n\n查看软件安装路径的命令：  \n\nrpm -ql 包名（列出包内所有文件路径），或 which 命令（查可执行文件路径）。\n\n\n解决“依赖未满足”报错的方法：  \n\n① 启用对应 yum 仓库（如 EPEL）；\n\n② 手动下载缺失的依赖包；\n\n③ 检查系统版本与包的兼容性。\n\n\n\n\n22、日期和时区\n修改系统时区为上海的命令： \nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime，\n\n\n\n\n或 timedatectl set-timezone Asia/Shanghai（systemd 环境）。\n\n\nNTP 与 Chrony 的区别：  \nChrony 更适合 网络不稳定环境（更快同步、低资源消耗），NTP 传统但兼容性好；CentOS 8+ 默认用 Chrony。\n\n\ndate 命令设时间后不生效的原因： \n可能被 NTP&#x2F;Chrony 服务覆盖（需先停服务 systemctl stop chronyd），或时区配置错误。\n\n\n解决虚拟机时间漂移的方法：  \n① 开启 VMware 时间同步（虚拟机设置→选项→时间同步）；\n② 配置 Chrony 自动校准。\n\n\n查看时间同步状态的命令：  \nChrony 用 chronyc sources -v，NTP 用 ntpq -p。\n\n\n\n23、systemctl 命令\nsystemctl 与 service 命令的区别：  \nsystemctl 是 systemd 工具（支持单元管理、依赖、状态查询），service 是兼容脚本（仅封装 systemctl，功能更弱）。\n\n\n设置服务开机自启的命令及扩展：  \nsystemctl enable 服务；若需禁止自启，用 systemctl mask 服务（更彻底，阻止手动启动）。\n\n\n查看服务依赖关系的命令： \nsystemctl list-dependencies 服务（递归显示依赖的单元）。\n\n\n服务启动失败的排查步骤：  \n① systemctl status 服务 看日志；\n② 检查配置文件语法（如 nginx -t）；\n③ 验证依赖服务是否正常。\n\n\nsystemd target 的作用： \n替代传统运行级别（如 multi-user.target 对应 runlevel 3，graphical.target 对应 runlevel 5），管理系统启动的单元集合。  \n\n\n\n\n24、网络传输（nmap&#x2F;netstat&#x2F;ping&#x2F;wget&#x2F;curl）\nnmap 与 netstat 查端口的区别\nnmap 是 主动扫描工具（查目标机开放端口），netstat 查 本机监听&#x2F;连接的端口（netstat -tulnp）。\n\n\nping 通但服务不可达”的原因： \n① 防火墙封禁端口（如 firewalld 阻止 80 端口）；\n② 服务未启动，或监听地址为 127.0.0.1（仅本机可访问）。\n\n\nwget 和 curl 下载大文件的优势：  \nwget 内置 断点续传（-c），适合后台下载；curl 支持 复杂请求（如带 Cookie、POST 上传），更灵活。\n\n\n用 curl 测试 POST 接口的命令：  \ncurl -X POST -d &quot;username=test&amp;password=123&quot; http://api.example.com/login（表单提交），\n或传 JSON：curl -H &quot;Content-Type: application/json&quot; -d &#39;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#39; URL。\n\n\n查看端口占用进程的命令：  \nnetstat -tulnp | grep 端口，或 ss -tulnp | grep 端口；结合 pidof 进程名 验证。\n\n\n\n25、进程管理（ps&#x2F;kill）\nps -ef 与 ps aux 的输出差异：  \nps -ef 是 System V 格式（列名如 UID、PID、PPID），\n\n\n\n\nps aux 是 BSD 格式（列名如 USER、PID、%CPU），\n核心数据一致。\n\n\n\n\nkill -9 与 kill -15 的区别： \n-15（SIGTERM）优雅终止（允许进程清理资源），-9（SIGKILL）强制终止（无视进程状态，可能丢数据）。\n\n\n批量杀死进程的方法：  \n① pgrep 进程名 | xargs kill；\n② pkill 进程名（更简洁，直接按名称杀进程）。\n\n\n进程僵死（Zombie）的原因及解决：  \n子进程退出，父进程未调用 wait() 回收；解决：kill 父进程（或重启服务），让 init 进程接管回收。\n\n\n查看进程资源占用的命令：  \ntop（实时监控）、htop（更友好），或 ps -eo %cpu,%mem,comm | sort -nr（按 CPU&#x2F;内存排序）。\n\n\n\n26、软链接（ln -s）\n软链接与硬链接的核心区别： \n软链接是特殊文件（存目标路径，Inode 不同），可跨分区、连目录；硬链接共享 Inode，不能连目录、跨分区。\n\n\n删除软链接的正确操作：\nrm -f 软链接名（不加 /，否则会删除目标目录！如 rm -f /link 删链接，rm -f /link/ 会删目标目录）。\n\n\n软链接指向的文件移动后，链接是否可用？  \n不可用！软链接存的是原路径，目标移动后路径失效，需重新创建链接。\n\n\n创建目录软链接的命令：  \nln -s 源目录 软链接名（硬链接无法创建目录链接，会报错）。\n\n\n软链接的权限是否影响访问？  \n不影响！访问软链接时，实际权限由目标文件决定，软链接自身权限可忽略。\n\n\n\n27、IP 和主机名\n临时 vs 永久设置 IP 的区别： \n临时用 ip addr add&#x2F;ifconfig（重启网卡失效）；\n\n\n\n\n永久需编辑 网卡配置文件（/etc/sysconfig/network-scripts/ifcfg-eth0），重启网络服务生效。\n\n\n主机名的三种类型（systemd 环境）：  \n① 静态（/etc/hostname，永久）；\n② 瞬态（hostname 临时名，重启失效）；\n③ 美观名（hostnamectl set-hostname &quot;Web Server&quot;，含空格，存 /etc/machine-info）。\n\n\n域名解析的优先级顺序：  \n先查 /etc/hosts，再查 /etc/resolv.conf 配置的 DNS 服务器（可通过 nsswitch.conf 调整顺序）。\n\n\nVMware 桥接模式 vs NAT 模式的区别：  \n桥接模式：虚拟机获 独立公网 IP（与主机同网段）；NAT 模式：虚拟机共享 主机 IP（通过主机转发上网，更安全）。\n\n\n解决 DNS 解析慢的方法：  \n① 换高速 DNS（如 8.8.8.8、223.5.5.5）；\n② 清理 DNS 缓存（systemd-resolve --flush-caches）；\n③ 优化 /etc/nsswitch.conf，优先用 dns 而非 files。\n\n\n\n28、主机状态（top、df、iostat、sar）\n简述top中load average的含义及“1&#x2F;5&#x2F;15分钟”数值的参考意义。\n\nload average 表示系统平均负载（等待CPU&#x2F;IO的进程数）。1分钟反映近期负载，15分钟反映长期趋势；若数值超过CPU核心数，可能系统过载。\n\n\n说明df -i的作用及适用场景。\n\ndf -i 显示磁盘分区的inode使用情况。当磁盘空间未满但无法创建文件时，需用它排查“inode用尽”问题。\n\n\niostat 中tps指标代表什么？\n\ntps（Transactions Per Second）表示每秒IO事务数，反映磁盘IO操作频率。\n\n\n如何实时监控eth0的网络吞吐量（每秒采集1次，共5次）？\n\n执行 sar -n DEV -p 1 5 | grep eth0（-p显示接口别名，1间隔1秒，5采集5次，grep过滤eth0）。\n\n\n系统负载高时，如何结合top、iostat判断是CPU还是磁盘IO瓶颈？\n\n① 用top看%iowait（高则可能IO瓶颈）和CPU使用率；\n② 用iostat看%util（磁盘利用率）、await（IO等待时间）。若%iowait和磁盘%util高，是IO瓶颈；若CPU使用率高，是CPU瓶颈。\n\n\n\n29、环境变量（概念、env、PATH、$、自定义）\n解释“环境变量”和“局部变量”的区别，并举例创建方式。\n\n环境变量可被子进程继承，用export VAR=value创建（如export PATH=/new/path:$PATH）；局部变量仅当前Shell有效，子进程不继承，直接VAR=value创建（如local_var=test）。\n\n\n命令提示“command not found”的可能原因及排查步骤？\n\n原因：命令路径不在PATH中，或命令不存在。步骤：① echo $PATH 查看路径；② which 命令 确认命令是否存在；③ 若存在，将路径加入PATH（export PATH=$PATH:/command/path）。\n\n\n简述$符号在Shell中的两种常见用法。\n\n① 引用环境变量（如echo $HOME）；② 命令替换（如current_dir=$(pwd)）。\n\n\n如何临时设置DEBUG=1并让子进程继承该变量？\n\n执行 export DEBUG=1，子进程会继承该环境变量。\n\n\n让MY_CONFIG=/etc/myapp.conf对所有用户永久生效，写出配置步骤。\n\n① 编辑/etc/profile；\n② 加入export MY_CONFIG=/etc/myapp.conf；\n③ 执行source /etc/profile让当前Shell生效（新登录用户自动加载）。\n\n\n\n30、压缩打包（gzip、zip、bzip2、tar）\n简述 tar -czf、tar -xzf、tar -tvf 的作用。\n\ntar -czf 用于打包并通过gzip压缩；tar -xzf 用于解压gzip格式的tar包；tar -tvf 用于查看tar包内的文件列表（不解压）。\n\n\ngzip 压缩文件后，原文件会发生什么变化？如何保留原文件？\n\ngzip 会删除原文件，生成 .gz 压缩文件；若要保留原文件，需加 -k 选项（如 gzip -k file）。\n\n\n对比 zip 和 tar + gzip 两种方式的优缺点。\n\nzip 跨平台性好（Windows&#x2F;Linux通用），但单文件压缩；tar + gzip 适合打包目录，Linux生态更友好，但Windows需工具（如7-Zip）支持。\n\n\n如何用 bzip2 压缩文件并显示压缩进度？\n\n使用 bzip2 -v file（-v 表示 verbose，显示详细过程，含压缩比、进度等）。\n\n\n命令 tar -cjf archive.tar.bz2 /data 的作用是什么？\n\n将 /data 目录打包并通过bzip2压缩，生成 archive.tar.bz2 文件。\n\n\n\n31、用户管理（useradd、passwd、usermod、userdel）\n简述 useradd 和 adduser 的关系。\n在多数Linux发行版中，adduser 是 useradd 的符号链接（软链接），功能一致；adduser 通常提供交互界面，useradd 更适合脚本自动化。\n\n\n普通用户修改自己密码时，对密码复杂度有要求吗？由什么决定？\n有要求，由 PAM（可插拔认证模块） 配置（如 /etc/security/pwquality.conf）和系统密码策略决定（长度、字符类型等）。\n\n\n如何强制新用户首次登录必须修改密码？\n使用 chage -d 0 username（设置密码过期时间为0，用户登录时会被强制改密码）。\n\n\nusermod -g group1 user1 和 usermod -G group2 user1 的区别是什么？\n-g 修改用户的主组；-G 将用户添加到附加组（原附加组会被覆盖，若要追加需加 -a，即 -aG）。\n\n\n执行 userdel -r testuser 会产生哪些操作？\n会删除用户 testuser，同时删除其家目录（/home/testuser）和邮件目录（/var/spool/mail/testuser）。\n\n\n\n32、用户组管理（groupadd、groupmod、groupdel、查看用户组）\n简述 /etc/group 文件的每行格式及含义。\n格式为 组名:密码占位符:GID:组成员。例如 dev:x:1001:user1,user2 表示组名 dev，GID 1001，成员为 user1 和 user2；“密码占位符”通常为 x（实际密码存 /etc/gshadow）。\n\n\n为什么删除用户组 testgrp 时提示“组非空”？如何解决？\n因为组内还有用户，需先移除组内所有成员（用 gpasswd -d user testgrp 逐个删除，或 usermod -G &quot;&quot; user 清空用户附加组），再执行 groupdel testgrp。\n\n\n如何查看系统中GID为1000的用户组？\n执行 grep &quot;:1000:&quot; /etc/group（匹配GID为1000的行）。\n\n\ngroupmod -o -g 1000 devgrp 中 -o 的作用是什么？\n-o 表示允许GID重复（默认GID唯一，加 -o 可创建与其他组相同GID的组）。\n\n\n新建用户时，如何指定其主组为已存在的 devgrp？\n使用 useradd -g devgrp newuser（-g 指定主组）。\n\n\n\n33、管理用户组成员（gpasswd）\n简述 gpasswd 中 -a、-d、-M、-A 选项的作用。\n-a：添加单个用户到组；-d：从组中删除单个用户；-M：批量添加多个用户到组（用逗号或空格分隔）；-A：设置组的管理员（允许该用户管理组成员）。\n\n\n普通用户作为组管理员，能执行哪些 gpasswd 操作？\n只能添加&#x2F;删除组内的普通成员，无法修改组名、GID，也不能删除组本身。\n\n\n如何查看组 testgrp 的所有成员？\n① 查看 /etc/group 中 testgrp 对应的行（如 grep &quot;testgrp&quot; /etc/group）；\n② 执行 getent group testgrp。\n\n\n对比 usermod -aG group user 和 gpasswd -a user group 的异同。\n异：usermod 是修改用户属性（将用户添加到附加组），gpasswd 是修改组的成员列表；\n同：最终效果都是用户加入组。\n\n\n执行 gpasswd -r testgrp 的作用是什么？\n移除组 testgrp 的密码（若组有密码，普通用户需密码才能加入；移除后，无需密码即可加入）。\n\n\n\n34、用户和用户组配置文件\n简述 Linux 中 /etc/passwd 和 /etc/shadow 的作用。\n\n/etc/passwd 存储用户基本信息（用户名、UID、GID、家目录、默认 Shell 等）；/etc/shadow 存储密码哈希及密码策略（过期时间等），权限更严格（仅 root 可读写），提升安全性。\n\n\n说明 /etc/group 文件的每行格式包含哪些字段。\n\n每行格式为 组名:组密码占位符:GID:组成员列表。组密码通常用 x 占位（实际存于 /etc/gshadow）；GID 是组 ID；成员列表为该组的用户（多用户用逗号分隔）。\n\n\n\n35、免密登录\n简述 SSH 免密登录的原理。\n\n基于非对称加密（公钥-私钥对）。客户端生成密钥对后，公钥部署到服务端 ~/.ssh/authorized_keys，私钥由客户端保管。登录时，服务端用公钥加密“挑战信息”，客户端用私钥解密并响应，验证通过则免密登录。\n\n\n生成 SSH 密钥对后，如何将公钥部署到远程服务端？\n\n方法 1：用 ssh-copy-id -i 公钥文件 用户名@服务端IP，自动追加公钥到 ~/.ssh/authorized_keys；方法 2：手动复制公钥内容，登录服务端后，将内容追加到 ~/.ssh/authorized_keys（无文件则创建）。\n\n\n为什么 ~/.ssh 目录和 authorized_keys 文件需要严格的权限设置？\n\n为保障安全。~/.ssh 设为 700（仅所有者可读写执行），authorized_keys 设为 600（仅所有者可读写），防止其他用户篡改公钥列表或非法读取私钥相关文件，避免未授权登录。\n\n\n\n36、文件属性和权限\n简述 Linux 文件和目录的权限属性，以及 r、w、x 分别对文件和目录的意义。\n\n权限分为所有者（user）、所属组（group）、其他用户（other）三类，每类包含读（r）、写（w）、执行（x）权限。\n对文件：r 允许读取内容；w 允许修改内容；x 允许执行文件（如运行程序）。\n对目录：r 允许列出目录内文件；w 允许在目录内创建&#x2F;删除&#x2F;重命名文件；x 允许进入目录（如 cd 到该目录）。\n\n\n说明 chown 和 chgrp 命令的作用及基本用法。\n\nchown：修改文件&#x2F;目录的属主，也可同时改属组，格式如 chown user:group 目标（例：chown alice:dev team.txt）。\nchgrp：仅修改文件&#x2F;目录的属组，格式如 chgrp group 目标（例：chgrp ops project/）。\n\n\n解释 Linux 权限的数字表示法（如 755、644）的含义，并举例说明如何用 chmod 命令修改权限。\n\n数字规则：r=4、w=2、x=1，三类用户（所有者、所属组、其他）的权限分别相加，形成三位数。\n示例：chmod 755 script.sh → 所有者 rwx（4+2+1=7），所属组和其他用户 rx（4+1=5）；chmod 644 doc.txt → 所有者 rw（4+2=6），所属组和其他用户 r（4）。\n\n\n系统安全加固中，“限制历史命令记录与退出清痕”的目的是什么？如何实现？\n\n目的：防止历史命令中可能包含的敏感信息（如密码、系统路径）被窃取，降低安全风险。\n实现：\n限制历史条数：修改 /etc/profile，设置 HISTSIZE=50（仅保留最近 50 条命令）。\n退出清痕：编辑用户的 ~/.bash_logout，添加 history -c（清空当前会话历史缓存）和 clear（清屏隐藏终端记录）。\n\n\n\n\n简述强化密码策略的主要手段及对应的配置方式。\n\n手段：控制密码有效期、最小长度、修改间隔、到期提示等。\n配置：\n修改 /etc/login.defs：设置 PASS_MAX_DAYS（密码最长有效期）、PASS_MIN_DAYS（密码修改间隔）、PASS_MIN_LEN（密码最小长度）、PASS_WARN_AGE（到期前提示天数）。\n对已有用户：用 chage 命令单独配置（如 chage -M 90 -m 1 -W 7 user，设置 90 天有效期、1 天修改间隔、到期前 7 天提示）。\n（可选）修改 PAM 配置（/etc/security/pwquality.conf）：强化密码复杂度（如长度、字符类型），该配置对 root 也有效。\n\n\n\n\n\n37、小结\n简述 touch 命令的作用及使用场景。\n\ntouch 命令主要用于创建新的空文件，或修改已有文件的访问时间和修改时间。场景包括：快速创建测试文件、更新文件时间戳以触发某些依赖时间的操作等。\n\n\n说明 cat、more 命令在查看文件时的主要区别。\n\ncat 会一次性将文件内容全部输出到终端，适合小文件；more 支持分页显示文件内容，通过空格翻页、q 退出，适合大文件，避免内容“刷屏”。\n\n\n解释Linux文件权限中 r、w、x 对文件和目录的不同含义。\n\n对文件：r 可读取内容，w 可修改内容，x 可执行文件；对目录：r 可列出目录内文件，w 可在目录内创建&#x2F;删除&#x2F;重命名文件，x 可进入目录（如 cd）。\n\n\n如何使用 chmod 命令将文件 test.sh 的权限设置为“所有者可执行，所属组可读，其他用户无权限”？\n\n命令为 chmod 540 test.sh。数字权限中，所有者 5（r+x，即 4+1）、所属组 4（r）、其他用户 0（无权限）。\n\n\n简述 ps 命令和 top 命令在查看进程时的区别。\n\nps 是“快照式”查看，显示命令执行时刻的进程状态；top 是“动态监控”，实时刷新显示进程的资源占用等变化情况。\n\n\n说明 kill 命令中 -9 参数的作用。\n\n-9 是强制终止信号（SIGKILL），会立即强制终止进程，不给予进程清理资源的机会，常用于无法通过普通 kill 终止的“顽固”进程。\n\n\ntop 命令可以查看哪些系统关键指标？\n\n可查看 CPU 使用率、内存使用情况、进程的资源占用（如各进程的 CPU&#x2F;内存占比）、系统负载等指标。\n\n\n解释环境变量 PATH 的作用。\n\nPATH 环境变量存储了系统查找可执行命令的路径列表。当输入一个命令时，系统会按 PATH 中路径的顺序，依次查找该命令的可执行文件。\n\n\n如何查看当前系统的所有环境变量？\n\n执行 env 命令，会列出所有环境变量及其对应的值。\n\n\n管道符 | 的作用是什么？举一个使用管道符的示例。\n\n管道符用于将前一个命令的输出作为后一个命令的输入。示例：ls -l | grep &quot;.txt&quot;，将 ls -l 的结果筛选出包含 .txt 的行。\n\n\n说明输出重定向 &gt; 和 &gt;&gt; 的区别。\n\n&gt; 会覆盖目标文件的原有内容；&gt;&gt; 会将内容追加到目标文件的末尾，不覆盖原有内容。\n\n\n什么是命令替换？如何使用反引号实现命令替换？\n\n命令替换是将命令的执行结果嵌入到另一个命令中。用反引号示例：echo &quot;当前日期：date&quot;，会将 date 命令的结果替换到字符串中。\n\n\nwhich 命令的作用是什么？\n\nwhich 命令用于查看系统中可执行命令的绝对路径，帮助确定当前使用的是哪个版本的命令。\n\n\n简述 find 命令的基本用法（如何按文件名搜索）。\n\n格式为 find 搜索路径 -name &quot;文件名&quot;，例如 find /home -name &quot;test.txt&quot;，在 /home 目录下搜索名为 test.txt 的文件。\n\n\ngrep 命令的作用是什么？如何在文件中筛选包含指定关键字的行？\n\ngrep 用于在文本中筛选匹配指定关键字的内容。命令格式：grep &quot;关键字&quot; 文件名，例如 grep &quot;error&quot; log.txt 筛选 log.txt 中含“error”的行。\n\n\n说明 wc 命令的主要功能。\n\nwc 用于统计文件的行数（-l）、单词数（-w）、字节数（-c），默认同时输出这三项统计结果。\n\n\nhead 和 tail 命令的作用分别是什么？tail -f 有什么特殊用途？\n\nhead 显示文件开头部分内容（默认前10行）；tail 显示文件末尾部分内容（默认后10行）。tail -f 可动态跟踪文件末尾的内容更新（如实时查看日志新增内容）。\n\n\n简述 sed 命令的工作原理。\n\nsed 是流编辑器，工作原理是逐行读取待处理文本，将每行放入“模式空间”进行指定的编辑操作（如打印、删除、替换等），处理后将结果输出，直到所有行处理完毕。\n\n\n如何使用 sed 命令直接修改源文件中的内容（替换操作）？\n\n使用 -i 选项结合替换脚本，格式为 sed -i &#39;s/原内容/新内容/g&#39; 文件名。例如 sed -i &#39;s/old/new/g&#39; test.txt，会将 test.txt 中所有“old”替换为“new”并直接修改源文件。\n\n\n列举至少3种Linux系统安全加固的措施，并说明其作用。\n\n① 移除不必要用户：减少系统中潜在的“弱口令”或“冗余权限”用户，降低被攻击风险；\n② 设置用户无操作自动退出（TMOUT）：防止用户离开后终端被他人冒用；\n③ 限制历史命令记录：避免敏感命令（如密码、路径）通过历史记录泄露。\n\n\n\n38、磁盘管理\n简述 MBR 和 GPT 分区表的核心区别。\n\nMBR 最多支持 4 个主分区，单分区最大 2TB，用 32 位地址；GPT 支持超 2TB 磁盘，最多 128 个分区，用 64 位地址，有冗余分区表，更可靠，且支持 UEFI 启动。\n\n\nLinux 硬件设备（如硬盘、分区）的命名规则是什么？举例说明。\n\nSCSI&#x2F;SATA 硬盘命名为 /dev/sdX（X 为字母，如 /dev/sda 是第一块硬盘）；分区为 /dev/sdXN（N 为数字，如 /dev/sda1 是第一块硬盘的第一个分区）；NVMe 硬盘可能命名为 /dev/nvme0n1。\n\n\n什么是 inode？它在文件系统中的作用是什么？\n\ninode 是“索引节点”，存储文件的元数据（权限、所有者、大小、数据块指针等），系统通过 inode 定位文件的数据块（实际内容存在 data block 中）。\n\n\n从新硬盘添加到 Linux 系统，到分区、格式化、挂载并开机自动挂载的完整流程是什么？\n\n① 物理添加硬盘；\n② 用 fdisk&#x2F;parted 创建分区（MBR&#x2F;GPT）；\n③ 用 mkfs 格式化（如 mkfs.ext4 /dev/sdb1）；\n④ 临时挂载：mount /dev/sdb1 /mnt/data；\n⑤ 配置自动挂载：编辑 /etc/fstab，添加 (/dev/sdb1 /mnt/data ext4 defaults 0 0)；\n⑥ 验证：mount -a 检查。\n\n\n交换分区的作用是什么？如何创建并启用交换分区？\n\n作用：物理内存不足时，临时将内存数据移到交换分区，释放物理内存。创建：用 fdisk 建 swap 类型分区，或 dd 建交换文件；格式化：mkswap /dev/sdb2（分区）或 mkswap /swapfile（文件）；启用：swapon /dev/sdb2 或 swapon /swapfile。\n\n\n超级块（superblock）的作用是什么？若超级块损坏会有什么影响？\n\n超级块存储文件系统的整体信息（如 inode 数量、块大小、文件系统类型）。若损坏，系统可能无法识别&#x2F;挂载该文件系统，导致数据无法访问，需用备份超级块或 fsck 修复。\n\n\nExt4 相比 Ext3 有哪些主要改进？\n\n支持更大文件&#x2F;分区（最大 1EB 文件、1EB 分区）；引入延迟分配、多块分配提升性能；日志模式更高效；支持在线碎片整理。\n\n\n什么是“挂载（mount）”？Linux 为什么需要挂载分区？\n\n挂载是将文件系统（分区、光盘、网络存储等）关联到 Linux 目录树的某个目录，使内容可通过该目录访问。Linux 以统一目录树组织存储，因此需挂载才能访问不同设备的文件系统。\n\n\n如何查看分区的文件系统类型？\n\n用 blkid /dev/sdb1（显示块设备的 UUID、文件系统类型）；或 df -T（显示已挂载分区的文件系统类型）；或 lsblk -f。\n\n\n解释 MBR 分区表中“逻辑分区”的概念，以及与主分区、扩展分区的关系。\n\nMBR 最多 4 个主分区，若需更多分区，需创建扩展分区，再在扩展分区内创建逻辑分区。逻辑分区是扩展分区的细分，编号从 5 开始（如 /dev/sda5）；主分区和扩展分区编号为 1 - 4。\n\n\n简述 MBR 和 GPT 分区表的主要区别，以及各自的适用场景。\n\nMBR（主引导记录）：\n\n最多支持 4个主分区（或3个主分区+1个扩展分区，扩展分区内可分多个逻辑分区）；\n单分区最大容量 2TB；\n采用32位地址，兼容性好（支持旧版BIOS启动）。\n适用：小容量磁盘（≤2TB）、需兼容老旧BIOS系统的场景。\n\n\nGPT（全局唯一标识符分区表）：\n\n最多支持 128个分区；\n单分区最大容量 超2TB（理论支持至8ZB）；\n采用64位地址，有冗余分区表（提高可靠性），支持UEFI启动。\n适用：大容量磁盘（＞2TB）、需多分区或UEFI启动的现代系统。\n\n\n\n\n解释 Linux 文件系统中 inode、data block、superblock 的作用，以及它们之间的关系。\n\ninode（索引节点）：存储文件的元数据（权限、所有者、大小、数据块指针等），每个文件对应一个 inode。\ndata block（数据块）：存储文件的实际内容，inode 通过指针指向这些块。默认大小4K\nsuperblock（超级块）：存储文件系统的全局信息（如 inode 总数、块大小、文件系统类型等），是文件系统的“总控中心”。\n\n关系：系统通过 superblock 识别文件系统整体信息 → 通过 inode 找到文件元数据和数据块指针 → 最终从 data block 读取文件内容。\n\n描述从新硬盘添加到 Linux 系统，到最终能存储数据的完整操作流程（包括分区、格式化、挂载等步骤）。\n流程如下：\n\n物理&#x2F;虚拟添加硬盘：将新硬盘接入服务器（或在虚拟机中添加虚拟磁盘）。\n\n查看新硬盘：用 fdisk -l 或 lsblk 确认新硬盘（如 /dev/sdb）。\n\n创建分区：\n\nMBR 分区：fdisk /dev/sdb → 交互创建主分区&#x2F;扩展分区。\nGPT 分区：parted /dev/sdb mklabel gpt → 交互或非交互创建分区。\n\n\n格式化分区：用 mkfs 格式化（如 mkfs.ext4 /dev/sdb1，将分区格式化为 Ext4）。\n\n临时挂载：mount /dev/sdb1 /mnt/data（将分区挂载到 /mnt/data 目录）。\n\n验证存储：在 /mnt/data 下创建文件（如 touch /mnt/data/test.txt），测试读写。\n\n配置自动挂载：编辑 /etc/fstab，添加行 (/dev/sdb1 /mnt/data ext4 defaults 0 0) → 执行 mount -a 验证自动挂载。\n\n\n\n什么是交换分区（swap）？它的主要作用是什么？如何创建并启用一个交换分区？\n\n交换分区（swap）：Linux 中用于“虚拟内存”的分区&#x2F;文件，当物理内存不足时，将部分内存数据临时换出到 swap，释放物理内存供活跃进程使用。\n作用：缓解物理内存不足，防止系统因内存耗尽崩溃。\n创建与启用步骤：\n（可选）用 fdisk 创建 swap 类型的分区（如 /dev/sdb2）。\n格式化 swap：mkswap /dev/sdb2（若用文件，先 dd if=/dev/zero of=/swapfile bs=1M count=2048 创建 2GB 文件，再 mkswap /swapfile）。\n启用 swap：swapon /dev/sdb2（或 swapon /swapfile）。\n（可选）配置开机自动启用：在 /etc/fstab 添加 (/dev/sdb2 none swap defaults 0 0)。\n\n\n\n\nLinux 中如何实现分区的开机自动挂载？请说明配置文件和关键步骤。\n通过配置 /etc/fstab 文件实现，步骤如下：\n\n确认分区信息：用 blkid /dev/sdb1 查看分区的 UUID、文件系统类型（如 ext4）。\n\n编辑 /etc/fstab：添加一行，格式为 UUID=xxx /挂载点  文件系统类型  选项  0  0（或用设备名 /dev/sdb1 替代 UUID，如 /dev/sdb1 /mnt/data ext4 defaults 0 0）。\n\n字段含义：UUID/设备名、挂载点、文件系统类型、挂载选项（defaults 包含 rw, suid, dev, exec, auto, nouser, async）、dump（备份标记）、fsck（检查顺序）。\n\n验证配置：执行 mount -a（无报错则配置正确），重启系统后分区会自动挂载。\n\n\n\n简述硬链接与软链接的核心区别。\n\n硬链接与源文件共享 inode，是同一文件的不同入口，仅能在同一文件系统创建，源文件删除后硬链接仍可访问；\n软链接是独立文件，有自己的 inode，通过路径指向源文件，可跨文件系统，源文件删除后软链接失效。\n\n\nRAID 0、RAID 1、RAID 5、RAID 10 的特点及适用场景分别是什么？\n\nRAID 0：条带化，无冗余，性能最优，适合对性能要求高但不要求冗余的场景（如临时缓存）。\nRAID 1：镜像，100% 冗余，读性能好、写性能一般，适合对数据安全性要求高的场景（如系统盘）。\nRAID 5：分布式校验，至少 3 块盘，兼顾性能与冗余，允许单块盘损坏，适合一般业务数据存储。\nRAID 10：先镜像（RAID 1）再条带（RAID 0），至少 4 块盘，性能与冗余俱佳，适合高 IO、高可靠性场景（如数据库）。\n\n\nLVM 的主要优势是什么？\n\nLVM 可动态管理存储，将多个物理设备抽象为卷组（VG），再灵活划分为逻辑卷（LV）；支持在线扩容&#x2F;缩容逻辑卷，还能创建快照、简化存储扩展与管理。\n\n\n正则表达式中元字符 .、&#96;&#96;、+、? 的作用分别是什么？\n\n.：匹配任意单个字符（除换行符）。\n&#96;&#96;：匹配前面的元素0 次或多次。\n+：匹配前面的元素1 次或多次。\n?：匹配前面的元素0 次或 1 次（可选）。\n\n\n简述创建并挂载 10G 逻辑卷到 /data 的步骤。\n步骤如下：\n\n创建物理卷：pvcreate /dev/sdb1（假设用 /dev/sdb1 分区）。\n创建卷组：vgcreate vg_data /dev/sdb1。\n创建逻辑卷：lvcreate -L 10G -n lv_data vg_data。\n格式化：mkfs.ext4 /dev/vg_data/lv_data。\n挂载：mount /dev/vg_data/lv_data /data；若需开机自动挂载，添加到 /etc/fstab。\n\n\n正则表达式 ^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$ 匹配什么格式？\n\n匹配类似 123-456-7890 的格式，即北美电话号码（3位区号 + 3位前缀 + 4位号码）。\n\n\nRAID 5 单块硬盘故障后，应如何处理？\n\n需立即更换故障硬盘，随后让 RAID 阵列自动&#x2F;手动重建，将数据恢复到新硬盘；重建过程中应减少阵列读写压力，确保数据完整恢复。\n\n\n软链接的典型应用场景有哪些？\n\n常用于跨文件系统链接文件、简化长路径访问（如将深目录链接到易访问位置）、版本管理（如链接不同版本的库文件）。\n\n\nLVM 缩容逻辑卷时的注意事项是什么？\n\n缩容前需卸载逻辑卷，用 e2fsck 检查文件系统完整性；缩容后需调整文件系统大小（如 resize2fs）；过程存在数据丢失风险，需提前备份。\n\n\n写出一个匹配简单 IPv4 地址的正则表达式（不严格校验范围）。\n\n基础匹配形式为 ^[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;$（更严谨的正则需校验每段为 0 - 255，此为简化版）。\n\n\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"MySQL面试题","url":"/2025/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"07281.数据库的分类有哪些？（谈谈你知道的数据库？）分为关系型数据库(RDBMS)、非关系型数据库(NoSQL)\n关系型数据库(RDBMS)，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n关系型数据库数据之间的关系性强，查询同类信息快，存储的数据结构可以很复杂。\n\n常见的关系型数据库：mysql、oracle、db2、sql server\n\n非关系型数据库(NoSQL)：Not-Only SQL ，泛指非关系型数据库，是对关系型数据库的补充。\n非关系型数据库数据之间可以没有关系，结构简单更容易扩展，在大量数据的情况下，读写性能优秀\n\n常见的非关系型数据库：Redis、MongoDB\n\n2.sql的分类？（分别是做什么的、关键字？）sql是操作数据库的一种语言\nDDL数据定义语言、DML数据操作语言、DQL数据查询语言、DCL数据控制语言\nDDL，操作数据库、表、列等，常用语句：CREATE、 ALTER、DROP\nDML，操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE\nDQL，查询数据 常用语句：SELECT\nDCL，操作访问权限和安全级别； 常用语句：GRANT(授权)、revoke(回收)、commit(提交)、roolback(回滚)\n​\t**TCL **是事务控制语言，用于控制处理事务。其常用关键字为commit、rollback。\n3.列举mysql常用的数据类型？（场景应用说明）整数类型：\nTINYINT，适合存储状态值，如 0&#x2F;1 表示开关\n​\t\t\t\tage TINYINT UNSIGNED（适合存储 0-120 的年龄）\n​\t\t\t【使用 UNSIGNED 关键字可取消负数范围，使正数范围扩大一倍】\nINT，常用整数，适合用户id、数量等\nBIGINT，适合存储大数值，如订单号\n浮点类型：\nFLOAT，适合不需要极高精度的小数，例如产品评分\nDOUBLE，用于更精确的计算，如科学数据\nDECIMAL(M,D)，用于财务计算，如金额\n日期和时间类型：\nDATE，存储日期，如生日\nTIME，存储时间（时分秒）\nDATETIME，存储日期和时间，如订单创建时间\nTIMESTAMP，存储日期和时间，范围小，受时区影响，常用于记录最后修改时间\nYEAR，存储年\n字符串类型：\nCHAR(M)，M 为字符数（1-255），适合长度固定的数据（如密码哈希、身份证号、性别）\nVARCHAR(M)，M 为最大字符数（1-65,535），适合长度不固定的数据（如用户名、文章摘要）\n文本类型TEXT，适合文章内容等大段文本（如文章内容、评论），不能有默认值。\n二进制类型：BLOB，用于存储二进制数据（如图片、文件）\nJSON 类型：JSON：存储 JSON 格式数据（对象或数组）\n空间数据类型：\nGEOMETRY：存储几何对象（点、线、多边形等）。\nPOINT、LINESTRING、POLYGON 等：特定几何类型。用于地理信息系统（GIS）应用\n4.说说drop，truncate，delete的作用和区别（1）这个三个关键字都是删除的意思（2）DROP 删除整个表（结构）\t  TRUNCATE： 清空表中的数据，包含主键自增列的数据（可以理解为：删除表，重新创建了一个新表）;\t\tDELETE: 不删除表结构，可以清空表数据，也可以根据条件删除指定的数据\n（3）delete属于DML，会被事务管理，可以回滚，且表空间不会被释放；\n​\t\tdrop和truncate都属于DDL，不被事务管理，不能回滚，但是表空间会被释放。\n​\tdelete效率低、truncate效率高\n5、写出DDL和DML语句中增删改的语法5.1 DDL(1)创建表:\tcreate table表名();(2)修改表名:\talter tablel 旧表名 rename to 新表名;(3)新增字段:\talter table 表名 add 字段名 字段类型;(4)修改字段名:\talter table 表名 change 旧字段名 新字段名 类型;(5)修改字段类型:\talter table 表名 modify 字段名 新类型;(6)删除字段:\talter table 表名 drop 字段名;(7) 删除表:\tdrop table 表名;\n5.2 DML(1)新增数据:\tinsert into 表名（字段1, 字段2..) values (值1,值2…);(2)更新数据:\tupdate 表名 set 字段名1&#x3D;值1, 字段名2&#x3D;值2, …[where条件];(3)删除数据:\tdelete from 表名 [where条件];\n07291，sql 中如何给字段取别名，（有几种方式，分别在什么场景下使用？）​\t在 sql 语句中，使用 as 关键字 给表、字段、查询结果取别名\n​\t在简单的查询语句中，as 关键字可以省略不写，使语句更简洁\n​\t在复杂查询语句中，建议不要省略 as 关键字，这样可读性会更好\n2，distinct 关键字的作用是什么？（如何使用？需要注意什么）​\t1.distinct 关键字的作用是在查询中去除重复的数据\n​\t2.该关键字使用在指定的字段前面\n​\t3.需要注意的是，使用 distinct 关键字的字段要紧跟在 select 关键字后面\n3，where 子句种常见的运算符有哪些？​\t1.where 子句是用来做条件筛选的\n​\t2.where 子句中可以使用的运算符包括：\n\n比较运算符，例如：&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &lt;&gt;, !&#x3D;\n\n逻辑运算符，例如 and(并且运算)， or(或运算)， not(取反运算)\n\n其它特殊的运算符：between(在指定区间取值)， in(符合一组数据中的一个即可)， is null(返回null数据)…\n\n比较运算符：&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &lt;&gt;, !&#x3D;\n\n逻辑运算符：AND, OR, NOT\n\n范围运算符：BETWEEN…AND…\n\n集合运算符：IN, NOT IN\n\n空值判断：IS NULL, IS NOT NULL\n\n模糊匹配：LIKE（_   %）, NOT LIKE\n注意：在 SQL中，NULL值与任何值的比较（包括!&#x3D;)都会返回UNKNOWN\n\n\n4，like 模糊查询用法\nlike 模糊查询中有两个关键的字符，分别是 %  和 _\n% 用来做模糊，可以匹配任意个字符；\n如果我们想要精准匹配，可以使用 _, 一个 _ 匹配一个字符\n例如：’a%’匹配所有以a开头的字符串，而’a_’只匹配两个字符且第一个字符为a的字符串。\n\n\n索引查询条件中like以 % 开头，索引会失效\n\n5，列举聚合函数？说出每个聚合函数的作用常用的聚合函数有5个\n\n求最大值、最小值、求和、求平均值的聚合函数分别是：MAX, MIN、SUM、AVG\n统计记录数使用 count 函数，需要注意的是，在使用 count 时，如果使用的是 *， 也会统计出 null 值的数据行数量， 如果使用的是指定的字段名称，那么该字段位 null 数据行不会统计\n\n6，having 和 where 的区别，使用场景？(1) having 和 where 都是用来做条件筛选的\n(2)不同的是:where 是对所有的记录进行筛选， having 是对分组后的记录进行筛选；\nwhere 不能放在 group by 子句后面\nhaving 是固定和 group by 一起使用，放在 group by 后面，作用相当于 where\nwhere 后面不能使用聚合函数, having 可以\n7，order by 子句如何实现多字段排序；\ndesc 降序\nasc  升序（默认值）\n\n使用逗号分隔多个排序字段，并可以为每个字段指定排序方向\n8、order by 和 group by 的区别\n这两个子句在 sql 语法中的作用不一样\norder by 指的是 排序查询，可以根据一个字段或多个字段排序，默认 asc 升序，我们也可以指定降序排序，使用 desc 关键字\ngroup by 的作用是分组查询，可以根据一个字段或多个字段进行分组查询，需要注意的是查询的结果只能是分组的列 和 聚合函数，可以使用 having 关键字筛选分组后的数据\n\n9，mysql 中，limit 子句如何实现分页查询？谈谈它的参数的作用1.在mysql中使用 limit 关键字实现分页查询\n2.limit 关键字后面可以跟 2个参数，第一个参数表示 起始的索引值，第二个参数表示查询的每页记录数\n3.limit 后面也可以只跟一个参数，此时该参数指的是所有记录中的前n条记录（也可以理解位第一页的数据）；\n4.**mysql 8.0 **以后新增了一个分页语法，是 limit 记录数 offset 起始索引\nSQL函数1、sql 中如何处理 null 值\n\n在sql 中我们可以使用 coalesce 函数 和 ifnull 函数\n\n这两个函数都可以接收两个参数，第一个参数不为 null，返回第一个参数，为 null 则返回第二个参数\n\n\n\n2、说说 if 和 case 函数的用法\n这两个都是流程控制函数\nif 函数接收三个参数，第一个参数是表达式，如果表达成立，则该函数返回第二个参数值，如果不成立则返回第三个参数值（类似于java中的三元表达式）  \ncase 函数有两种用法\n第一种用于条件匹配，在 when 关键字后面指定条件，如果条件成立，则返回当前then的结果\n第二种用于精准匹配，这个时候是在 case 后面指定要匹配的值，和 when 后面的值进行比较，如果匹配上了，则返回当前then的结果\n这两种用法中，如果不满足条件 或者 精准匹配，都是返回 esle 后面的结果\n\n\n需要注意的是：要使用 end 关键字来结束 case 语法\n\n3、列举常用的函数\n5个聚合函数 \nnull值处理函数：COALESCE()  和 ifnull()\n数学函数：ceil(),floor(),  RAND(),  TRUNCATE()\n字符串函数：trim(), substring(), concat(), lower(), UPPER()\n日期函数：CURRENT_DATE(),CURRENT_TIME() NOW(), TIMESTAMPDIFF()\n流程控制函数： if()\n\n主键自增1.MySQL中如何设置主键自增?MySQL中通过将关键字 auto_increment添加到要自增的字段声明上设置主键自增。其设置auto_increment有以下条件：\t1.字段要求具有索引，一般我们是给主键添加，而主键具有主键索引；\t2.要求字段的类型必须是数字类型，包括整数和浮点数；\t3.在一张表中只能有一个主键自增列存在。\n约束2.数据库的约束有哪些?​\t1、概念：约束是作用于作用域中字段上的规则，用于限制存储在表中的数据目的：保证数据库中数据的正确，有效性和完整性\n​\t2、约束的分类\n数据库中常见的约束有6个\n(1) 主键约束(primary key):当前字段是数据的唯一标识符，唯一且不能为空，例如：表中 id 字段(2) 外键约束(foreign key): 用来让两张表的数据之间建立连接，保证数据的一致性和完整性(当前表的外键是一般是另一张表的主键)，例如：员工表中设置 部门编号为 外键，可以关联部门表(3) 非空约束(not null): 限制当前字段的数据不能为null，例如：给员工 姓名字段添加非空约束，姓名不能为空(4) 唯一约束(unique): 保证该字段的所有数据都是唯一、不重复，可以为null，例如：给员工 身份证号码添加唯一约束(5) 检查约束(check): 保证字段的值满足某一个条件(男&#x2F;女)，或者某个区间，例如：性别 字段 设置检查约束，限制当前字段 只能输入‘男’或 ‘女’(6) 默认值约束(default): 保存数据时,如果没有指定该字段的值,则采用默认值(入职时间,岗位)，例如：员工 岗位 字段，插入字段时 不指定字段，默认为 ‘员工’\n内外连接3.内连接、外连接的区别有哪些?(1)内连接和外连接都是用来多表查询的；\n(2)内连接使用 INNER JOIN 实现 ，外连接 使用 LEFT JOIN 或者 RIGHT JOIN 实现；\n(3)内连接是返回满足所有条件的数据行，\n而外连接是返回主表的所有数据和副表中满足条件的数据行，不满足条件的使用null填充\n使用场景：\n查询所有的员工信息和员工的部门信息，使用外连接，查询所有的员工，包括没有部门的员工信息\n查询所有 有部门的员工信息，应该使用内连接，只返回有部门的员工信息\n视图1、什么是视图，说一说视图的作用？\n视图是由查询语句定义的虚拟表（基于SQL查询语句的结果集生成的一张虚拟表），本身不存储数据（只存储查询的定义），数据来源于表，使用 view 关键字创建\n作用：\n\n\n\n\n简化复杂查询：封装常用的查询逻辑，使SQL更易理解和维护\n数据安全：通过视图控制用户对敏感数据的访问权限\n逻辑隔离：\n通过基表创建的多个视图，逻辑是相互隔离\n屏蔽底层表结构变化，提供统一的数据接口\n\n\n\n\n总的来说，视图可以简化复杂查询，增强数据的安全性和逻辑性\n2.通过视图更新基表要满足什么条件？\n视图定义中只包含一个基表\n视图中包含基表的主键或唯一键\n视图中没有包含聚合函数(如SUM, AVG, COUNT等)\n视图中没有包含DISTINCT关键字\n视图的定义中不能包含表达式或者子查询\n\n3、视图和表的区别是什么\n\n存储方式：视图是虚拟表，不存储数据，基表是存储实际数据的；\n空间占用：视图仅仅占用定义的空间，表占用物理存储空间；\n更新操作：视图更新基表有限制，表可以直接更新\n\n\n4、查询视图和查询基表，谁的效率高，为什么？\n查询基表的效率高，视图相当于一个中间商，查询视图，本质是通过是视图查询基表，效率没有直接查询基表的效率高\n因为视图不存储数据，每次查询视图时，都需要执行视图定义中的 select 语句，动态生成结果，而直接查询基表可以直接读取存储的数据，减少计算开销。\n\n5、哪些情况下，视图无法直接执行 INSERT、UPDATE 或 DELETE 操作？至少列举 3 种\n\n视图定义中使用了 distinct 或者 聚合函数\n视图的查询中使用了多表连接（join）\n视图的定义中，字段包含表达式计算（ 例如 sal*1.2）\n\n\n6、某电商系统需要频繁查询 “近 30 天已付款的订单及对应商品名称”，这个场景是否适合用视图？为什么？\n适合原因：使用视图的目的是为了简化查询语句当前的业务中：近 30 天已付款 的查询条件是固定的，查询 订单及对应商品名称 也是固定，也就是说这个复杂查询的sql语句不会变化，所以适合使用 视图 来优化\n\n存储过程1.什么是存储过程？存储过程优缺点？\n存储过程是一组预先编译好的SQL语句集合\n存储在数据库服务器中，由客户端通过名称和参数重复调用执行\n可以接收参数、执行特定操作并返回结果\n使用BEGIN…END构造来包含多条语句\n\n\n\n优点\n\n(1)存储过程是预编译的代码块**，执行效率高**(2)存储过程在服务器端运行，减少客户端压力(3)存储过程只需要创建一次，可以重复使用(4)存储过程代替大量的SQL语句，提高通信速率(5)可以一定程度上确保数据安全\n\n事务处理：可以在存储过程中进行完整的事务控制\n缺点\n\n不同数据库的存储过程语法不同，可移植性差\n调试和维护较困难\n占用数据库资源较多\n对数据库服务器产生一定负担\n\n\n不适合处理大量的文本和图像数据\n\n\n\n2.说一下存储过程的参数\n\nIN参数：输入参数，在存储过程中值不会被修改\nOUT参数：输出参数，在存储过程中赋值后返回给调用者（可以重新赋值，在调用存储过程时可以获取该结果）\nINOUT参数：既是入参，也是出参，具备入参和出参的特点，调用时提供值并能被修改后返回\n\n\n4.说一说系统变量、用户变量和局部变量的作用\n\n系统变量：是控制数据库特定行为的参数，这些变量可以被设置为特定的值来改变服务器的默认设置，比如说 autocommit，这个系统变量可以设置提交事务的行为\n用户变量和局部变量 可以用来保存一些临时数据，例如 在 存储过程中声明局部变量，接收 sql 操作的结果\n\n\n5、创建存储过程时，BEGIN...END块的作用是什么？如果存储过程只有一条 SQL 语句，是否可以省略？\nBEGIN…END 块的作用是包裹多条 sql 语句或者复杂的业务逻辑可以省略\n\n6、 调用存储过程使用什么语句？若存储过程有 OUT 参数，如何获取其返回值？\n使用 call 存储过程名称来调用\n我们可以在存储过程外面声明一个用户变量，在调用 存储过程是，使用该变量接收 out 参数\n\n7、MySQL 中能否直接修改存储过程的逻辑（如 SQL 语句）？若不能，如何实现 “修改” 效果？\n在 8.0.16 版本之前使用 drop，create 重新创建来修改 存储过程的逻辑\n在 8.0.16 版本之后可以使用 alter 关键字修改 存储过程的逻辑，语法和创建的语法类似\n\n8、 为什么说存储过程可能增加数据库维护成本？请举例说明。\n可移植性不高，切换数据库，那么存储过程的语法可能需要重写逻辑复杂不易维护\n\n9、某系统需要 “根据用户 ID 批量删除其所有订单及关联数据”，这个场景是否适合用存储过程？为什么？\n适合使用存储过程的目的是为了简化操作逻辑，提升执行效率，在当前的业务中删除的逻辑复杂，且逻辑是一致的不会变化，所以适合使用存储过程\n\n10、 存储过程中能否使用事务控制语句（如BEGIN TRANSACTION、COMMIT）？请说明原因游标1. 什么是游标，说说它的作用\n游标是数据库中用于逐行遍历查询结果集的数据库对象，可以在存储过程和存储函数中声明使用，声明游标的关键字是 cursor\n游标相当于一个集合，保存查询出来的一组数据，可以逐行遍历\n\n游标的主要作用：\n\n逐行处理查询结果集\n对每一行数据进行单独的操作和处理\n在存储过程中实现复杂的逻辑控制\n处理需要循环操作的业务场景\n\n2. 游标和普通 select 查询的核心区别普通 SELECT 查询：一次性返回所有符合条件的记录(依从性返回所有结果集)，适合批量数据处理\n游标查询：游标允许逐行访问结果集，适合需要对每行数据进行单独处理的场景,支持循环控制流程\n3. 使用游标的步骤\n声明游标：定义游标关联的查询结果集(declare 游标名称 cursor for 查询语句);\n声明 not found 异常处理器：标记循环遍历游标结束的条件；\n打开游标：open 游标名称\n获取数据：fetch 游标名称 into 变量\n关闭游标：close 游标名称\n\n4. 什么场景适合使用游标，什么场景不适合？适合使用游标的场景：\n需要逐行处理结果集（例如：批量更新员工的部门，又比如根据条件修改员工的工资）\n\n需要对每行数据进行不同的复杂处理逻辑\n需要根据当前行数据决定后续操作\n处理数据量较小且需要精细控制的场景\n\n不适合使用游标的场景：\n结果集太大不合适使用游标（游标加载全部数据到内存，效率低），可以通过 update&#x2F;delete直接操作表\n\n简单的批量数据操作（用 UPDATE、DELETE 等更高效）\n大数据量处理（性能较差）\n只需要统计或聚合操作的场景\n\n异常5. MySQL 中3种常见异常\n主键冲突： sqlstate ‘23000’， 错误码 1062;\n除零异常： sqlstate ‘22012’, 错误码 1365;\n数据类型不匹配异常： sqlstate ‘22005’， 错误码 1366;\n游标遍历结束：not found\n\n6. MySQL 中异常处理的两种方式EXIT 方式：\n\n捕获异常后，退出当前存储过程，适用于严重的错误，例如：主键冲突，事务失败\n\n\n遇到异常时立即退出当前执行块\n适用于严重错误，需要立即终止程序执行的场景\n保证数据的完整性和一致性\n\nCONTINUE 方式：\n\n捕获异常后，继续执行过程，适用于不影响后续逻辑的轻微错误，例如：游标结束\n\n\n遇到异常时记录错误但继续执行后续代码\n适用于可容忍的错误，希望程序继续运行的场景\n用于批量处理中部分数据出错但不影响整体流程的情况\n\n存储函数存储函数和存储过程的区别?\n1.声明的关键字不一样：存储过程使用 procedure，函数使用 function\n2**.参数类型**支持不一样：存储过程支持 IN\\OUT\\INOUT参数类型，函数仅支持 IN类型参数\n3.返回结果的处理方式不一样：存储过程可以通过OUT参数返回结果，或者不返回结果，函数必须返回结果，使用 return 关键字\n4.调用方式：存储过程通过 call 语句调用，函数可以直接嵌套在 sql 语句中\n5.事务支持不一样：存储过程完全支持事务，函数支持事务但是有限制(不推荐在函数中使用事务)\n\n1、什么是存储函数？其核心特征是什么？存储函数是预编译并存储在数据库中的SQL程序，必须返回一个值，可嵌入SQL语句（如SELECT）中调用，用于实现特定计算或查询逻辑。\n核心特征：强制返回值、仅支持IN参数、可嵌入SQL。\n存储函数特性选项说明：标明特性的目的是：告诉数据库引擎，优化函数的执行效率取值如下：（1）DETERMINISTIC ：输入相同的参数时，返回的结果时固定的，多次调用，直接复用结果，有助于优化器提速；确定性函数：是指每次调用函数时，传同一个参数，返回值是固定的如果 传递一个参数 返回值是固定的第一次调用时会执行函数，计算出结果并缓存；之后每次调用则使用缓存的结果，不需要再次执行函数过程，提升执行效率（2）SQL DATA ACCESS ：声明的函数对数据的操作类型   no sql ：无数据操作   reads sql data ：仅读数据   modifies sql data ：修改数据\n2、存储函数为什么必须有返回值？如何指定返回值类型？存储函数本质是“计算工具”，需像数学函数（f(x)=y）一样输出结果，因此必须通过RETURN语句返回值。通过CREATE FUNCTION中的RETURNS 数据类型（如RETURNS INT）指定返回值类型。\n3、存储函数与存储过程在参数类型上有何区别？存储函数仅支持IN类型参数（输入参数，默认隐含）；存储过程支持IN（输入）、OUT（输出）、INOUT（双向）三种参数类型。\n4、存储函数能否直接返回结果集？（如SELECT * FROM 表）？为什么？不能。存储函数中的SELECT语句必须通过INTO子句将结果存入变量（如SELECT name INTO var FROM users），无法直接返回结果集；存储过程则可直接返回结果集。\n5、什么场景适合使用存储函数？举一个实际业务例子。适合计算型场景，适合简单计算、数据转换或单行查询结果处理，如数学运算、格式转换、业务规则计算\n例子：计算员工年终奖金的函数，根据工龄和绩效返回奖金金额\n例如：创建calc_age(birth_date DATE)函数，根据出生日期计算年龄，可直接在SELECT中调用（SELECT name, calc_age(birth) FROM users）。\n6、存储函数中如何主动抛出异常？请写出核心代码。SIGNAL SQLSTATE &#x27;45000&#x27; SET MESSAGE_TEXT = &#x27;自定义错误信息&#x27;;\n\n使用SIGNAL语句。例如：参数非法时抛异常：  \nIF price &lt; 0 THEN  SIGNAL SQLSTATE &#x27;45000&#x27;   SET MESSAGE_TEXT = &#x27;价格不能为负数&#x27;;END IF;\n\n\n\n7、创建存储函数时，DETERMINISTIC特性的作用是什么？默认值是什么？DETERMINISTIC表示函数输入相同参数时返回结果固定（如数学计算），帮助优化器缓存结果提升效率。\n默认值是NOT DETERMINISTIC（非确定性）\n触发器1、什么是触发器？其“自动触发”的核心条件是什么？触发器是与表关联的特殊程序，当表发生INSERT&#x2F;UPDATE&#x2F;DELETE操作时自动执行。\n核心条件：关联表发生指定触发事件（如INSERT），且满足触发时机（BEFORE&#x2F;AFTER）。\n2、触发器的BEFORE和AFTER触发时机有何本质区别？分别适用于什么场景？BEFORE在操作执行前触发，可修改即将插入&#x2F;更新的数据（如校验、自动计算字段）；例如在插入员工数据之前，检验是否允许插入；\nAFTER在操作执行后触发，适合记录日志、同步数据（无法修改已提交数据）。例如在插入员工后，记录日志。\n3、触发器中NEW和OLD关键字的作用是什么？分别在哪些触发事件中可用NEW.字段引用插入&#x2F;更新后的新值（INSERT&#x2F;UPDATE可用）；\nOLD.字段引用更新&#x2F;删除前的旧值（UPDATE&#x2F;DELETE可用）。\n例如：UPDATE触发器中，OLD.price是旧价格，NEW.price是新价格。\n4、触发器能否修改自身关联表的数据？为什么？不建议。若触发器中修改自身关联表（如UPDATE触发器又UPDATE同表），可能导致递归触发（无限循环执行），引发性能问题或数据异常。\n5、什么场景适合使用触发器？举一个实际业务例子。适合自动维护数据一致性、记录变更日志。如审计日志、数据同步\n例如：创建AFTER UPDATE触发器，当products表价格修改时，自动向price_logs表插入旧价格、新价格和修改时间。\n6、触发器与存储过程的核心区别是什么？触发器是“事件驱动自动执行”，无需手动调用，依附于表的操作；\n存储过程是“手动调用执行”，可独立存在，不依赖表事件。\n7、如何查看某张表关联的所有触发器？通过系统表查询：  \nSELECT * FROM information_schema.TRIGGERS WHERE EVENT_OBJECT_TABLE = &#x27;表名&#x27;;\n\n\n\n定时任务（MySQL事件）1、什么是MySQL事件（定时任务）？其依赖的核心组件是什么？MySQL事件是按预设时间&#x2F;周期自动执行的SQL程序（如数据清理、统计），依赖事件调度器（event_scheduler） 进程监控和触发执行。\n2、启用MySQL事件调度器的临时和永久方式分别是什么？临时启用：SET GLOBAL event_scheduler = ON;；\n永久启用：修改配置文件（如my.cnf）添加event_scheduler = ON，重启MySQL生效。\n3、MySQL事件支持哪两种触发模式？分别用什么语法定义？（1）一次性触发：ON SCHEDULE AT &#39;具体时间&#39;\n（如AT &#39;2025-12-31 23:59&#39;）；（2）周期性触发：ON SCHEDULE EVERY 时间间隔 [STARTS 开始时间]\n（如EVERY 1 DAY STARTS &#39;2025-01-01 03:00&#39;）。\n4、创建定时任务时，ON COMPLETION PRESERVE的作用是什么？默认行为是什么？ON COMPLETION PRESERVE表示事件执行完成后保留（不自动删除）；\n默认行为是ON COMPLETION NOT PRESERVE（一次性事件执行后自动删除）。\n5、定时任务适合处理哪些业务场景？不适合哪些场景？适合：数据库内部周期性操作（如每日清理过期数据、每小时统计订单）；\n不适合：实时性要求极高的任务（调度器有秒级延迟）、跨数据库&#x2F;系统的复杂操作。\n6、如何暂停一个正在运行的定时任务？如何彻底删除？暂停（禁用）：ALTER EVENT 事件名 DISABLE;；\n彻底删除：DROP EVENT IF EXISTS 事件名;。\n事务1、说说事务的四大特性\n事务的四大特性（ACID）：原子性（Atomicity）：是指事务是一个不可分割的整体，事务中的操作要么全部成功，要么全部失败回滚；\n例如：转账业务中减钱和加钱的操作，要么同时成功，要么同时失败。\n一致性（Consistency）：是指一个事务中，事务前后数据的完整性必须保持一致；\n例如：转账业务中，转账前和转账后，总金额必须一致。\n隔离性（Isolation）：多个事务，在并发事务中，一个事务不能被其他事务所干扰，多个并发事务之间数据要相互隔离。持久性（Durability）：是指一个事务一旦被提交，该事务对数据库中数据的操作，必须被持久化\n\n2、说说事务的隔离级别\n事务的隔离级别从低到高：读未提交（Read Uncommitted）：允许读取未提交的数据，可能出现脏读、不可重复读和幻读。读已提交（Read Committed）：只允许读取已提交的数据，避免了脏读，但可能出现不可重复读和幻读。（oracle默认）可重复读（Repeatable Read）：在同一事务中多次读取同样的数据结果一致，避免了脏读和不可重复读，但可能出现幻读。MySQL的InnoDB默认使用这种隔离级别。\nmysql中InnoDB增强，通过间隙锁和临键锁也解决了幻读\n串行化（Serializable）：最高级别，事务串行执行，避免了所有并发问题，但性能最差。\n\n3、什么是事务？请用生活中的例子类比事务的核心特性。事务是数据库中的一系列操作，这些操作要么全部成功执行，要么全部不执行，是数据库操作的基本单位。\n以银行转账为例：\n原子性：小明给小红转账1000元，要么成功（小明账户-1000，小红账户+1000），要么失败（两个账户都不变），不会出现只扣款不到账的情况。\n一致性：转账前后，两个账户的总金额保持不变，符合”钱不会凭空消失或增加”的规则。\n隔离性：小明给小红转账的同时，小王也在查询小红的账户余额，小王应该只能看到转账完成前或完成后的状态，而不是中间状态。\n持久性：一旦转账成功，即使银行系统立即崩溃，重启后小红的账户里仍然有这笔钱。\n4、事务的ACID特性中，”原子性”和”持久性”分别依赖MySQL的哪些机制实现？在MySQL中：\n**原子性（Atomicity）**依赖 undo log（回滚日志），记录操作的反向逻辑，事务失败时通过undo log撤销已执行的修改； \n**持久性（Durability）**依赖 redo log（重做日志），事务提交时先将修改写入redo log（磁盘），即使数据库崩溃，重启后可通过redo log恢复已提交的修改。  \n5、事务的隔离级别中，”读已提交（RC）”和”可重复读（RR）”的核心区别是什么？MySQL的InnoDB默认使用哪种？\n核心区别：RC级别下，事务中两次读取同一数据可能因其他事务提交而不一致（不可重复读）；RR级别下，事务中多次读取数据结果一致（通过MVCC和间隙锁实现）。  \nInnoDB默认隔离级别是可重复读（RR）。\n\n6、什么是”脏读”？如何通过隔离级别避免脏读？脏读：一个事务读取到另一个事务未提交的数据。这种情况下，如果未提交的事务最终回滚，那么读取到的数据就是无效的。\n如何通过隔离级别避免脏读： 设置事务隔离级别至少为”读已提交（Read Committed）“或更高级别。\n\n读未提交（Read Uncommitted）：允许脏读\n读已提交（Read Committed）：避免脏读，但可能有不可重复读\n可重复读（Repeatable Read）：避免脏读和不可重复读\n串行化（Serializable）：避免所有并发问题\n\n7、事务的并发问题\n1、脏读：是指一个事务读取到了另外一个事务未提交的数据（脏数据）；\n2、不可重复读：当前事务在读取数据时，另外一个事务修改了数据，导致当前事务对数据的两次查询结果不一致；3、幻读：当前事务读取表数据，另外一个事务对表的数据进行了新增或删除，导致当前事务对表的两次查询结果不一致。\n\n8、长事务有哪些风险？如何优化长事务？风险包括：占用锁资源导致并发阻塞、产生大量undo log占用磁盘空间、数据库崩溃后恢复时间长。优化方案：拆分长事务为短事务（如批量更新分批次执行）、减少事务中的非数据库操作（如网络请求）、合理设置锁等待超时时间。 \n9、事务的”一致性”与数据库三范式的”一致性”有何区别？\n事务的一致性：指事务执行前后，数据从一个合法状态转换到另一个合法状态（如库存不能为负），是运行时的数据正确性保障；  \n\n三范式的一致性：指表结构设计中数据无冗余、无异常，是设计时的数据存储合理性保障。\n\n\n10、MySQL中如何手动控制事务？请写出“转账”场景的事务控制代码示例。手动控制事务的核心语句包括`BEGIN`、`COMMIT`、`ROLLBACK`。  \n\n-- 转账示例（A账户向B账户转100元）：  BEGIN; -- 开启事务UPDATE accounts SET balance = balance - 100 WHERE id = &#x27;A&#x27;; -- A扣款UPDATE accounts SET balance = balance + 100 WHERE id = &#x27;B&#x27;; -- B入账COMMIT; -- 提交事务（若两句都成功）-- 若中间出错，执行 ROLLBACK; 撤销所有修改\n\n-- 使用存储过程，完成转账业务操作-- 需求-- （1）查询余额 &gt; 1000 的 就可以转账， 小于 1000， 提示余额不足-- （2）转账过程中出现异常，就回滚事务  DROP PROCEDURE IF EXISTS transfer_money;CREATE PROCEDURE transfer_money( IN out_id INT,  -- 转出账户 IN in_id INT,   -- 转入账户 IN `money` DECIMAL(10, 2),   -- 转账金额 OUT result_msg  VARCHAR(255)   -- 转账结果)label: BEGIN   -- 声明变量   DECLARE out_balance DECIMAL(10, 2);   -- 转出账户的余额   DECLARE has_in_id INT DEFAULT 0;   -- 判断转入账户是否存在      -- 异常处理处理器   DECLARE EXIT HANDLER FOR  SQLEXCEPTION   BEGIN     ROLLBACK;  --  回滚事务     SET result_msg := &#x27;转账失败，系统出现异常，请重试！&#x27;;   END;      -- 判断转入账户是否存在   SELECT count(*) INTO has_in_id FROM `account` WHERE id = in_id;       IF has_in_id = 0 THEN     SET result_msg := &#x27;转入账户不存在！&#x27;;     LEAVE label;   END IF;       -- 开始事务   START TRANSACTION;         -- 查询转出账户余额   SELECT balance INTO out_balance FROM `account` WHERE id = out_id;         -- 判断余额   IF out_balance &gt;= `money` THEN       -- 转出账户减钱      UPDATE account SET balance = balance - `money`  WHERE  id =  out_id;      -- 模拟的sql异常        -- select * from ccc;            -- 转入账户加钱      UPDATE account SET balance = balance + `money`  WHERE id =  in_id;            -- 转账完成      COMMIT;      SET result_msg := &#x27;转账成功&#x27;;   ELSE      ROLLBACK;     SET result_msg := &#x27;转账失败，您的余额不足！&#x27;;   END IF;END;-- 测试SET @result := &#x27;&#x27;-- 正确转账-- CALL transfer_money(1, 3, 1000, @result)-- 余额不足-- CALL transfer_money(3, 2, 2000, @result)-- 账号不存在-- CALL transfer_money(2, 5, 2000, @result)-- 出现异常CALL transfer_money(1, 3, 1000, @result)SELECT @result;\n\n\n\n数据库三范式1、什么是数据库设计三范式数据库的三大范式是关系型数据库设计中用于规范表结构、减少数据冗余和避免更新异常的重要原则。\n1NF：列不可分割（原子性）。2NF：消除非主属性对复合主键的部分依赖（基于1NF）。3NF：消除非主属性之间的传递依赖（基于2NF）。\n\n第一范式（1NF）：要求表中的每个字段都是原子性的，不可再分。\n第二范式（2NF）：在1NF的基础上，要求非主键字段必须完全依赖于主键，而不是部分依赖。解决的是复合主键下，表中数据冗余和更新异常的问题\n第三范式（3NF）：在2NF的基础上，要求消除非主键字段对主键的传递依赖。解决的是非主键属性对主键的依赖传递问题（非主键属性之间存在依赖）\n\n2、什么是数据库范式？其核心目的是什么？数据库范式（Normal Form）是关系型数据库设计的规范，用于指导表结构设计以减少数据冗余和避免更新异常（如插入异常、删除异常、修改异常）。\n**核心目的：**通过合理拆分表，确保数据的一致性和存储效率。 \n3、第一范式（1NF）的定义是什么？请举例说明”不满足1NF”和”满足1NF”的情况。第一范式（1NF）定义：要求表中的每个字段都是原子性的，不可再分，即每个字段只包含单一值，不能有重复的属性组。\n不满足1NF的例子： 学生表(学号, 姓名, 课程[语文,数学,英语]) ，”课程”字段包含多个值，不是原子性的。\n满足1NF的例子： 学生表(学号, 姓名) 选课表(学号, 课程名称)，每个字段都是原子性的，不可再分。 \n4、 第二范式（2NF）的前提是什么？其核心要求是什么？第二范式（2NF）的前提：首先满足第一范式（1NF）。\n核心要求：表中的非主键字段必须完全依赖于主键，而不是部分依赖。即如果一个表有复合主键，那么每个非主键字段都必须依赖于整个主键，而不能只依赖于主键的一部分。\n例如：选课表(学号, 课程号, 成绩, 课程名称) ，其中(学号,课程号)是复合主键，”成绩”完全依赖于(学号,课程号)，但”课程名称”只依赖于”课程号”，这就是部分依赖，不满足2NF。\n5、 第三范式（3NF）的前提是什么？其核心要求是什么？与2NF的区别是什么？第三范式（3NF）的前提：满足第二范式（2NF）。\n核心要求：表中的非主键字段不能依赖于其他非主键字段，即消除非主键字段对主键的传递依赖。\n与2NF的区别：\n\n2NF解决的是非主键字段对主键的部分依赖问题\n3NF解决的是非主键字段对主键的传递依赖问题\n\n例如：学生表(学号, 姓名, 系名, 系主任) 其中”学号”是主键，”系主任”依赖于”系名”，而”系名”依赖于”学号”，这就形成了”学号-&gt;系名-&gt;系主任”的传递依赖，不满足3NF。\n需拆分出系表（存储系别和系主任），学生表仅保留学号和系别，通过系别关联。 \n6、满足三范式的表一定是”好的设计”吗？为什么需要”反范式化”？不一定。三范式虽减少冗余，但可能导致表数量过多，查询时需频繁关联（如多表JOIN），降低查询性能。 \n反范式化是指有选择地增加冗余字段，减少表关联，提升查询效率，适合读多写少的场景（如电商商品详情页，将商品分类名称冗余到商品表，避免关联分类表）。 \n7、请用一个实例说明”不满足三范式”可能导致的”更新异常”。例如现在有一张学生表，维护学生的学号，学生的老师编号以及老师的手机号，现在这张表的字段存在依赖传递问题，老师的手机号依赖老师的编号，老师的编号依赖学生学号，不满足第三范式；                                                            \n假如有一条数据：1号学生对应的老师编号是 101， 老师的手机号是 123，  那么现在如果我们更新1号学生的教师手机号为456，那么该学生表中 其它学号的学生对应的 101 号教师的手机号就不匹配了，出现更新异常。\n解决这个问题的方式有两种：\n\n（1）更新1号学生信息的同时，要更新表中所有该教师的手机号，非常麻烦（2）设计更规范的表，将学生表拆分成两张表，将教师的手机号和教师编号单独使用教师表维护，学生表只维护学号和直接依赖的教师编号即可，这就是符合 数据库设计的第三范式，消除非主键对主键的传递依赖\n\n\n不满足三范式的表例子： 学生选课表(学号, 姓名, 课程号, 课程名称, 成绩)\n这个表中，”课程名称”依赖于”课程号”，而不是直接依赖于主键”学号”，形成了传递依赖，不满足3NF。\n\n可能导致的更新异常：\n\n更新异常：如果需要修改某个课程的名称，必须找到并更新所有选修该课程的记录，否则会导致数据不一致。例如，课程”C001”名称从”数据库”改为”数据库原理”，需要修改所有选修C001的记录。\n插入异常：如果要添加一门新课程，但还没有学生选修，就无法在该表中添加课程信息。\n删除异常：如果某门课程的所有学生记录都被删除，则该课程的信息也会丢失。\n\n存储引擎1、什么是存储引擎？MySQL中常见的存储引擎有哪些？存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。\n常见的存储引擎：\n\n1、 InnoDB：是一种兼顾高可靠性和高性能的通用存储引擎，从MySQL 5.5开始成为默认的存储引擎。它支持事务处理（ACID兼容）、行级锁定、外键约束、崩溃恢复等特性，适合于高并发环境下的数据操作。\n2、MyISAM：在MySQL 5.5之前是默认的存储引擎。它不支持事务和行级锁，但因为其设计简单，所以在某些读密集型应用中表现良好。不过，它的表级锁定限制了写操作的并发性。\n3、Memory：将所有数据保存在内存中，因此读写速度非常快，适用于需要快速查找的临时表格。但是由于数据只存在于内存中，所以如果服务器关闭或崩溃，数据会丢失，安全性差。\n\n2、InnoDB和MyISAM的核心区别是什么？（高频考点）\n事务支持：InnoDB 提供完整的 ACID 事务支持，而 MyISAM 完全不支持事务。\n锁机制：InnoDB 采用行级锁，允许多个事务并发修改不同行；MyISAM 使用表级锁，任何写操作都会锁定整个表，遇到大量并发写入时性能瓶颈明显。\n数据完整性：InnoDB 支持外键约束和崩溃自动恢复（通过 redo log）；MyISAM 不支持外键，崩溃后需要手动修复表（崩溃后可能数据损坏）。\n索引结构：InnoDB 采用聚簇索引，数据与主键索引绑定存储；MyISAM 使用非聚簇索引，数据与索引分离存储。\n文件存储：InnoDB 将数据+索引存储在 .ibd 文件中；MyISAM 分离存储数据（.MYD）和索引（.MYI）。\n适用场景：InnoDB 适合高并发事务型应用（如电商、金融）；MyISAM 适合读多写少的事务性要求不高的场景（密集型应用）。\n\n3、为什么InnoDB是MySQL的默认存储引擎？\n\n支持事务和ACID特性，保证数据一致性；  \n行级锁支持高并发场景，减少锁冲突；  \n聚簇索引设计提升查询效率；  \n支持崩溃恢复和外键，适合复杂业务场景（如电商、金融）。\n\n\n4、Memory存储引擎的特点和适用场景？\n核心特点：\n\n数据存储在内存中，读写速度极快，但数据易失性使其不适合持久化存储。\n使用哈希表实现索引，查找速度快，但索引大小受内存限制。\n不支持事务和行级锁定，只能进行表级锁定，写操作时会锁定整个表。\n\n适用场景：\n\n临时数据存储和查询，如复杂查询的中间结果存储、临时排序等，提升查询效率。\n缓存频繁查询的数据，如热点数据缓存，减少磁盘 I&#x2F;O 操作，加快查询速度。\n性能测试和调试，因其内存操作的高效性，可快速测试数据库性能或调试 SQL 查询。\n\n\n5、说说mysql 体系结构\n连接层：主要负责连接处理、授权认证、安全方案等功能。\n服务层：主要负责核心服务功能，比如sql接口，完成缓存查询，内置函数的执行等功能。\n引擎层：存储引擎主要负责 mysql 中数据的存储和提取。\n存储层：主要负责将数据存储到磁盘文件中\n\n6、存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\nInnoDB : 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。\nMyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\nMEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n\n索引1、什么是索引？索引的核心作用是什么？\n\n索引是数据库中用于快速定位表中数据的结构，就像书的目录，可根据索引快速找到对应数据。\n\n核心作用：加速查询速度（减少数据扫描范围）；但会降低写入性能（需维护索引结构）。\n\n\n\n2、常见的索引类型有哪些？\n按结构分：B+树索引（最常用）、哈希索引、全文索引、R树索引。  \n按功能分：  \n聚簇索引（主键索引，叶子节点存完整数据）；  \n非聚簇索引（二级索引，叶子节点存主键值）；  \n联合索引（多列组合索引）；  \n唯一索引（值唯一，如身份证号）。\n\n\n\n结构：\n​\tB+树索引（最常用）、哈希索引、全文索引、R树索引。  \n（1）主键索引：针对于表中主键创建的索引，默认自动创建, 只能有一个，关键字：PRIMARY（2）唯一索引：避免同一个表中某数据列中的值重复，可以有多个，关键字：UNIQUE（3）普通索引：快速定位特定数据，最基本的索引类型，无唯一性限制（4）全文索引：全文索引查找的是文本中的关键词，而不是比较索引中的值\n功能：（1）聚集索引&#x2F;聚簇索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。\n（2）二级索引&#x2F;非聚簇索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键\n（3） 联合索引：多列组合索引（需遵循最左前缀原则）\n3、B+树索引的优势是什么？（高频考点）\n1.b+tree 可以存放多个节点\n2.非叶子结点只存储索引键（好处：每页存放的节点数量可以更多，树的高度越低，查询效率越快）\n3.所有的数据都存储在叶子结点（好处：在叶子结点形成双向链表，更利于范围查询）\n\n\n\n叶子节点按顺序链表连接，支持范围查询（如BETWEEN、ORDER BY）；  \n非叶子节点仅存索引键，索引树高度低（通常3-4层），查询效率高；  \n所有数据存在叶子节点，查询结果稳定（每次查询路径长度一致）。  \n稳定的查询性能：所有数据都存储在叶子节点，查询任何数据的路径长度都相同，保证了稳定的查询性能\n\n\n4、聚簇索引和非聚簇索引的区别？\n\n聚簇索引：索引和数据存于同一文件（InnoDB的主键索引），叶子节点即数据行；查询时找到索引即可获取数据，效率高。  一个表只能有一个聚簇索引\n非聚簇索引：索引和数据分离（MyISAM所有索引），叶子节点存数据地址；查询时需先查索引，再通过地址取数据（回表），效率较低。一个表可以有多个非聚簇索引\n\n\n聚集索引的特点是：默认使用主键创建聚集索引，叶子节点保存了整行数据\n非聚集索引的特点是：使用其它字段创建的例如单列索引、联合索引都是非聚集索引，叶子节点保存的是主键，如果不能在非聚集索引表中直接查询到数据，那么需要回聚集索引表查询数据，也就是回表查询。\n5、聚簇索引选取的规则？如果存在主键，主键索引就是聚簇（聚集）索引\n如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚簇（聚集）索引\n如果表没有主键或合适的唯一索引，InnoDB会自动生成一个rowid作为隐藏的聚簇（聚集）索引\n6、聚簇索引和二级索引谁的查询的效率高？为什么？\n聚簇索引的效率高\n聚簇索引将数据存储与索引放到了一块，二级索引将数据与索引分开存储，它的索引结构的叶子节点关联的是对应的主键，使用二级索引查询，还是需要回表查询聚簇索引\n\n7、哪些情况会导致索引失效？（高频考点）\n查询条件中使用函数或表达式：WHERE YEAR(create_time)=2023\n隐式类型转换：字符串索引列使用数字查询 WHERE id=&#39;100&#39; (id 是整数)\nLIKE语句以 % 开头：WHERE name LIKE &#39;%abc&#39;\nOR连接的列中有非索引列：WHERE id=1 OR age=20（age 无索引）\n联合索引未遵循最左前缀原则：如联合索引(a,b,c)，查询b=1会失效\n使用不等于操作符：WHERE status != 1\n数据量过少：优化器判定全表扫描更快（通常 &lt; 10 行）\n\n8、如何使用索引优化sql查询\n9、联合索引的“最左前缀原则”是什么？查询条件必须包含联合索引中最左边的列，才能有效利用索引，跳过中间某列时，后面列的索引会失效。\n\n联合索引(a,b,c)的生效顺序为a→a,b→a,b,c；  \n若查询条件不包含最左列（如b=1或b=1 AND c=2），索引失效；  \n设计时需将高频查询列放左侧（如(用户ID, 订单时间)）。\n\n10、为什么不建议大量创建索引？\n写入（INSERT&#x2F;UPDATE&#x2F;DELETE）时需维护索引结构，耗时增加；  \n索引占用磁盘空间，过多会浪费存储；  \n优化器可能选择低效索引，反而降低查询性能。\n\n索引也是一个表结构，它会占据磁盘空间在增删改数据的时候，加了索引的字段，索引表的结构会跟着发生更新，大量创建索引的话，那么更新的索引表就多，降低性能\n\n\n11、InnoDB为什么推荐使用自增主键作为聚簇索引？\n自增主键保证新数据追加到索引树末尾，避免索引树分裂（减少碎片）；  \n自增主键值小且连续，节省索引空间；  \n若用非自增主键（如UUID），会导致索引树频繁分裂，降低性能。\n\n12、主键索引原则\n\nmysql管理 常用工具举例说明常见的mysql管理工具，并说明作用mysql客户端、mysqladmin、mysqlbinlog、mysqlshow、mysqldump、mysqlimport  和 source\n1.mysql（命令行客户端工具）\n作用：\n\n连接 MySQL 服务器并执行 SQL 命令\n支持批处理脚本操作\n远程连接管理数据库\n\n2.mysqladmin（管理客户端）\n作用：\n\n检查服务器状态和配置\n创建&#x2F;删除数据库\n刷新权限&#x2F;日志\n关闭服务器\n\n3.mysqlbinlog（二进制日志工具）\n作用：\n\n解析二进制日志文件（binlog）\n数据恢复和审计\n主从复制故障排查\n\n4.mysqlshow（元数据查看工具）\n作用：\n\n显示数据库&#x2F;表&#x2F;列结构\n统计数据库对象信息\n快速查看表状态\n\n5.mysqldump（数据备份工具）\n作用：\n\n逻辑备份数据库\n生成 SQL 格式转储文件\n支持全库&#x2F;单库&#x2F;单表备份\n\n6.mysqlimport（数据导入工具）\n作用：\n\n批量导入文本文件数据\n高效加载分隔符格式数据\n与 mysqldump 的 -T 选项配对使用\n\n7.source（SQL 脚本执行命令）\n作用：\n\n在 MySQL 客户端内执行 SQL 脚本\n恢复 mysqldump 备份\n批量执行 DDL&#x2F;DML 语句\n\n数据库锁1、数据库锁的核心作用是什么？协调并发事务对共享资源的访问，保证数据一致性（避免脏读、不可重复读、幻读），同时平衡并发性能。\n2、MySQL 中有哪些锁类型？（按粒度&#x2F;类型分类）\n按粒度：表锁（MyISAM）、行锁（InnoDB）、页锁（少见）；  \n按类型：共享锁（S锁，只读）、排他锁（X锁，读写）；  \n特殊锁：意向锁（IS&#x2F;IX，表级）、间隙锁（Gap Lock，范围锁）、临键锁（Next-Key Lock，记录+间隙锁）。\n\n3、行锁和表锁的区别是什么？\n\n\n维度\n行锁（InnoDB）\n表锁（MyISAM）\n\n\n\n锁定粒度\n单行记录\n整张表\n\n\n并发能力\n高（支持多事务并行）\n低（锁冲突概率高）\n\n\n开销\n大（加锁慢）\n小（加锁快）\n\n\n死锁\n可能发生\n不会发生\n\n\n4、InnoDB 的行锁是如何实现的？为什么行锁必须基于索引？InnoDB 行锁通过 索引 实现：  \n\n若 SQL 条件命中索引（如 WHERE id=1），则锁定对应索引行；  \n若条件无索引（如 WHERE name=&#39;xxx&#39;），则行锁退化为表锁（全表扫描并锁定所有行）。\n\n5、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的作用是什么？\n间隙锁：锁定索引区间的间隙（如 WHERE id BETWEEN 1 AND 10 会锁定(1,10)的间隙），防止其他事务插入新数据，解决幻读；  \n临键锁：间隙锁 + 记录锁（如锁定id&#x3D;5及之前的间隙），是 InnoDB 可重复读（RR） 隔离级别的默认锁算法。\n\n6、什么是 MVCC？它如何与锁机制协同工作？MVCC（多版本并发控制）通过保存数据的多个版本（Undo Log + 隐藏字段 trx_id&#x2F;roll_pointer）实现读并发：  \n\n快照读（普通 SELECT）：基于事务启动时的 Read View 读取历史版本，无需加锁；  \n当前读（SELECT FOR UPDATE&#x2F;UPDATE）：加行锁或间隙锁，确保读取最新数据并阻止并发修改。\n\n7、MySQL 死锁的常见原因是什么？如何排查和解决？\n原因：循环锁等待（如事务A锁表1→等表2，事务B锁表2→等表1）、锁粒度冲突（行锁与表锁）、索引失效导致锁范围过大；  \n排查：SHOW ENGINE INNODB STATUS\\G 查看死锁日志，或查询 performance_schema.innodb_lock_waits；  \n解决：固定锁顺序（如按表名升序加锁）、缩短事务时长、设置锁超时（innodb_lock_wait_timeout）。\n\n8、如何优化数据库锁的性能？\n索引优化：确保 SQL 走索引，避免行锁变表锁；  \n事务优化：缩小事务范围（只包含必要操作）、避免长事务；  \n锁粒度优化：用行锁替代表锁，或用乐观锁（版本号）减少锁竞争；  \n隔离级别优化：读已提交（RC）比可重复读（RR）锁竞争更少（需业务容忍不可重复读）。\n\n9、事务隔离级别如何影响锁的行为？\n读未提交（RU）：无锁，直接读未提交数据（脏读风险）；  \n读已提交（RC）：快照读（MVCC），当前读加行锁（防止脏读，仍有不可重复读&#x2F;幻读）；  \n可重复读（RR）：快照读复用 Read View，当前读加间隙锁&#x2F;临键锁（防止不可重复读，幻读需依赖间隙锁）；  \n串行化（SERIALIZABLE）：所有操作加表锁，事务串行执行（无并发，但最安全）。\n\n10、为什么 InnoDB 的可重复读（RR）能防止幻读？RR 级别通过 MVCC（快照读） + 间隙锁&#x2F;临键锁（当前读） 协同实现：  \n\n快照读：事务内多次查询基于同一 Read View，只能看到事务启动前已提交的数据；  \n当前读：加间隙锁锁定范围，阻止其他事务插入新数据，从而避免幻读。\n\n11、执行 SELECT * FROM table WHERE id=1 FOR UPDATE 时，InnoDB 加了什么锁？答：若 id 是唯一索引，加行锁（Record Lock）；若 id 无索引，加表锁。  \n12、如何避免“修改丢失”问题？答：用排他锁（如 SELECT ... FOR UPDATE）或乐观锁（版本号）：  \n\n悲观锁：BEGIN; SELECT ... FOR UPDATE; UPDATE ...; COMMIT;  \n乐观锁：UPDATE table SET num=num+1, version=version+1 WHERE id=1 AND version=old_version;\n\n13、判断对错并说明理由：\n（1）InnoDB 的行锁一定比表锁性能好。错：行锁加锁开销大，小表全表更新时表锁更高效（如MyISAM表锁）\n（2）只要使用了索引，InnoDB 就会加行锁，不会升级为表锁。错：索引失效（如函数操作索引列）时，行锁会退化为表锁。\n（3）MySQL 的 “可重复读（RR）” 隔离级别完全避免了幻读。对：InnoDB的RR通过间隙锁/临键锁避免幻读，超出了sql标准定义的 RR 能力\n\n14、共享锁（S 锁）和排他锁（X 锁）的兼容规则是什么？举例说明哪些 SQL 操作会自动加这两种锁。\n兼容规则：S锁 和 S 锁兼容，S 锁与 X 锁互斥，X 锁与所有锁互斥\n示例：\nS 锁： select … lock in share mode (共享读锁)\nX 锁： update&#x2F;delete（独占写锁，自动加 X 锁）\n\n\n\n15、间隙锁（Gap Lock）和临键锁（Next-Key Lock）的触发条件是什么？为什么 InnoDB 需要这两种锁？\n触发条件：InnoDB 在 RR 隔离级别下，对索引列的范围查询（如 &gt;、between）触发\n作用：通过锁定索引间隙，阻止新数据插入，解决幻读问题（临键锁是记录锁 和 间隙锁 的组合）。\n\n经典代码案例以下是 MySQL 数据库中经典且常用的代码案例，涵盖表设计、CRUD 操作、事务、索引、存储过程等核心场景，贴近实际开发需求：\n1、表结构设计案例1.1 基础表设计（用户表+订单表，含主键、外键、约束）-- 用户表（基础信息）CREATE TABLE `user` (  `id` INT AUTO_INCREMENT COMMENT &#x27;用户ID（主键）&#x27;,  `username` VARCHAR(50) NOT NULL UNIQUE COMMENT &#x27;用户名（唯一）&#x27;,  `phone` VARCHAR(20) NOT NULL COMMENT &#x27;手机号&#x27;,  `age` TINYINT CHECK (age &gt;= 0 AND age &lt;= 120) COMMENT &#x27;年龄（0-120校验）&#x27;,  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  PRIMARY KEY (`id`),  INDEX idx_phone (`phone`)  -- 手机号索引（加速查询）) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT &#x27;用户信息表&#x27;;-- 订单表（关联用户表，含外键）CREATE TABLE `order` (  `id` BIGINT AUTO_INCREMENT COMMENT &#x27;订单ID&#x27;,  `order_no` VARCHAR(32) NOT NULL UNIQUE COMMENT &#x27;订单编号&#x27;,  `user_id` INT NOT NULL COMMENT &#x27;关联用户ID&#x27;,  `amount` DECIMAL(10,2) NOT NULL COMMENT &#x27;订单金额&#x27;,  `status` TINYINT NOT NULL DEFAULT 0 COMMENT &#x27;状态（0-待支付，1-已支付）&#x27;,  PRIMARY KEY (`id`),  INDEX idx_user_id (`user_id`),  -- 关联查询索引  -- 外键约束（订单必须属于存在的用户）  FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT &#x27;订单表&#x27;;\n\n\n\n2、CRUD 核心操作案例2.1 插入数据（单条+批量）-- 单条插入INSERT INTO `user` (username, phone, age) VALUES (&#x27;zhangsan&#x27;, &#x27;13100001111&#x27;, 25);-- 批量插入（高效，减少IO）INSERT INTO `order` (order_no, user_id, amount, status) VALUES   (&#x27;20231001001&#x27;, 1, 99.99, 0),  (&#x27;20231001002&#x27;, 1, 199.50, 1),  (&#x27;20231001003&#x27;, 2, 299.00, 0);\n\n\n\n2.2 查询数据（基础+关联+聚合）-- 基础查询（带条件+排序）SELECT id, username, age FROM `user` WHERE age BETWEEN 18 AND 30 ORDER BY create_time DESC LIMIT 10;-- 关联查询（用户+订单，统计用户总消费）SELECT   u.id, u.username,   COUNT(o.id) AS order_count,  -- 订单总数  SUM(o.amount) AS total_amount  -- 总消费FROM `user` uLEFT JOIN `order` o ON u.id = o.user_idGROUP BY u.id, u.usernameHAVING total_amount &gt; 0;  -- 筛选有消费的用户\n\n\n\n2.3 更新与删除（带条件+限制）-- 更新（安全更新，带WHERE条件）UPDATE `order` SET status = 1, amount = amount  1.05  -- 支付成功，金额加5%WHERE order_no = &#x27;20231001001&#x27;;-- 删除（逻辑删除，而非物理删除，保留数据）ALTER TABLE `user` ADD COLUMN is_delete TINYINT DEFAULT 0 COMMENT &#x27;是否删除（0-否，1-是）&#x27;;UPDATE `user` SET is_delete = 1 WHERE id = 3;  -- 标记删除\n\n\n\n3、事务与锁案例3.1 事务控制（转账场景，确保原子性）-- 转账：用户1向用户2转100元（需关联账户表）CREATE TABLE `account` (id INT, user_id INT, balance DECIMAL(10,2), PRIMARY KEY(id));BEGIN;  -- 开启事务-- 步骤1：检查转出账户余额SELECT balance FROM `account` WHERE user_id = 1 FOR UPDATE;  -- 加排他锁，防止并发修改-- 步骤2：扣减转出账户UPDATE `account` SET balance = balance - 100 WHERE user_id = 1;-- 步骤3：增加转入账户UPDATE `account` SET balance = balance + 100 WHERE user_id = 2;-- 无异常则提交COMMIT;-- 若出错，回滚（如余额不足）-- ROLLBACK;\n\n\n\n4、索引与性能优化案例4.1 索引设计（联合索引+最左前缀原则）-- 为订单表创建联合索引（优化多条件查询）CREATE INDEX idx_user_status ON `order`(user_id, status);-- 有效利用索引的查询（符合最左前缀）EXPLAIN SELECT  FROM `order` WHERE user_id = 1 AND status = 0;  -- 命中联合索引-- 索引失效的查询（跳过左列）EXPLAIN SELECT  FROM `order` WHERE status = 0;  -- 未使用联合索引（未匹配user_id）\n\n\n\n5、存储过程与触发器案例5.1 存储过程（批量生成测试数据）-- 批量插入N条随机用户数据DELIMITER //CREATE PROCEDURE batch_insert_user(IN n INT)BEGIN  DECLARE i INT DEFAULT 0;  SET autocommit = 0;  -- 关闭自动提交，提升效率  WHILE i &lt; n DO    INSERT INTO `user` (username, phone, age)    VALUES (      CONCAT(&#x27;user_&#x27;, FLOOR(RAND()100000)),  -- 随机用户名      CONCAT(&#x27;131&#x27;, FLOOR(RAND()10000000)),  -- 随机手机号      FLOOR(RAND()80 + 18)  -- 18-98岁随机年龄    );    SET i = i + 1;  END WHILE;  COMMIT;  -- 批量提交  SET autocommit = 1;END //DELIMITER ;-- 调用：插入1000条测试数据CALL batch_insert_user(1000);\n\n5.2 触发器（数据校验+自动维护）-- 插入订单时，自动校验金额必须&gt;0DELIMITER //CREATE TRIGGER check_order_amount BEFORE INSERT ON `order`FOR EACH ROWBEGIN  IF NEW.amount &lt;= 0 THEN    SIGNAL SQLSTATE &#x27;45000&#x27;     SET MESSAGE_TEXT = &#x27;订单金额必须大于0&#x27;;  END IF;END //DELIMITER ;\n\n\n\n6、分页与高级查询案例6.1 分页查询（避免一次性加载大量数据）-- 分页查询第3页数据（每页20条）SELECT id, username, phone FROM `user` WHERE is_delete = 0 ORDER BY create_time DESC LIMIT 40, 20;  -- 偏移量=（页码-1）每页条数\n\n6.2 窗口函数（排名统计，MySQL 8.0+）-- 按用户消费金额排名（降序）SELECT   u.username,  SUM(o.amount) AS total_amount,  RANK() OVER (ORDER BY SUM(o.amount) DESC) AS rnk  -- 排名（相同金额并列）FROM `user` uJOIN `order` o ON u.id = o.user_idGROUP BY u.id, u.username;","categories":["MySQL"],"tags":["MySQL"]},{"title":"MySQl学习笔记(总)","url":"/2025/09/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%80%BB)/","content":"数据库（DataBase）：数据库(简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。\n数据库中存储的基本对象是数据(Data)数据库的基本特点：永久存储、有组织、可共享\n数据库管理系统（DataBase Management System）：DBMS，位于用户与操作系统之间的一层数据管理软件。（是系统软件，是数据库系统的核心）\n主要功能：\n\n数据定义功能\n数据组织、存储和管理\n数据操纵功能（插入、删除、修改和查询）\n数据库的事务管理和运行管理\n数据库的建立和维护功能(实用程序)\n其它功能（异构数据库之间的互访等）\n\n数据库系统（DataBase System）\n数据库系统（DBS）： 计算机系统中引入数据库后的系统构成\n数据库系统的构成：由数据库、数据库管理系统、应用系统、应用开发工具、用户、应用程序员、数据库管理员（Database Administrator，DBA）等组成 。\n\n数据库分类：\n关系型数据库(RDBMS)：关系型数据库，是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n\n特点：\n使用表存储数据，格式统一(行列），便于维护\n使用SQL语句操作，标准统一，使用方便\n数据存储在磁盘中，安全\n\n常见的关系型数据库：mysql、oracle、db2、sql server\n\n应用场景：医疗系统、教育系统、商业系统\n\n\n\n非关系型数据库(NoSQL)：Not-Only SQL ，泛指非关系型数据库，是对关系型数据库的补充。\n\n特点：KEY:VALUE 存储，数据结构灵活、伸缩性强\n\n常见的非关系型数据库：Redis、MongoDB\n\n应用场景：新闻文本信息-MongoDB、电商抢购促销-Redis、微博热点信息-Redis\n\n\n\n\nSQL简述：Structure Query Language(结构化查询语言)简称SQL\nSQL的优点：1、简单易学，具有很强的操作性2、绝大多数重要的数据库管理系统均支持SQL3、高度非过程化；用SQL操作数据库时大部分的工作由DBMS自动完成\nSQL的分类：1、DDL(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP2、DML(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE\n3、DQL(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT\n4、DCL(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT(授权)、revoke(回收)、commit(提交)、roolback(回滚)\n数据库的数据类型使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。\n在 MySQL 中，数据类型决定了字段可以存储的数据种类以及存储方式。合理选择数据类型对于优化数据库性能和节省存储空间至关重要。以下是 MySQL 中主要的数据类型分类及详细介绍：\n1、数值类型1.1 整数类型\n\n\n\n类型\n存储字节\n无符号范围（Unsigned）\n有符号范围（Signed）\n应用场景\n\n\n\nTINYINT\n1 字节\n0 到 255\n-128 到 127\n适合**存储状态值，**如 0&#x2F;1 表示开关\n\n\nSMALLINT\n2 字节\n0 到 65,535\n-32,768 到 32,767\n\n\n\nMEDIUMINT\n3 字节\n0 到 16,777,215\n-8,388,608 到 8,388,607\n\n\n\nINT\n4 字节\n0 到 4,294,967,295\n-2,147,483,648 到 2,147,483,647\n常用整数，适合用户id、数量等\n\n\nBIGINT\n8 字节\n0 到 18,446,744,073,709,551,615\n-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\n适合存储大数值，如订单号\n\n\n特点：\n\n使用 UNSIGNED 关键字可取消负数范围，使正数范围扩大一倍。\n示例：age TINYINT UNSIGNED（适合存储 0-120 的年龄）。\n\n1.2 浮点类型\n\n\n\n类型\n存储字节\n精度\n范围（近似）\n应用场景\n\n\n\nFLOAT\n4 字节\n单精度（7 位小数）\n±3.402823466E+38\n适合不需要极高精度的小数，例如产品评分\n\n\nDOUBLE\n8 字节\n双精度（15 位小数）\n±1.7976931348623157E+308\n用于更精确的计算，如科学数据\n\n\nDECIMAL(M,D)\n可变\n精确小数（M &#x3D; 总位数，D &#x3D; 小数位数）\n取决于 M 和 D 的设置\n用于财务计算，如金额\n\n\n特点：\n\nFLOAT 和 DOUBLE 适用于科学计算，但存在精度损失。\n\nDECIMAL 用于财务计算（如金额），确保精确性。\n\n示例：price DECIMAL(10, 2)（存储 99999999.99 以内的金额）。\n\n\n2、日期和时间类型\n\n\n类型\n存储字节\n格式\n范围\n使用场景\n\n\n\nDATE\n3 字节\nYYYY-MM-DD\n1000-01-01 到 9999-12-31\n存储日期，如生日\n\n\nTIME\n3 字节\nHH:MM:SS\n-838:59:59 到 838:59:59\n存储时间\n\n\nDATETIME\n8 字节\nYYYY-MM-DD HH:MM:SS\n1000-01-01 00:00:00 到 9999-12-31 23:59:59\n存储日期和时间，如订单创建时间\n\n\nTIMESTAMP\n4 字节\nYYYY-MM-DD HH:MM:SS\n1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC\n存储日期和时间，范围小，受时区影响，常用于记录最后修改时间\n\n\nYEAR\n1 字节\nYYYY 或 YY\n1901 到 2155\n存储年\n\n\n特点：\n\nTIMESTAMP 会自动转换为当前时区，且支持 ON UPDATE CURRENT_TIMESTAMP 自动更新。\n\n示例：\n\n\ncreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n\n\n\n3、字符串类型3.1 固定长度字符串\n\nCHAR(M)：固定长度字符串，M 为字符数（1-255），不足 M 时用空格填充。\n\n特点：适合长度固定的数据（如密码哈希、身份证号、性别），访问速度快。\n\n\n3.2 可变长度字符串\n\nVARCHAR(M)：可变长度字符串，M 为最大字符数（1-65,535），实际占用空间为字符串长度 + 1&#x2F;2 字节。\n\n特点：适合长度不固定的数据（如用户名、文章摘要），节省空间。\n\n\n3.3 文本类型\n\n\n\n类型\n最大长度\n存储需求\n使用场景\n\n\n\nTINYTEXT\n255 字符\nL + 1 字节（L &#x3D; 实际长度）\n\n\n\nTEXT\n65,535 字符\nL + 2 字节\n适合文章内容等大段文本\n\n\nMEDIUMTEXT\n16,777,215 字符\nL + 3 字节\n\n\n\nLONGTEXT\n4,294,967,295 字符\nL + 4 字节\n\n\n\n特点：\n\n用于存储大文本（如文章内容、评论），不能有默认值。\n\n3.4 枚举和集合\n\nENUM(&#39;value1&#39;, &#39;value2&#39;, ...)：从预定义值中选择单个值。\n\nSET(&#39;value1&#39;, &#39;value2&#39;, ...)：从预定义值中选择 0 个或多个值。\n\n示例：\n\n\ngender ENUM(&#x27;Male&#x27;, &#x27;Female&#x27;, &#x27;Other&#x27;),hobbies SET(&#x27;Reading&#x27;, &#x27;Music&#x27;, &#x27;Sports&#x27;)\n\n\n\n4、二进制类型\n\n\n类型\n最大长度\n存储需求\n\n\n\nTINYBLOB\n255 字节\nL + 1 字节\n\n\nBLOB\n65,535 字节\nL + 2 字节\n\n\nMEDIUMBLOB\n16,777,215 字节\nL + 3 字节\n\n\nLONGBLOB\n4,294,967,295 字节\nL + 4 字节\n\n\nVARBINARY(M)\n可变长度，最大 M 字节\n实际长度 + 1&#x2F;2 字节\n\n\n特点：\n\n用于存储二进制数据（如图片、文件），但通常建议存储文件路径而非直接存储二进制数据。\n\n5、JSON 类型\nJSON：存储 JSON 格式数据（对象或数组）。\n\n特点：\n\n\n-- 支持 JSON 路径表达式查询（如 `-&gt;` 和 `-&gt;&gt;` 操作符）。-- 示例：user_info JSON,-- 存储 &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;hobbies&quot;: [&quot;Reading&quot;, &quot;Music&quot;]&#125;\n\n\n\n6、空间数据类型\nGEOMETRY：存储几何对象（点、线、多边形等）。\nPOINT、LINESTRING、POLYGON 等：特定几何类型。\n特点：用于地理信息系统（GIS）应用，支持空间索引和函数。\n\n7、选择数据类型的原则\n最小化原则：选择能满足需求的最小数据类型（如年龄用 TINYINT 而非 INT）。\n精度优先：财务数据用 DECIMAL，避免浮点误差。\n避免 TEXT/BLOB：除非必要，否则用 VARCHAR 代替，以提高查询性能。\n一致性：关联字段使用相同的数据类型（如外键与主键）。\n\n数据库、数据表的基本操作DDL 操作DDL： 数据定义语言，操作数据库、数据库表 \n关键字：create、alter、drop\n1、DDL 操作数据库1.1 查询数据库SHOW DATABASES;\n\n1.2 创建数据库IF NOT EXISTS 表示如果数据库不存在就创建\nCREATE DATABASE IF NOT EXISTS test1;\n\n1.3 删除数据库DROP 表示删除的意思\nDROP DATABASE IF EXISTS test1;\n\n1.4 使用数据库USE sc0701;\n\n2、DDL操作表2.1 创建表 create语法：\ncreate table [IF NOT EXISTS] 表名( 字段1  数据类型 [comment 字段注释], 字段2  数据类型 [comment 字段注释], ... 字段n 数据类型 [comment 字段注释])[comment  表注释];\n\n注意：（1）中括号 […]  表示可选参数（2）最后一个字段的定义，末尾不能有逗号\nCREATE TABLE `teacher`( tno INT COMMENT &#x27;教师编号&#x27;, tname VARCHAR(255) COMMENT &#x27;教师名称&#x27;, gender CHAR(2), birthday DATE COMMENT &#x27;教师的生日&#x27;) COMMENT &#x27;教师表&#x27;;\n\n练习UNSIGNED 关键字的作用是去负数范围\nCREATE TABLE IF NOT EXISTS emp(  id INT COMMENT &#x27;员工编号&#x27;,\teno VARCHAR(10) COMMENT &#x27;员工工号&#x27;,\tename  VARCHAR(10),\tgender  CHAR(2),\tage TINYINT UNSIGNED,\tinno CHAR(18),\thirday date)COMMENT &#x27;员工表&#x27;;\n\n2.2 修改表 alter（1）给表添加字段，语法：\nalter table 表名 add 字段名 类型(长度) [comment 注释][约束];\n\n给学生表添加一个 昵称(nickname) 字段， varchar(20)\nALTER TABLE student ADD `nickname` VARCHAR(20) COMMENT &#x27;学生昵称&#x27;;\n\n\n（2）修改表字段的数据类型，语法：\nalter table 表名 modify 字段名 新的数据类型(长度);\n\n扩展语法：修改字段名和字段类型\nalter table 表名 change 旧字段名 新字段名 新的数据类型(长度);\n\n修改 学生表 name 字段的数据类型为 char\nALTER TABLE student MODIFY `name` char(15);\n\n练习：修改学生表， 将 name 字段修改为 username，并且数据类型为 varchar(20)\nALTER TABLE student CHANGE `name` `username` VARCHAR(20);\n\n（3）删除字段，语法：\nalter table 表名 drop 字段名; \n\n删除学生表的 nickname 字段\nALTER TABLE student DROP nickname;\n\n（4）修改表名称，语法：alter table 表名 rename to 新表名;\n将 emp 表 名称修改为 employee 表\nALTER TABLE emp RENAME TO employee;\n\n2.3 删除表：\ndrop（删除表结构）\n\ntruncate（截断表数据）\n\ndelete （删除表数据）\n\n\nDELETE FROM teacher;  -- 清空了表里面的数据，自增的主键列 tno的记录还在\n\nTRUNCATE TABLE teacher; \t-- 清空了表里面的数据，自增的主键列 tno的记录也被清除了，从新开始记录\n\n\n\nDROP TABLE teacher; -- 删除表结构\n\n\n\n\n\nDML 操作DML：数据操作语言，用来对数据库表中的数据（记录）进行增删改操作。\n1、添加数据：insert1.1 给指定的字段添加数据，语法：insert into 表名(字段1, 字段2 ...) values (值1, 值2 ...);\n\n注意：插入数据时，指定的字段顺序和值的顺序一一对应\n给 teacher 表 tname 字段、gender 字段添加数据\nINSERT INTO teacher(tname, gender) VALUES(&#x27;tom&#x27;, &#x27;男&#x27;);\n\n\n\n1.2 给所有字段添加数据，语法：insert into 表名 values (值1, 值2 ...);\n\n注意：（1）没有指定字段时，值的顺序要和数据库表中的字段顺序一致（2）插入日期类型的数据时，可以使用日期格式的字符串插入数据\nINSERT INTO teacher VALUES (null, &#x27;jack&#x27;, &#x27;女&#x27;, &#x27;2025-07-28&#x27;);\n\n\n\n1.3 批量添加数据insert into 表名(字段1, 字段2 ...)   values (值1, 值2 ...), (值1, 值2 ...), (值1, 值2 ...)... ;\n\ninsert into 表名   values (值1, 值2 ...), (值1, 值2 ...), (值1, 值2 ...)...;\n\nINSERT INTO teacher   VALUES   (null, &#x27;rose1&#x27;, &#x27;女&#x27;, &#x27;2025-07-28&#x27;),  (null, &#x27;rose2&#x27;, &#x27;女&#x27;, &#x27;2025-07-28&#x27;),  (null, &#x27;rose3&#x27;, &#x27;女&#x27;, &#x27;2025-07-28&#x27;),  (null, &#x27;rose4&#x27;, &#x27;女&#x27;, &#x27;2025-07-28&#x27;);\n\n\n\n\n\n2、更新数据：update语法：\nupdate 表名 set 字段名1=值1, 字段名2=值2, ... [where 条件]\n\n注意：（1）修改语句的条件 可以有，也可以没有（2）如果没有条件，修改的是整张表中的该字段的所有数据\n修改teacher 表中的 tno &#x3D; 1 的数据行，将 tname 修改为 alex\nUPDATE teacher SET tname=&#x27;alex&#x27; WHERE tno=1;\n\nUPDATE teacher SET tname=&#x27;jock&#x27;;  --  整个表的 tname 字段都会修改为 jock\n\n\n\n3、删除数据：delete语法：\ndelete from 表名 [where 条件];\n\n注意：（1）删除语句可以有条件，也可以没有条件（2）如果没有条件，会删除整张表中的数据\n删除教师表中 tno&#x3D;3 的教师信息\nDELETE FROM teacher WHERE tno=3;DELETE FROM teacher;\n\n\n\nDQL数据查询语言（基础）\n* 表示所有（通配符）&#123;&#125;表示必选项[]表示可选项| 表示 或者 的意思\n\n基础查询语句语法（编写顺序：）：select &#123; * |字段名&#125;\t\t\t--5  from 表名 [AS 表名]\t\t\t-- 1  [where ...]  --条件查询\t\t-- 2  [group by ...] --分组查询\t\t-- 3  [having ...]  --分组条件\t\t--4  [order by ...]  --排序查询\t--6  [limit ...] --分页查询\t\t--7;\n\n1.1  * 匹配所有记录，当数据量特别大的时候，会检索所有数据，不推荐使用SELECT * FROM c_teacher;\n\n1.2根据指定 一列或者多列 查询,多个字段之间使用逗号分隔\nSELECT tname FROM c_teacher;SELECT tno,tname,gender FROM c_teacher;\n\n2、AS 设置别名as子句作用：（1）可以给表和字段取别名（2）也可以给计算结果取别名\nSELECT tno AS &#x27;教师编号&#x27;,tname AS &#x27;教师名称&#x27;,gender AS &quot;教师性别&quot;  FROM c_teacher;\n\n取别名时，as关键字可以省略不写\nSELECT tno &#x27;教师编号&#x27;,tname &#x27;教师名称&#x27;,gender &quot;教师性别&quot;  FROM c_teacher;\n\n2.2 给计算结果取别名SELECT SUM(sal) &#x27;月总工资&#x27; FROM c_teacher;\n\n3、distinct 去重distinct关键字的作用：去除查询返回结果中重复的记录（重复的记录只返回一条）\nSELECT gender FROM c_teacher;SELECT DISTINCT gender FROM c_teacher;\n\n4、运算sql支持四则运算\n查询每个老师的编号，姓名，月薪，年薪（计算）\nSELECT tno,tname,sal &#x27;月薪&#x27;,sal*12 &#x27;年薪&#x27;  FROM c_teacher;\n\n5、连接函数concat(str1,str2, …) 连接字符串和字段\n格式：编号是1，姓名为：赵辉，性别：男\nSELECT CONCAT(&#x27;编号：&#x27;,tno,&#x27;，姓名为：&#x27;,tname,&#x27;，性别：&#x27;,gender)FROM c_teacher;\n\n6、where 条件查询(1) where条件语句：作用是用于检索表中符合条件的记录(2)检索的条件可以由一个或者多个逻辑表达式组成，表达式的结果一般为真或假(3)检索条件的组成：逻辑操作符\t和\t比较操作符比较操作符：&#x3D; &gt; &lt; ≥ &lt;&#x3D; !&#x3D;\n逻辑操作符：and  or not\n特殊的比较操作符：\nbetween\t例如：a between b, 表示范围在a~b之间，就返回真 **[a,b] **is null\t例如：a is null, 表示 a 不是 null,则返回真is not null\t例如：a is not null, 表示 a 不是 null,则返回真like\t例如：a like b,模糊匹配，表示 a 匹配 b,则返回真in\t例如：a in (a, bb, cc),表示 a 等于 (aa, bb, cc)中的一个，就返回真\n--查询：教师表中 名字为 赵辉 的老师所有信息SELECT * FROM c_teacher WHERE tname=&#x27;赵辉&#x27;;-- 练：查询所有男老师的编号、姓名 和 性别SELECT tno,tname,gender FROM c_teacher WHERE gender=&#x27;男&#x27;;-- 练：查询所有薪水大于 20000 的教师 编号、姓名 和 薪水SELECT tno,tname,sal FROM c_teacher WHERE sal&gt;20000;-- 练：查询所有不是 4 号部门的老师编号、姓名 和 部门编号SELECT tno,tname,dno FROM c_teacher WHERE dno!=4;SELECT tno,tname,dno FROM c_teacher WHERE dno&lt;&gt;4;\n\n注意：在 SQL中，NULL值与任何值的比较（包括!&#x3D;)都会返回UNKNOWN, 因此使用dno !&#x3D;4 过滤时, dno为INULL的记录不会被选中。\n如果需要查询出 null 的记录，需要修改条件：\n-- dno 不等于  或者 dno 是 null 的记录都会被筛选出来SELECT tno, tname, dno FROM c_teacher WHERE dno!=4 or dno is null;\n\n6.2 逻辑操作符 and or-- 练：查询 薪水在 10000~20000 之间的老师编号、姓名、薪水信息SELECT tno, tname, sal FROM c_teacher WHERE sal BETWEEN 10000 AND 20000;SELECT tno, tname, sal FROM c_teacher WHERE sal&gt;=10000 AND sal&lt;=20000;SELECT tno, tname, sal FROM c_teacher WHERE sal&gt;=10000 &amp;&amp; sal&lt;=20000;-- 练：查询2号部门 和 3号部门的所有老师编号、姓名、部门编号信息SELECT tno, tname, dno FROM c_teacher WHERE dno=2 OR dno=3;SELECT tno, tname, dno FROM c_teacher WHERE dno=2 || dno=3;SELECT tno, tname, dno FROM c_teacher WHERE dno IN (2, 3);-- 练：查询薪水在5000以下和25000以上的老师师编号、姓名、薪水信息SELECT tno, tname, sal FROM c_teacher WHERE sal&lt;5000 OR sal&gt;25000;-- 练：查询不是 2号 和 5号 部门的老师编号、姓名、部门编号信息SELECT tno, tname, dno FROM c_teacher WHERE dno!=2 AND dno!=5;SELECT tno, tname, dno FROM c_teacher WHERE dno&lt;&gt;2 AND dno&lt;&gt;5;SELECT tno, tname, dno FROM c_teacher WHERE dno NOT IN (2, 5);-- 查询所有没有部门的教师编号、姓名、部门编号信息SELECT tno,tname, dno FROM c_teacher WHERE dno IS NULL;\n\n6.3 like模糊查询模糊查询匹配符号：符号 _ 表示精准匹配1个字符；符号 % 表示模糊匹配0~n个字符；\n-- 查询教师表中 姓陈的老师编号、姓名信息SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;陈_&#x27;;SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;陈%&#x27;;-- 查询名字是 辉 字结尾的老师编号、姓名信息SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;_辉&#x27;;SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;%辉&#x27;;-- 练：查询名字中包含 建 字的老师编号、姓名信息SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;%建%&#x27;;  -- 任意位置SELECT tno, tname FROM c_teacher WHERE tname LIKE &#x27;_建_&#x27;;  -- 在中间位置\n\n\n\n7、聚合函数注意事项：(1)聚合函数在查询时会忽略null值(2)sum和avg只能用于数字类型的计算(3)avg统计的是有数据的记录之和除以有记录的数量例如：6个人有奖金，平均值计算的是6个人的奖金和 &#x2F; 6\n7.1统计记录数 count()-- 查询教师表中有多少条记录SELECT count(*) FROM c_teacher;SELECT count(tname) FROM c_teacher;SELECT count(dno) FROM c_teacher; -- null 值不参与运算\n\n7.2 求\t最大值、最小值、求和、求平均值max() ，min() ，sum() ，avg()\n-- 查询教师表中的最高工资、最低工资、工资总和、平均工资SELECT \tMAX(sal) &#x27;最高工资&#x27;, \tMIN(sal) &#x27;最低工资&#x27;, \tSUM(sal) &#x27;工资总和&#x27;,\tAVG(sal) &#x27;平均工资&#x27;FROM c_teacher;-- 统计奖金平均值SELECT avg(comm) FROM c_teacher;\n\n8、分组查询 group by分组查询：将相同的数据分为一组【注意事项】(1) group by 一般和聚合函数一起使用，单独使用没有意义(2) select 关键字后面只能放 分组的列，也就是说该字段必须是 group by 后面的字段 或者 5个聚合函数(3)当一个sql语句中有 表的某个列 + 聚合函数时，必须使用group by子句\nSELECT * FROM c_teacher GROUP BY dno; --报错，select后面只能跟分组的列SELECT dno FROM c_teacher GROUP BY dno;\t--单独使用没有意义SELECT dno&#x27;部门&#x27;,COUNT(dno)&#x27;人数&#x27; FROM c_teacher GROUP BY dno;\tSELECT dno, COUNT(dno) FROM c_teacher; --列+聚合函数，必须使用group by子句\n\n\n\n--根据部门分组，统计每个部门的人数SELECT dno, COUNT(dno) FROM c_teacher GROUP BY dno; -- 查询字段+聚合函数-- 练：查询有的男老师的工资总和 和 女老师的工资总和SELECT gender, SUM(sal) FROM c_teacher GROUP BY gender;-- 练：查询每个部门的平均工资-- TRUNCATE(m, n)  数值 m 保留 n 位小数SELECT dno, TRUNCATE(avg(sal), 2) FROM c_teacher GROUP BY dno;-- 练：查询不同岗位的记录数、工资和、平均工资SELECT job, COUNT(job), SUM(sal), avg(sal) FROM c_teacher GROUP BY job;\n\n\n\n-- 提升：根据多个字段分组，-- 查询每个部门中不同岗位的记录数、工资和、平均工资SELECT dno, job, COUNT(job), SUM(sal), avg(sal) FROM c_teacher GROUP BY dno, job;SELECT dno, job, COUNT(job), SUM(sal), avg(sal) FROM c_teacher GROUP BY dno, job ORDER BY dno DESC;\n\n\n\n--查询所有男老师的工资总和、人数--不能使用where筛选条件SELECT gender,COUNT(gender),SUM(sal) FROM c_teacher GROUP BY gender WHERE gender=&#x27;男&#x27;; --报错 -- 分组后的筛选条件使用 having 关键字SELECT gender,COUNT(gender),SUM(sal) FROM c_teacher GROUP BY gender HAVING gender=&#x27;男&#x27;;\n\n【面试题】 having 和 where 的区别:(1) having 和 where 都是用来做条件筛选的(2)不同的是:\twhere 是对所有的记录进行筛选， having 是对分组后的记录进行筛选；\twhere 不能放在 group by 子句后面\thaving 是固定和 group by 一起使用，放在 group by 后面，作用相当于 where\twhere 后面不能使用聚合函数, having 可以\n-- 查询平均工资高于 16000 的部门编号、最低工资和平均工资SELECT dno, MIN(sal), AVG(sal) FROM c_teacher GROUP BY dno HAVING avg(sal)&gt;=16000;SELECT * FROM c_teacher WHERE AVG(sal)&gt;=16000;  -- 报错  where 后面不能使用 聚合函数\n\n\n\n9、排序 order byorder by 是将查询结果按照一个或者多个字段进行排序\n\ndesc 降序\nasc  升序（默认值）\n\n-- 查询所有老师信息，按照编号降序排序SELECT * FROM c_teacher ORDER BY tno DESC;-- 查询教师编号、姓名、工资和部门编号，按照部门编号降序、按照工资升序排序SELECT tno, tname, sal, dno FROM c_teacher ORDER BY dno DESC, sal ASC;SELECT tno, tname, sal, dno FROM c_teacher ORDER BY dno DESC, sal;  -- 升序 asc 关键字可以省略-- 练：查询所有教师的编号、姓名、工资，按照工资降序排序-- 练：查询教师表中岗位是 讲师 和 研发的教师信息，按照工资降序排序SELECT * FROM c_teacher WHERE job in (&#x27;讲师&#x27;, &#x27;研发&#x27;) ORDER BY sal DESC; -- 练：查询女老师中姓李的老师编号、姓名、性别、岗位、薪水信息，按照薪水降序排序SELECT tno, tname,  gender, job, salFROM c_teacherWHERE gender=&#x27;女&#x27; AND tname like &#x27;李%&#x27;ORDER BY sal DESC;\n\n\n\n10、limit分页查询limit 起始索引，查询的记录数索引值从0开始起始索引：(页码-1) * 查询记录数如果查询的是 第一页 的数据，起始索引可以省略\n-- 查询教师表， 每页显示5条记录， 查第1页数据SELECT tno, tname FROM c_teacher LIMIT 0, 5;   -- 第1页SELECT tno, tname FROM c_teacher LIMIT 5;     -- 第1页 起始索引可以省略SELECT tno, tname FROM c_teacher LIMIT 5, 5;   -- 第2页SELECT tno, tname FROM c_teacher LIMIT 10, 5;  -- 第3页  起始索引 (3-1)*5SELECT tno, tname FROM c_teacher LIMIT 15, 5;  -- 第3页  起始索引 (4-1)*5SELECT tno, tname FROM c_teacher LIMIT 45, 5;  -- 第10页 起始索引 (10 - 1) * 5\n\n新语法：mysql 8.0+ 语法limit 查询记录数 offset 起始索引 \nSELECT tno,tname FROM c_teacher LIMIT 5 OFFSET 0;\t--第1页SELECT tno,tname FROM c_teacher LIMIT 5 OFFSET 10;\t--第3页-- 练：查询教师表中工资最高的3个老师编号、姓名、工资SELECT tno, tname, sal FROM c_teacher ORDER BY sal DESC LIMIT 3;-- 练：查询教师表中工资排名 6~10 的老师编号、姓名、工资SELECT tno, tname, sal FROM c_teacher ORDER BY sal DESC LIMIT 5 OFFSET 5;\n\n基础查询小结：（1）快速体验 基础查询语句语法（2）取别名：as（3）去重：distinct（4）四则运算（5）where 条件查询\n\n比较运算\n逻辑运算\nlike 模糊查询（6）连接函数（7）聚合函数\n5个聚合函数（8）group by 分组 having（9）order by 排序（10）limit  分页\n\n\n0730\nDCL数据控制语言DCL 主要做两件事情：\n(1)用户管理：创建、修改、删除数据库用户\n(2)权限管理：授予(grant)、回收(revoke)用户对数据库对象(库、表、列)的操作权限\n1、用户管理1.1 创建用户语法：\ncreate user &#x27;用户名&#x27;@&#x27;主机&#x27;\tidentified by &#x27;密码&#x27;;\n\n主机：是指限定用户可连接ip\n创建一个只能登录本机 mysql 数据库的用户，密码为123456\nCREATE USER &#x27;tom&#x27;@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;123456&#x27;;CREATE USER &#x27;tom&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;\n\n1.2 修改用户密码语法：\nalter user &#x27;用户名&#x27;@&#x27;主机&#x27; identified by &#x27;新密码&#x27;;\n\nALTER USER &#x27;tom&#x27;@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;123456&#x27;;\n\n\n\n1.3 删除用户语法：\nDROP USER &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n\n\n2、权限管理(1)增删改查数据的权限：select、insert、update、delete\n(2)表操作权限：create、drop、alter\n(3)其它权限：index（索引权限）、all(所有权限)、grant option(给其它用户授权的权限)\n查看当前登陆的用户所有的权限\nSHOW GRANTS;\n\n查看指定用户的权限\nSHOW GRANTS FOR &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n2.1 授权给用户授予指定数据库下的指定表查询的权限\nGRANT SELECT ON test.c_teacher TO &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n添加其他权限\n指定库下的所有表授予查询权限\nGRANT SELECT ON test.* TO &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n更新的权限\nGRANT UPDATE ON test.* TO &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n\n\n2.2 回收权限回收指定的权限\nREVOKE SELECT ON test.c_teacher FROM &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\nREVOKE UPDATE ON test.c_teacher FROM &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n回收所有的权限\nREVOKE ALL PRIVILEGES ON test.* FROM &#x27;tom&#x27;@&#x27;127.0.0.1&#x27;;\n\n\n\n\n\n常用的函数sql语言中提供了很多内置函数\n分类：1.null 处理函数2.聚合函数3.数学函数4.字符串函数5.日期和时间函数6.流程控制函数\n1. null 值处理函数COALESCE(字段名，value)字段名的值不为null，返回该字段的值字段名的值为null，返回value值\n查询教师表中老师的姓名和奖金SELECT tname,comm FROM c_teacher;查询教师表中老师的姓名和奖金，奖金为null显示0SELECT tname,COALESCE(comm,0) &#x27;奖金&#x27; FROM c_teacher;查询老师的月薪注意：任意值和null进行运算，结果都是nullSELECT tname,sal+comm AS &#x27;月薪&#x27; FROM c_teacher;\n\n将null值处理后再进行计算\nSELECT tname,sal+COALESCE(comm,0) AS &#x27;月薪&#x27; FROM c_teacher;\n\n\n\n2. 聚合函数2.1 常用的5个聚合函数：count,max,min,sum,avg2.2 group _concat()group _concat()是 mysql 的特有聚合函数\n(1)用于将分组内的指定字段值连接成一个字符串返回\n(2)通常与 group by 配合使用\n(3)如果没有使用group by, 会将整张表当成一个分组\n语法：\ngroup _concat([distinct] 要链接的字段 [order by] [separator&#x27;分隔符&#x27;])\n\n默认分隔符逗号\nSELECT dno AS&#x27;部门&#x27;,GROUP_CONCAT(tname)FROM c_teacherGROUP BY dno ;\n\n去重\nSELECT dno AS&#x27;部门&#x27;,GROUP_CONCAT(DISTINCT tname)FROM c_teacherGROUP BY dno ;\n\n指定分隔符\nSELECT dno AS&#x27;部门&#x27;,GROUP_CONCAT(tname SEPARATOR &#x27;-&#x27;)FROM c_teacherGROUP BY dno ;\n\n指定字段排序\nSELECT dno AS&#x27;部门&#x27;,GROUP_CONCAT(tname ORDER BY tname SEPARATOR &#x27;-&#x27;)FROM c_teacherGROUP BY dno ;\n\n注意：不适用 group by 分组，会全表拼接\nSELECT GROUP_CONCAT(tname) FROM c_teacher;\n\n\n\n3、数学函数3.1 PI() 返回pi值SELECT PI();\t-- 3.141593\n\n\n\n3.2 向上取整\tceil()    ceiling()SELECT CEIL(1.1);   --2SELECT CEIL(-1.9);  --1SELECT CEILING(-1.9);   --1\n\n\n\n3.3 向下取整\tfloor()SELECT FLOOR(1.9);  --1\n\n\n\n3.4 返回最大值\tgreatest()SELECT GREATEST(1,6,89,75,23,56);\n\n\n\n3.5 返回最小值\tleast()SELECT LEAST(1,6,89,75,23,56);\n\n\n\n3.6 取模（取余）MOD(x, y)   返回 x &#x2F; y 的余数SELECT MOD(10, 5);SELECT MOD(5, 10);\n\n\n\n3.7 四舍五入\tround()SELECT ROUND(-1.5);  -- -2\n\n\n\n3.8 随机数\trand()  返回 [0,1) 随机数SELECT RAND();\n\n[0,10]之间的随机整数\nSELECT FLOOR(RAND()*11)\n\n公式：\nRAND() * (max_val - min_val + 1) + min_val\n3.9 截断数字TRUNCATE(x,d) 将数字x 保留 d 位小数位返回\nSELECT TRUNCATE(3.141593,2);\n\n不处理的结果：\nSELECT dno,avg(sal) FROM c_teacher GROUP BY dno;\n\n将查询结果数据处理，保留两位小数\nSELECT dno,TRUNCATE(avg(sal),2) as &#x27;平均薪资&#x27; FROM c_teacher GROUP BY dno;\n\n\n\n4、字符串函数4.1 ASCII() 返回字符的 ASCII 码SELECT ASCII(&#x27;A&#x27;);  --65SELECT ASCII(&#x27;a&#x27;);  --97SELECT ASCII(&#x27;中&#x27;);  --228SELECT ASCII(&#x27;国&#x27;);  --229\n\n\n\n4.2 字符串拼接concat(str1,str2, ...)\nSELECT CONCAT(&#x27;Hello&#x27;,&#x27; &#x27;,&#x27;World !&#x27;);\n\n拼接教师编号和姓名，格式：编号-姓名\nSELECT CONCAT(tno,&#x27;-&#x27;,tname) &#x27;基本信息&#x27; FROM c_teacher;\n\n4.3插入替换insert(str, start, length, &#39;newStr&#39;)操作字符串 str,从 start 位置开始，替换 length 个字符，替换为’newStr’这里的start表示第几个字符\nSELECT INSERT(&#x27;万里长城万里长&#x27;,3,2,&#x27;黄河&#x27;);\t\t-- 万里黄河万里长\n\n\n\n4.4 转小写字符lcase 和 lower\nSELECT LCASE(&#x27;aBCdEFg&#x27;);  -- abcdefgSELECT LOWER(&#x27;aBCdEFg&#x27;);  -- abcdefg\n\n\n\n4.4 转大写字符ucase 和 upper\nSELECT UCASE(&#x27;aBCdEFg&#x27;);  -- ABCDEFGSELECT UPPER(&#x27;aBCdEFg&#x27;);  -- ABCDEFG\n\n\n\n4.5 去首尾空格\ttrim()SELECT TRIM(&#x27; AB &#x27;);\n\n\n\n4.7 反转字符串\treverse()SELECT REVERSE(&#x27;上海自来水来自海上！！！&#x27;);\n\n\n\n4.8返回字符串左边指定个数的字符\tleft(str, len)SELECT LEFT(&#x27;今朝有酒今朝醉&#x27;, 3);\t-- 今朝有\n\n查询教师表中所有老师的姓 \nSELECT DISTINCT LEFT(tname,1) AS &#x27;姓氏&#x27; FROM c_teacher;\n\n\n\n4.9 返回字符串的长度\tlength()一个汉字占3个字符\nSELECT LENGTH(&#x27;长城外面是故乡&#x27;);   -- 21SELECT LENGTH(&#x27;hello&#x27;);   -- 5\n\n\n\n4.10 字符串比较\tstrcmp(str1,str2)不区分大小写，比大小str1 &gt; str2返回1str1 &lt; str2str1 &#x3D; str2返回 0\nSELECT STRCMP(&#x27;F&#x27;,&#x27;B&#x27;);\t   -- 1\n\nSELECT STRCMP(&#x27;b&#x27;, &#x27;B&#x27;);\t-- 0\n\n\n\n4.11 返回字符出现的第一次位置position(substr in str)返回substr在str字符串中第一次出现的位置注意：位置指的是第几个字符\nSELECT POSITION(&#x27;长城&#x27; IN &#x27;万里长城万里长，长城外面是故乡&#x27;); -- 3\n\n\n\n4.12 截取字符串substr 和 substringSUBSTR(str FROM pos FOR len)\nSELECT SUBSTR(&#x27;万里长城万里长&#x27;, 2);  -- 从第二个位置截取道末尾   里长城万里长SELECT SUBSTR(&#x27;万里长城万里长&#x27;, 3, 2); -- 从第三个位置截取，截取2个字符\t\t长城SELECT SUBSTRING(&#x27;万里长城万里长&#x27;, 2); SELECT SUBSTRING(&#x27;万里长城万里长&#x27;, 3, 2);\n\n\n\n5、日期和时间函数5.1 返回当前系统时间日期：年月日\nSELECT CURDATE();  -- mysql支持SELECT CURRENT_DATE;  -- sql:标准的时间函数\n\n时间：时分秒\nSELECT CURTIME();SELECT CURRENT_TIME();\n\n年月日+时分秒\nSELECT NOW();\n\n\n\n5.2 格式化时间DATE_FORMAT(时间,格式)通过 % 读取时间:\t\t%Y年 %m月 %d日 %H时 %i分 %s秒\nSELECT DATE_FORMAT(NOW(),&#x27;%Y年%m月%d日 %H时%i分%s秒&#x27;) AS &#x27;时间&#x27;;\n\nH 24小时制， h 12小时制\n5.3 日期和时间计算加法运算\ndate_add(date, interval expr unit)在date的基础上加指定时间\nSELECT DATE_ADD(CURRENT_DATE(),INTERVAL 3 DAY); -- 在当前系统时间+3天SELECT DATE_ADD(CURRENT_DATE(),INTERVAL 2 DAY); -- 在当前系统时间+2月\n\n减法运算date_sub(date, interval expr unit)在date的基础上减指定时间\nSELECT DATE_SUB(NOW(),INTERVAL 1 MONTH) -- 减一个月\n\n\n\n计算时间差（天数差）datediff(date1,date2);  计算两个日期的天数差\nSELECT DATEDIFF(NOW(),&#x27;2003-01-01&#x27;) AS &#x27;天数&#x27;;  -- 8246\n\n\n\n指定单位差timestampdiff(unit,date1,date2) 根据指定单位计算日期差\nSELECT TIMESTAMPDIFF(YEAR,NOW(),&#x27;2003-01-01&#x27;);  -- -22SELECT TIMESTAMPDIFF(DAY, NOW(),&#x27;1987-05-06&#x27;);SELECT TIMESTAMPDIFF(YEAR, NOW(),&#x27;1987-05-06&#x27;);SELECT TIMESTAMPDIFF(MONTH, NOW(),&#x27;1987-05-06&#x27;);\n\n\n\n5.4 获取日期和时间部分获取年份\nSELECT YEAR(now());\n\n获取月份\nSELECT MONTH(&#x27;2003-11-11&#x27;);\n\n获取日\nSELECT DAY(&#x27;2003-11-11&#x27;);\n\n获取一周的第几天\n​\t\t星期日为第一天\nSELECT DAYOFWEEK(NOW());  -- 4 \t星期日为第一天\n\n获取时间戳时间戳指的是 指定时间 距离 1970-01-01 00:00:00 的毫秒数1s &#x3D; 1000 ms\nSELECT UNIX_TIMESTAMP(); -- 获取当前系统时间的时间戳SELECT UNIX_TIMESTAMP(&#x27;1970-01-02&#x27;); -- 根据指定时间格式的字符串获取时间戳SELECT FROM_UNIXTIME(1753865651); -- 将时间戳转换为日期\n\n\n\n\n5.5 获取指定日期月份的最后一天LAST_DAY(date)\nSELECT LAST_DAY(&#x27;2025-07-01&#x27;);  -- 2025-07-31SELECT LAST_DAY(NOW());\n\n获取指定月份的 倒数第二天的 （获取日）\nSELECT DAY(LAST_DAY(NOW()) - INTERVAL 1 DAY);SELECT DAY(LAST_DAY(&#x27;2025-02-01&#x27;) - INTERVAL 1 DAY);  -- 27\n\n\n\n6、流程函数6.1 三元运算if(value,t,f) 条件判断，value值为真，返回 t ，否则返回 f\nSELECT tno,tname, IF(gender=&#x27;男&#x27;,&#x27;先生&#x27;,&#x27;女生&#x27;)FROM c_teacher;\n\n6.2 null 值处理IFNULL(value1,value2) 如果value1 非 null，返回value1，否则返回value2 \nSELECT tno,tname,IFNULL(dno,&#x27;无部门&#x27;) AS &#x27;部门编号&#x27; FROM c_teacher; \n\n\n\n6.3 多条件分支语法：case  when [val1] then [result1]  when [val2] then [result2]  ......else [default]end;\nSELECT tno,tname,CASE \tWHEN dno=1 THEN &#x27;人力部&#x27;\tWHEN dno=2 THEN &#x27;产品部&#x27;\tWHEN dno=3 THEN &#x27;招生部&#x27;\tELSE  &#x27;其他部门&#x27;\tEND AS &#x27;部门&#x27;FROM c_teacher ORDER BY dno;\n\n\n\n\n6.4 等值判断语法：case value  when value1 then res1  when value2 then res2  when value3 then res3  else dafaultend;\nSELECT CASE DAYOFWEEK(now())-1    WHEN 1 THEN &#x27;星期一&#x27;    WHEN 2 THEN &#x27;星期二&#x27;    WHEN 3 THEN &#x27;星期三&#x27;    WHEN 4 THEN &#x27;星期四&#x27;    WHEN 5 THEN &#x27;星期五&#x27;    WHEN 5 THEN &#x27;星期六&#x27;\tELSE &#x27;星期天&#x27;END AS &#x27;星期&#x27;;\n\nSELECT tno,tname,CASE dno\tWHEN 1 THEN &#x27;人力部&#x27;\tWHEN 2 THEN &#x27;产品部&#x27;\tWHEN 3 THEN &#x27;招生部&#x27;\tELSE  &#x27;其他部门&#x27;\tEND AS &#x27;部门&#x27;FROM c_teacher ORDER BY dno;\n\n\n\n函数知识点小结  1、null值处理函数: COALESCE()  2、聚合函数，拓展一个 mysql 的聚合函数 group_concat  3、数学函数 \nrand() 、TRUNCATE()、floor()、ceil()\n4、字符串函数\nconcate()、trim()、substr()、lower() 和 upper()5、日期函数\nCURRENT_DATE()、CURRENT_TIME()\nNOW()、DATE_FORMAT()\nDATE_ADD()、DATE_SUB()、DATEDIFF()、TIMESTAMPDIFF()\nYEAR()、MONTH()、DAY()\nDAYOFWEEK()、LAST_DAY()6、流程控制函数\nif()、ifnull()、case when 、case value when \n数据库表约束1、概念：约束是作用于作用域中字段上的规则，用于限制存储在表中的数据目的：保证数据库中数据的正确，有效性和完整性\n2、约束的分类\n(1)主键约束(primary key):当前字段是数据的唯一标识符，唯一且不能为空(2)外键约束(foreign key): 用来让两张表的数据之间建立连接，保证数据的一致性和完整性(当前表的外键是另一张表的主键)(3)非空约束(not null): 限制当前字段的数据不能为null(4)唯一约束(unique): 保证该字段的所有数据都是唯一、不重复，可以为null(5)检查约束(check): 保证字段的值满足某一个(男&#x2F;女)(6)默认值约束(default): 保存数据时,如果没有指定该字段的值,则采用默认值(入职时间,岗位)\n注意: 在sql中 null 和任何值都不相等,包括null 本身和 null 也不相等\n1、主键约束(PRIMARY KEY)1.1 创建表的时候，指定主键CREATE TABLE stu01(-- `id` INT PRIMARY KEY, -- 在声明字段时标注当前字段是主键`id` INT PRIMARY KEY auto_increment,-- `id` INT,`name` VARCHAR(50)--  PRIMARY KEY(id) -- 字段创建完成后，指定主键字段);\n\n1.2、通过 alter 语法添加主键CREATE TABLE stu02(`id` INT,`name` VARCHAR(50));-- ALTER TABLE stu02 ADD PRIMARY KEY(id); -- 指定表中的 id 字段为主键ALTER TABLE stu02 MODIFY COLUMN id INT PRIMARY KEY auto_increment; -- 设置主键，且主键自增\n\n1.3、删除主键约束ALTER TABLE stu02 DROP PRIMARY KEY;\n\n2、非空约束(NOT NULL)2.1 建表的时候定义字段非空约束CREATE TABLE stu03(`id` INT,`name` VARCHAR(50) NOT NULL, -- 创建字段时 定义为 not null`password`VARCHAR(50));\n\n2.2 alter语法修改字段非空约束ALTER TABLE stu03 MODIFY `password`VARCHAR(50) NOT NULL;\n\n3、检查约束(CHECK)3.1 建表时添加 检查字段 checkCREATE TABLE stu04(`id` INT PRIMARY KEY auto_increment,`name` VARCHAR(50), `age` INT,`gender` CHAR(2) CHECK (gender in(&#x27;男&#x27;,&#x27;女&#x27;)) -- 检查约束);INSERT INTO stu04 (name,gender) VALUES(&#x27;frank&#x27;,&#x27;妖怪&#x27;); -- 添加失败，不符合约束INSERT INTO stu04 (name,gender) VALUES(&#x27;frank&#x27;,&#x27;男&#x27;); -- 可以添加\n\n3.2 通过alter 语法添加 检查约束ALTER TABLE stu04 ADD CONSTRAINT ck_stu04_age CHECK (age &gt;=18 AND age &lt;=120);INSERT INTO stu04 (name,,age,gender) VALUES(&#x27;frank&#x27;,15,&#x27;男&#x27;); -- 年龄不符合检查约束INSERT INTO stu04 (name,age,gender) VALUES(&#x27;jack&#x27;,25,&#x27;男&#x27;); \n\n4、唯一约束（UNIQUE）4.1 建表时添加 唯一约束CREATE TABLE stu05(`id` INT PRIMARY KEY auto_increment,`name` VARCHAR(50), `age` INT,`card_number` CHAR(18) UNIQUE  -- 唯一约束);INSERT INTO stu05 (name,card_number) VALUES(&#x27;tom&#x27;,&#x27;362326202507311234&#x27;); INSERT INTO stu05 (name,card_number) VALUES(&#x27;jack&#x27;,&#x27;362326202507311234&#x27;); -- 失败，重复的值不能添加INSERT INTO stu05 (name,card_number) VALUES(&#x27;rose&#x27;,null); -- 可以添加nullINSERT INTO stu05 (name,card_number) VALUES(&#x27;alex&#x27;,null); -- null 可以重复添加\n\n4.2 alter 语法添加唯一约束ALTER TABLE stu05 ADD CONSTRAINT uk_stu05_name UNIQUE (name);INSERT INTO stu05 (name) VALUES (&#x27;rose&#x27;); -- 失败，重复的名字不能新增\n\n5、默认值约束(DEFAULT)5.1 建表时 指定默认值CREATE TABLE stu06(`id` INT PRIMARY KEY auto_increment,`name` VARCHAR(50), `age` INT,`gender` VARCHAR(10) DEFAULT &#x27;male&#x27; -- 默认值约束);INSERT INTO stu06 (name) VALUES (&#x27;rose&#x27;); SELECT * FROM stu06;\n\n5.2 alter 语法设置默认值ALTER TABLE stu06 MODIFY `name` VARCHAR(50) DEFAULT &#x27;user&#x27;;\n\n6、外键约束(FOREIGN KEY)外键是用来让两张表的数据建立连接保证数据的一致性和完整性 创建时表指定外键\nCREATE TABLE 表名(字段名 类型,...[CONSTRAINT][外键名称] FOREIGN KEY (外键的字段名) REFERENCES 主表 (主表字段名)-- 例如：constraint fk_teacher_dno foreign key (dno) references dept (dno));\n\n 使用ALTER 语法\n--  alter table 表名 add constraint 外键名称 foreign key (外键的字段名) references 主表 (主表字段名)-- 将 c_teacher 表的 dno 字段 与 c_dept 表使用外键约束关联alter table c_teacher add constraint fk_teacher_dno foreign key (dno) references c_dept (dno); \n\n 注意：一旦建立了外键约束，不能随意删除主表数据\n1、子查询子查询：在查询语句的 select、from、where、having关键字的后面，都可以包含另外的查询语句外层查询：主查询内层查询：子查询执行顺序：一般是先执行子查询，然后将子查询的结果带入到主查询中，得出最终的结果\n1.1单行子查询：返回一条结果查询教师表中\t工资比\t秦占豪\t高的老师信息\nSELECT tname, sal FROM c_teacher WHERE tname=&#x27;秦占豪&#x27;;\t-- 31564.79SELECT tname, sal FROM  c_teacher WHERE sal&gt;31564.79;\n\n子查询\nSELECT * FROM c_teacherWHERE sal&gt;(  SELECT sal  FROM c_teacher  WHERE tname = &#x27;秦占豪&#x27;);\n\n练：查询招生部所有男老师的姓名\n--先查询出招生部的编号SELECT dno FROM c_dept WHERE dname=&#x27;招生部&#x27;; -- 3--再根据编号出该部门编号的所有老师，筛选出男老师SELECT tname, gender, dno FROM c_teacherWHERE dno=(SELECT dno FROM c_dept WHERE dname=&#x27;招生部&#x27;) AND gender=&#x27;男&#x27;;\n\n\n\n给表取别名\nSELECT t.tname,t.gender,t.dnoFROM c_teacher AS tWHERE t.dno=(SELECT d.dno FROM c_dept d WHERE d.dname=&#x27;招生部&#x27;) AND gender=&#x27;男&#x27;;\n\n\n\n\n1.2 多行子查询，查询返回多条记录in : 条件满足列表中的一个即可，例如：a in(x,y,z),a等于其中一个即可any : 和子查询中返回的任意一个值比较，例如 a &gt; any(100,200,300) ，a大于最小的即可all : 和子查询和子查询中返回所有值比较，例如 a &gt; all(100,200,300)，a大于最大的即可\n需求：查询出地址时北京海淀的所有老师信息 \n--先查询出所有地址是北京海淀的 部门编号SELECT dno FROM c_dept WHERE loc=&#x27;北京海淀&#x27;; -- 1 2 4--再根据部门编号查询出符合条件的所有老师SELECT tname,dno FROM c_teacher WHERE dno in(1,2,4);\n\n子查询\nSELECT t.tname,t.dno FROM c_teacher t WHERE t.dno in(SELECT d.dno FROM c_dept d WHERE d.loc=&#x27;北京海淀&#x27;);\n\n练习：练：查询工资比1号部门任意一个教师工资高的老师编号、姓名和工资信息\nSELECT tno,tname,sal FROM c_teacher;SELECT dno,dname FROM c_dept WHERE dno=1;SELECT t.tno,t.tname,t.sal FROM c_teacher tWHERE sal &gt;ANY(  SELECT sal   FROM c_teacher   WHERE dno=1);\n\n练：查询工资比2号部门所有老师工资都高的老师编号、姓名和工资信息\nSELECT t.tno,t.tname,t.sal FROM c_teacher tWHERE t.sal &gt; ALL(  SELECT sal  FROM c_teacher   WHERE dno=2);\n\n练：查询有 营销专员 的部门中所有教师编号、姓名、部门编号和岗位信息\nSELECT t.tno,t.tname,t.dno,t.job FROM c_teacher tWHERE dno IN (SELECT dno FROM &#x27;营销专员&#x27; );\n\n练：所有在人力部、招生部的教师编号、姓名、部门编号信息\nSELECT t.tno,t.tname,t.dno FROM c_teacher tWHERE t.dno IN (  SELECT dno   FROM c_dept   WHERE dname IN(&#x27;人力部&#x27;,&#x27;招生部&#x27;));\n\n练：所有老师的姓名和该老师的部门名称\nSELECT t.tname,COALESCE( (SELECT dname FROM c_dept d WHERE t.dno=d.dno -- teacher表和dept表相匹配的数据), &#x27;混吃等死部门&#x27;)FROM c_teacher t;\n\n\n\n1.3  EXISTS 和 NOT EXISTS用于判断子查询是否返回结果的逻辑运算符、\n核心解决“是否存在满足条件的记录”的问题\nEXISTS ：检查子查询是否 至少返回一条数据（只要有结果，立即返回）\nNOT EXISTS：检查子查询是否 返回0行数据（只有无结果时，才返回true）\n查询有部门的老师信息\nSELECT tno,tname,dno FROM c_teacher tWHERE EXISTS (\t SELECT * FROM c_dept d\t WHERE t.dno=d.dno -- 关联部门表);\n\n没有部门的老师信息\nSELECT tno, tname, dno FROM c_teacher tWHERE NOT EXISTS (SELECT * FROM c_dept dWHERE t.dno = d.dno --关联部门表);\n\n\n\n2、多表连接查询连接查询：使用一张以上的表根据指定条件查询多表连接：用一张主表作为结果集，将其他表的记录 有选择的连接在主表的结果集上常见的连接查询：内连接、外连接、自连接和交叉连接（笛卡尔积）\n2.1 外连接左外连接 和 右外连接（1）左外连接：从左表（表1）中返回所有记录，即便右表（表2）中没有匹配的行语法：SELECT 字段1,字段2,… FROM 表1 LEFT JOIN 表2 ON 连接条件\n（2）右外连接：从右表（表1）中返回所有记录，即便左表（表2）中没有匹配的行语法：\nSELECT 字段1,字段2,... FROM 表2 RIGHT JOIN 表1 ON 连接条件\n\n查询所有老师的信息和该老师的部门名称\nSELECT t.*, d.dname FROM c_teacher t LEFT JOIN c_dept d ON t.dno=d.dno; SELECT *FROM c_teacher t RIGHT JOIN c_dept d ON t.dno=d.dno; \n\n练：查询工作地点在北京海淀的老师信息\nSELECT d.loc,t.*FROM c_teacher t LEFT JOIN c_dept d ON t.dno=d.dnoWHERE d.loc=&#x27;北京海淀&#x27;; \n\n练：查询薪水等级(c_salgrade)为4的教师编号、姓名、薪水等级和薪水所在区间\nSELECT t.tno,t.tname,g.grade FROM c_teacher t LEFT JOIN c_salgrade gON t.sal BETWEEN g.losal AND g.hisalWHERE g.grade=4;\n\n\n\n2.2 内连接两张表的记录满足条件，两张表的记录合并成一条记录，返回到结果集\n注意 :内连接：返回所有满足条件的数据，不满足条件的数据不返回外连接：返回主表的所有记录，满足条件的就连接到主表，不满足条件的返回null语法：\nSELECT 字段1,字段2,... FROM 表1 [INNER] JOIN 表2 ON 连接条件\n\n查询所有  有部门的（非空） 老师的信息和该老师的部门名称\nSELECT t.tno,t.tname,t.dno,d.dnameFROM c_teacher t INNER JOIN c_dept dON t.dno=d.dno; -- INNER 可省略\n\n练：查询教师编号、姓名、薪水、薪水等级\nSELECT t.tno,t.tname,t.sal,g.gradeFROM c_teacher t INNER JOIN c_salgrade gON sal BETWEEN g.losal AND g.hisal;\n\n练：查询薪水等级为4的教师编号、姓名、薪水等级和薪水所在区间\nSELECT t.tno,t.tname,t.sal,g.gradeFROM c_teacher t INNER JOIN c_salgrade gON sal BETWEEN g.losal AND g.hisalWHERE g.grade=4;\n\n\n\n2.3  自连接概念：数据表与自身进行连接\n查询所有老师姓名和对应的导师姓名\nSELECT t1.tno &#x27;老师编号&#x27;,t1.tname &#x27;老师姓名&#x27;,t2.tno &#x27;导师编号&#x27;,t2.tname &#x27;导师姓名&#x27;FROM c_teacher t1 LEFT JOIN c_teacher t2ON t1.mgrno=t2.tno;\n\n查询分类表 t_category查询父类别名称和 其对应的子类别名称\nSELECT c1.categoryName &#x27;父类别名称&#x27;,c2.categoryName &#x27;子类别名称&#x27;FROM t_category c1 INNER JOIN t_category c2ON c1.categoryid=c2.pid;\n\n\n\n2.4 交叉链接（笛卡尔积）交叉连接 会产生笛卡尔积（结果是两个表的记录数相乘）\nSELECT count(*) FROM c_teacher,c_dept; -- 539\n\n\n\n2.5 联合查询两个操作符：（1）union all ：将 两个查询结果合并成一个结果集，不会去重（2）union ：将 两个查询结果合并成一个结果集，会去重（重复的记录只保留一条）\n查询1 6 66 号老师查询1 7 号老师UNION去重：\nSELECT tno,tname FROM c_teacher WHERE tno IN(1,6,66)UNION SELECT tno,tname FROM c_teacher WHERE tno IN(1,7);\t\t-- 4条数据\n\nUNION ALL不去重：\nSELECT tno,tname FROM c_teacher WHERE tno IN(1,6,66)UNION ALLSELECT tno,tname FROM c_teacher WHERE tno IN(1,7);\t\t-- 5条数据\n\n\n\n08-视图1.视图(view)：​\t是mysql中一种虚拟表，他是基于sql查询语句的结果生成的一张不存在的表\n2.作用：\n\n(1)简化复杂查询：封装常用的查询逻辑，使sql更易理解和维护\n(2)数据安全：通过视图控制用户对敏感数据的访问权限\n(3)逻辑隔离：屏蔽底层表结构变化，提供统一的数据接口\n总的来说，视图可以简化复杂查询，增强数据的安全性和逻辑性\n\n\n3.创建视图的语法：\ncreate [or replace] view 视图名称 as select 语句说明： or replace 表示视图如果存在，则替换原来的视图\n\n1.基本用法1.1 创建视图CREATE VIEW view_teacherASSELECT tno, tname, job, sal FROM c_teacher;CREATE VIEW view_teacher_deptASSELECT tno, tname, job, sal FROM c_teacher;\n\n\n\n1.2 使用视图SELECT * FROM view_teacher;SELECT * FROM view_teacher_dept;\n\n\n\n创建视图：查询所有教师基本信息和所在的部门名称、部门地址信息\nCREATE OR REPLACE VIEW view_teacher_dept2 ASSELECT t.tno,t.tname,t.dno,d.dname,d.loc FROM c_teacher t LEFT JOIN c_dept d ON t.dno=d.dnoSELECT * FROM view_teacher_dept2;\n\n\n\n2. 可以更新视图：是指通过修改视图的字段，修改基表可以通过视图修改基表数据需要满足以下条件：\n\n\n(1)视图定义中只包含一个基表\n(2)视图中包含基表的主键或唯一键\n(3)视图中没有包含 **聚合函数 ** 和 **distinct 关键字 **\n\n\nCREATE OR REPLACE VIEW v_emp_sal ASSELECT empno,ename,job,sal FROM t_emp;SELECT * FROM v_emp_sal;\n\nv_emp_sal 视图符合修改基表数据的三个条件– 修改7369号员工的薪资（涨薪20%）\nUPDATE v_emp_sal SET sal=sal*1.2 WHERE empno=7369; SELECT * FROM v_emp_sal;\n\n\n\n3. 修改视图3.1 覆盖原来的视图CREATE OR REPLACE VIEW v_emp_sal ASSELECT empno,ename,job,sal,comm FROM t_emp;\n\n\n\n3.2 ALTER修改原来的视图ALTER VIEW v_emp_sal ASSELECT empno,ename,job,sal FROM t_emp;\n\n\n\n4. 删除视图DROP VIEW IF EXISTS v_emp_sal;\n\n\n\n09-存储过程存储过程：(1)是什么：存储过程是一组可编程的函数，是为了完成特定功能的sql语句集，经过编译创建并保存在数据库中，用户可以通过指定存储过程的名字调用执行。（相当于java中类的方法）\n简单来说：存储过程是用来封装 一段sql逻辑供开发者重复调用，类似java中的方法\n(2)优点：\n(1)存储过程是预编译的代码块，执行效率高(2)存储过程在服务器端运行，减少客户端压力(3)存储过程只需要创建一次，可以重复使用(4)存储过程代替大量的SQL语句，提高通信效率(5)可以一定程度上确保数据安全\n\n缺点：调试麻烦  可移植性低\n(3)语法：创建存储过程：create procedure 存储过程名称(参数 参数类型)begin  -- 逻辑代码(sql语句集)end;\n调用存储过程：call 存储过程名称(参数);\n1、存储过程的使用1.1创建一个查询所有教师的存储过程CREATE PROCEDURE pro_get_teacher()BEGIN  -- 查询所有教师  SELECT * FROM c_teacher;  END;\n\n\n\n1.2 调用存储过程CALL pro_get_teacher(); \n\n\n\n1.3 查看存储过程查看所有存储过程\nSHOW PROCEDURE STATUS;\n\n搜索指定存储过程\nSHOW PROCEDURE STATUS LIKE &#x27;%teacher%&#x27;;\n\n查看存储过程的定义\nSHOW CREATE PROCEDURE pro_get_teacher;\n\n查看某个数据库下的所有存储过程\nSHOW PROCEDURE STATUS WHERE db=&#x27;sys&#x27;;\n\n\n\n1.4 删除存储过程DROP PROCEDURE IF EXISTS pro_get_teacher;\n\n\n\n2. mysql的变量2.1 系统变量系统变量是指 mysql服务器运行时，控制其行为的参数，\n这些变量可以被设置为特定的值来改变服务器的默认设置。\n分类：(1)全局(global)作用域的系统变量：所有连接和所有数据库都能使用(2)会话(session)级别的系统变量：当前连接和当前数据库使用\n查看系统变量\nSHOW GLOBAL variables;SHOW SESSION variables;UPDATE c_dept SET dname=&#x27;后勤3部&#x27; where dno=7; COMMIT;\n\n查看指定名称的变量： SELECT @@系统变量名;\nSELECT @autocommit;set @@autocommit=0; -- 表示关闭自动提交set @@autocommit=1; -- 表示开启自动提交SELECT @@admin_port;\n\n\n\n2.2 用户变量用户自定义的变量，只在当前会话有效，所有用户变量使用 @ 开头\nSET @username=&#x27;tom&#x27;; -- 定义了一个用户变量SELECT @username; SET @age :=30; -- 初始化一个用户变量SELECT @age;\n\n动态赋值\n将查询的结果赋值(into)给变量 @sex\nSELECT gender INTO @sex FROM c_teacher WHERE tno=1;SELECT @sex;\n\n\n\n2.3 局部变量在存储过程内部声明的变量语法：DECLARE 变量名 数据类型 [DEFAULT ...]\n声明一个查询教师表总工资的存储过程DROP PROCEDURE IF EXISTS get_teacher_sal_sum;CREATE PROCEDURE get_teacher_sal_sum() BEGIN  -- 声明一个局部变量  DECLARE salsum INT DEFAULT 0;  -- 给变量赋值  SELECT SUM(sal) INTO salsum FROM c_teacher;  -- 查询结果  SELECT salsum;END;\n\n-- 调用CALL get_teacher_sal_sum();-- 验证SELECT SUM(sal) FROM c_teacher;\n\n3. IF语句语法：IF 条件 THEN ...;   ELSEIF 条件 THEN ...;   ELSEIF 条件 THEN ...;   ELSEIF 条件 THEN ...;   ELSE ...; END IF;\n需求：判断 1 号教师的薪资等级DROP PROCEDURE IF EXISTS get_sal_rank;CREATE PROCEDURE get_sal_rank()BEGIN  DECLARE `rank` VARCHAR(20) DEFAULT &#x27;null&#x27;;  DECLARE `salvalue` INT DEFAULT 0;\t  SELECT sal INTO `salvalue` FROM c_teacher WHERE tid = 1;    IF salvalue &gt;=16000 THEN SET `rank` :=&#x27;高收入&#x27;;    ELSEIF salvalue&gt;=8000 THEN SET `rank` :=&#x27;中收入&#x27;;    ELSEIF salvalue&gt;=4000 THEN SET `rank` :=&#x27;低收入&#x27;;    ELSE SET `rank` :=&#x27;贫困收入&#x27;;  END IF;  SELECT `rank`;END;-- 调用CALL get_sal_rank();\n\n\n\n4. 参数\n存储过程的参数有三种IN : 入参OUT ：出参INOUT : 既是入参，也是出参\n\n需求：给定任意一个教师编号，判断他的薪资等级DROP PROCEDURE IF EXISTS get_rank_tno;CREATE PROCEDURE get_rank_tno(IN v_tno INT)BEGIN  DECLARE `rank` VARCHAR(20) DEFAULT &#x27;null&#x27;;  DECLARE `salvalue` INT DEFAULT 0;  SELECT sal INTO `salvalue` FROM c_teacher WHERE tno = v_tno;  IF salvalue &gt;=16000 THEN SET `rank` :=&#x27;高收入&#x27;;    ELSEIF salvalue&gt;=8000 THEN SET `rank` :=&#x27;中收入&#x27;;    ELSEIF salvalue&gt;=4000 THEN SET `rank` :=&#x27;低收入&#x27;;    ELSE SET `rank` :=&#x27;贫困收入&#x27;;  END IF;  SELECT `rank`;END;CALL get_rank_tno(2);CALL get_rank_tno(1);\n\n\n\n5. CASE WHEN 语法需求：输出指定 tno 教师的教师的部门名称– 例如1号教师的部门编号为4，则输出 研究院– 例如3号教师的部门编号为2，则输出 产品部\nDROP PROCEDURE IF EXISTS print_teacher_dname;CREATE PROCEDURE print_teacher_dname(IN v_tno INT, OUT v_dname VARCHAR(50))BEGIN  DECLARE v_dno INT DEFAULT 0;  -- 查询出教师的部门编号  SELECT dno INTO v_dno FROM c_teacher WHERE tno=v_tno;  -- 根据部门编号匹配部门名称  CASE v_dno    WHEN 1 THEN SET v_dname :=&#x27;人力部&#x27;;    WHEN 2 THEN SET v_dname :=&#x27;产品部&#x27;;    WHEN 3 THEN SET v_dname :=&#x27;招生部&#x27;;    WHEN 4 THEN SET v_dname :=&#x27;研究院&#x27;;    WHEN 5 THEN SET v_dname :=&#x27;系统部&#x27;;    ELSE SET v_dname :=&#x27;其他部门&#x27;;  END CASE;END;SET @teadname := &#x27;&#x27;;CALL print_teacher_dname(1,@teadname);SELECT @teadname; -- 1号老师部门编号为4，输出 研究院CALL print_teacher_dname(3,@teadname);SELECT @teadname; -- 3号老师部门编号为2，输出 产品部\n\n\n\n需求：涨薪10%DROP PROCEDURE IF EXISTS add_sal;CREATE PROCEDURE add_sal(INOUT salvalue INT)BEGIN  SET salvalue := salvalue*1.1;END;SET @salval =1000;CALL add_sal(@salval);SELECT @salval;\n\n\n\n6. 循环6.1 while循环语法：WHILE 条件 DO 循环体END WHILE;\n需求：传入一个值n，求1~n之间偶数和DROP PROCEDURE IF EXISTS get_enen_sum;CREATE PROCEDURE get_enen_sum(IN n INT)BEGIN\t-- 声明变量接收和\tDECLARE v_sum INT DEFAULT 0;\t-- 循环计算偶数和WHILE n&gt;1 DO\tIF n%2=0 THEN \t\tSET v_sum := v_sum+n;\tEND IF;\t\tSET n := n-1;\tEND WHILE;SELECT v_sum;END;CALL get_enen_sum(100); -- 2550\n\n\n\n6.2 repeat循环语法：REPEAT 循环体``;\tUNTIL 结束条件END REPEAT;注意：until语句后面不加分号\n需求：传入一个值n，求1~n之间奇数和DROP PROCEDURE IF EXISTS get_odd_sum;CREATE PROCEDURE get_odd_sum(IN n INT)BEGIN \tDECLARE v_sum INT DEFAULT 0;\tREPEAT\tIF n%2 !=0 THEN SET v_sum := v_sum+n;\tEND IF;\t\tSET n := n-1;\t\tUNTIL n &lt; 1 -- 退出循环的条件\tEND REPEAT;SELECT v_sum;END;CALL get_odd_sum(100);\n\n\n\n6.3 loop循环\nleave：类似break\niterate：类似continue\n\n需求：获取 i 的值DROP PROCEDURE IF EXISTS get_i;CREATE PROCEDURE get_i()BEGIN\tDECLARE i INT DEFAULT 0; -- 初始化i值为0\tlabel: LOOP\tSET i := i+1;\tIF i = 5 THEN\t\tLEAVE label; \t-- 结束循环,leave相当于break\tEND IF; END LOOP label;SELECT i;END;CALL get_i(); -- 5\n\n获取 i 的值DROP PROCEDURE IF EXISTS get_ii;CREATE PROCEDURE get_ii()BEGIN\tDECLARE i INT DEFAULT 0; -- 初始化i值为0\t    label: LOOP        SET i := i+1;        IF i = 5 THEN            ITERATE label; \t-- 跳出当前循环,继续执行下次循环        ELSEIF i =10 THEN             LEAVE label;        END IF;     END LOOP label;\tSELECT i;END;CALL get_ii(); -- 10\n\n\n\n10-异常捕获捕获异常并处理1、语法\nDECLARE  handler_name HANDLER FOR condition_value action_satament;\nDECLARE 处理方式 HANDLER FOR 异常条件 处理动作;\n\n语法解析：（1） handler_name（处理方式）: 异常处理程序的名称，取值如下：\n\ncontinue：发生异常后，程序不会终止，会正常执行后续的过程（捕获异常）;\nexit：发生异常后，终止存储过程的执行\n\n（2）condition_value（异常条件）：是指捕获异常类型，取值如下：\n\nSQLSTATTE sqlstate_value(状态码)，例如：SQLSTATE ‘02000’（捕获特定的 sqlstate 错误码）（捕获特定的 状态码的异常，例如：23000 表示主键冲突）\n\nsqlwaring： 代表所有警告类型的异常 （sqlstate 以01 开头）（这类错误通常表示警告，例如数据截断、空值转换等）\n\nnot found： 未找到数据异常（sqlstate 以 02 开头）（通常用于游标中，表示”没有更多的数据”）\n\nsqlexception: 代表除了 01 和 02 开头以外的 sqlstate 错误（表示严重的异常，例如主键冲突、权限不足等）\n(3) 处理动作：    通常是一条sql语句，例如：SET 变量 :&#x3D; 值    ，    SELECT ‘错误信息’    如果处理方式有多条sql语句，使用 begin…end 包裹\n\n\n\n**抛出自定义异常：**signal​    在 mysql 中使用 signal sqlstate ‘4500’抛出用户自定义异常可以在存储过程、存储函数、触发器中适用\nSIGNAL SQLSTATE &#x27;45000&#x27; SET MESSAGE_TEXT=&#x27;错误:新工资低于旧工资!!!&#x27;;\n需求：写一个存储过程，新增员工\n– 非工作日不能新增员工\nDROP PROCEDURE IF EXISTS add_emp;CREATE PROCEDURE add_emp(IN var_eno INT,IN var_ename VARCHAR(50))BEGIN \tDECLARE var_week INT;\t\tSELECT DAYOFWEEK(NOW()) INTO var_week;\t\tIF var_week=1 || var_week=7 THEN\t\tSIGNAL SQLSTATE &#x27;45000&#x27; SET MESSAGE_TEXT=&#x27;周末不允许添加员工&#x27;;\tELSE \t\tINSERT INTO t_emp(empno,ename) \t\tVALUES(var_eno,var_ename);\t\t\t\tSELECT &#x27;新增成功！！！&#x27;;\tEND IF;END;CALL add_emp(7133,&#x27;alex&#x27;);\n\n\n\n\n\n2、异常处理声明的位置CREATE PROCEDURE 存储过程名()BEGIN\t-- 1.声明异常\t-- 2.声明异常处理器(必须在变量之后声明)-- 示例：DECLARE EXIT HANDLER FOR SQLEXCEPTIONBEGIN\tSELECT &#x27;发生错误&#x27;;\tROLLBACK; -- 回滚事务END-- 3.主业务逻辑-- 例如：给员工加薪，转账操作。。。END;\t\t\t\n\n\n\n处理**主键冲突(**SQLSTATE 23000)在新增数据的业务中，可能会出现主键冲突的异常\n需求：向部门表中新增数据\nDROP PROCEDURE IF EXISTS insert_dept;CREATE PROCEDURE insert_dept(\tIN var_dno INT,\t\t-- Variable变量\tIN var_dname VARCHAR(50),\tIN var_loc VARCHAR(255))BEGIN\t\t-- 1.声明变量\t\t\t-- 2.声明异常处理器-- \tDECLARE EXIT HANDLER FOR SQLSTATE &#x27;23000&#x27;\t\tDECLARE primarykey_conflict CONDITION FOR SQLSTATE &#x27;23000&#x27;;\t\tDECLARE EXIT HANDLER FOR primarykey_conflict\t\tBEGIN\t\t\tSELECT &#x27;错误：当前部门编号已存在&#x27; AS &#x27;err_mssage&#x27;;\t\tEND;\t-- 只有一条代码可以省略begin end\t\t\t-- 主业务逻辑(插入数据)\tINSERT INTO c_dept(dno,dname,loc) \t\tVALUES(var_dno,var_dname,var_loc);\tSELECT &#x27;新增数据成功！！！&#x27; AS &#x27;success&#x27;;END; CALL insert_dept(1,&#x27;营销部&#x27;,&#x27;江西南昌&#x27;);CALL insert_dept(8,&#x27;营销部&#x27;,&#x27;江西南昌&#x27;);\n\n\n​\t\t\t需求：处理 除 0 异常  定义一个存储过程，输入一个被除数和一个除数  如果除数为0，输出”除数不能为0”的错误信息\nDROP PROCEDURE IF EXISTS test_exception;CREATE PROCEDURE test_exception(  IN numberator INT,  -- 被除数  IN denominator INT,  -- 除数  OUT result DECIMAL(10,2),  -- 结果  OUT errmsg VARCHAR(255) -- 错误信息)BEGIN  -- 1.声明变量的  --  将特定 sqlstate 映射为可读性更好的条件名称  -- 除零错误的 sqlstate: SOLSTATE &#x27;22012&#x27;  DECLARE division_by_zero CONDITION FOR SQLSTATE &#x27;22012&#x27;;  -- 2.声明处理异常程序  -- 当发生除零错误的时候执行此处理程序  DECLARE EXIT HANDLER FOR division_by_zero  BEGIN    SET result := NULL;    SET errmsg := &#x27;错误：除数不能为0&#x27;;  END;  -- 处理其他的错误   DECLARE EXIT HANDLER FOR SQLEXCEPTION    BEGIN    -- 获取错误信息      GET DIAGNOSTICS CONDITION 1      @sqlstate = RETURNED_SQLSTATE,   --  sql 标准的错误码      @errno = MYSQL_ERRNO,         --  mysql 特定的错误号      @text = MESSAGE_TEXT;        SET result := NULL;  SET errmsg := CONCAT(    &#x27;其他错误: @sqlstate&#x27;,@sqlstate,    &#x27;,@errno = &#x27;,@errno,&#x27;,@text = &#x27;,@text);   END;   -- 3.执行主业务逻辑   -- 没有异常，正常输出结果   SET result := numberator / denominator;   SET errmsg := NULL;END;SET @result :=&#x27;&#x27;;SET @errmsg := &#x27;&#x27;;CALL test_exception(10,5,@result,@errmsg);SELECT @result,@errmsg;   -- 2.00 NULLCALL test_exception(10,0,@result,@errmsg);SELECT @result,@errmsg;   -- NULL 错误：除数不能为0\n\n\n\n\n\n11-游标游标：可以理解为一个指向结果集中某条记录的指针，允许我们逐一访问结果集中的每条记录，并对其进行逐行操作和处理简单来说，类似java中保存数据的集合（可以被遍历）\n\n语法：DECLARE 游标名称 CURSOR FOR 查询语句;\n\n\n使用游标:OPEN 游标名称FETCH 游标名称 INTO 变量 [,变量, …];CLOSE 游标名称\n\n需求：将c_dept表中的所有数据查询出来，循环插入到c_dept2表中  复制表中的数据\nDROP TABLE IF EXISTS c_dept2;-- 先创建c_dept表结构到c_dept2表CREATE TABLE c_dept2(  dno INT,  dname VARCHAR(50) NOT NULL,  loc VARCHAR(255));DROP PROCEDURE IF EXISTS copy_dept;CREATE PROCEDURE copy_dept()BEGIN  DECLARE v_dno INT;  DECLARE v_dname VARCHAR(50);  DECLARE v_loc VARCHAR(255);  -- 声明一个变量控制循环的结束  DECLARE done INT DEFAULT FALSE;  -- 1.查询c_dept表中的所有数据，保存到一个游标中  DECLARE dept_cursor CURSOR FOR     SELECT dno,dname,loc FROM c_dept;  -- 声明异常处理器    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done := TRUE;  -- 2.使用游标   OPEN dept_cursor;  -- 循环游标  label: LOOP    -- 每次循环从游标中取一行数据    FETCH dept_cursor INTO v_dno,v_dname,v_loc;    IF done THEN -- 退出条件：取不到数据  LEAVE label;END IF;-- 将取出来的数据插入c_dept2 表中INSERT INTO c_dept2(dno,dname,loc) VALUES (v_dno,v_dname,v_loc);  END LOOP label;  CLOSE dept_cursor;END;CALl copy_dept();-- TRUNCATE TABLE c_dept2;SELECT * FROM c_dept2;\n\n\n\n12-存储函数1、存储函数：是预编译并存储在数据库中的sql程序，它封装了一系列SQL语句和逻辑判断，【必须返回一个值】，它可以像内置函数（例如sum(),concat()…）嵌入到SQL语句中直接调用简单理解：是一个带返回值的存储过程\n2、核心特点：（1）强制返回值：函数中必须包含return语句，要注意：返回值的类型与声明的一致（2）参数限制：函数的参数仅支持IN类型的参数，没有OUT和INOUT（默认IN类型，可以不写）（3）嵌入性：可以直接用在select，where，insert等语句中\n3、语法结构\nCREATE FUNCTION 函数名称(参数 参数类型, …)– 默认IN类型，可以不写RETURNS 返回值数据类型[特性选项]  – 可选BEGIN– 函数逻辑– 整个函数必须有return返回值RETURN 结果;END;\n\n4、特性选项说明：标明特性的目的是：告诉数据库引擎，优化函数的执行效率取值如下：（1）DETERMINISTIC ：输入相同的参数时，返回的结果时固定的，多次调用，直接复用结果，有助于优化器提速；确定性函数：是指每次调用函数时，传同一个参数，返回值是固定的\n\n如果 传递一个参数 返回值是固定的，第一次调用时会执行函数，计算出结果并缓存；\n之后每次调用则使用缓存的结果，不需要再次执行函数过程，提升执行效率\n\n（2）SQL DATA ACCESS ：声明的函数对数据的操作类型   no sql ：无数据操作   reads sql data ：仅读数据   modifies sql data ：修改数据\n1、确定性函数(科学计算)无数据库操作，结果是确定的(每一次传100进来，结果是确定的5050)创建一个函数：计算0~n之间的整数和\nDROP FUNCTION IF EXISTS get_sum;CREATE FUNCTION get_sum(n INT)  RETURNS INT DETERMINISTIC -- 表示是确定性函数 -- NOT DETERMINISTIC -- 表示不确定性函数，例如返回一个随机数时，使用该特性BEGIN  DECLARE result  INT DEFAULT 0;  DECLARE i INT DEFAULT 0;  label: LOOP    IF i &lt;= n THEN       SET result := result + i;      SET i := i+1;    ELSE LEAVE label; -- i &gt; n 则推出循环    END IF;  END LOOP label;  -- 返回结果  RETURN result;END;\n\n– 使用函数\n-- 第一次调用，计算结果会缓存SELECT get_sum(100) AS &#x27;result&#x27;;  -- 后面的调用，使用缓存的结果，效率更快SELECT get_sum(100) AS &#x27;result&#x27;;\n\n\n\n2、查询型函数(读取数据库数据)需求：根据部门dno，查询部门的地址loc\nDROP FUNCTION IF EXISTS get_dept_loc;CREATE FUNCTION get_dept_loc(v_dno INT) RETURNS VARCHAR(255) READS SQL DATA -- 该特性表示 仅读取数据BEGIN   DECLARE var_loc VARCHAR(255); -- 保存查询到的部门地址  -- 查询逻辑  SELECT loc INTO var_loc FROM c_dept WHERE dno=v_dno;  -- 判断查询结果  IF var_loc IS NULL THEN     SET var_loc := &#x27;没有该部门的地址信息！！！&#x27;;  END IF;  RETURN var_loc;END;\n\n\n\nSELECT get_dept_loc(2) AS &#x27;部门地址&#x27;; -- 北京海淀SELECT get_dept_loc(10) AS &#x27;部门地址&#x27;;           -- 没有该部门的地址信息！！！SELECT loc FROM c_dept WHERE dno=10;\n\n\n\n3、带游标和异常处理的复杂函数计算教师表c_teacher，每个部门的老师平均工资– 传递部门编号，计算出该部门的平均薪资\nDROP FUNCTION IF EXISTS get_avgsal_by_dept;CREATE FUNCTION get_avgsal_by_dept(v_dno INT) RETURNS DECIMAL(10,2) READS SQL DATA -- 仅查询BEGIN  -- 1.声明变量  -- 计算部门的薪资和  DECLARE var_total_sal DECIMAL(10,2) DEFAULT 0;  DECLARE var_count INT DEFAULT 0; -- 统计部门的人数  DECLARE done INT DEFAULT 0; -- 控制循环的变量  DECLARE var_sal DECIMAL(10,2); -- 接受游标中取出来的值  DECLARE var_avgsal DECIMAL(10,2); -- 返回结果：部门的平均工资  -- 2.声明游标，保存当前部门的薪资  DECLARE cur_sal CURSOR FOR      SELECT sal FROM c_teacher WHERE dno=v_dno;  -- 3.声明异常处理器  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done := 1;  -- 4.使用游标  OPEN cur_sal;    label: LOOP      FETCH cur_sal INTO var_sal;      -- 取不到就立即退出循环      IF done = 1 THEN LEAVE label;      END IF;        -- 计算薪资和  SET var_total_sal := var_total_sal + var_sal;  -- 统计人数  SET var_count := var_count + 1; -- 每次取到就+1END LOOP label;  CLOSE cur_sal;  -- 计算平均值  -- 加入某个部门的人数为0，不能作为除数，计算平均工资  IF var_count = 0 THEN     RETURN 0;  ELSE     -- 平均工资 = 总工资 / 人数    SET var_avgsal := var_total_sal / var_count;    RETURN var_avgsal;  END IF;END;\n\nSELECT get_avgsal_by_dept(1) AS &#x27;部门平均薪资&#x27;; -- 15978.49-- 验证SELECT TRUNCATE(AVG(sal),2) FROM c_teacher GROUP BY dno HAVING dno = 1;\n\n\n\n\n\n存储函数和存储过程的区别\n1.声明的关键字不一样：\n存储过程使用 procedure，\n函数使用 function\n\n\n2**.参数类型**支持不一样：\n存储过程支持 IN\\OUT\\INOUT参数类型，\n函数仅支持 IN类型参数\n\n\n3.返回结果的处理方式不一样：\n存储过程可以通过OUT参数返回结果，或者不返回结果，\n函数必须返回结果，使用 return 关键字\n\n\n4.调用方式：\n存储过程通过 call 语句调用，\n函数可以直接嵌套在 slq 语句中\n\n\n5.事务支持不一样：\n存储过程完全支持事务，\n函数支持事务但是有限制(不推荐在函数中使用事务)\n\n\n\n13-触发器1、触发器：是与表关联的特殊的存储过程，会在满足特定条件的自动触发执行，无需手动调用\n2、核心要素（1）触发事件：引起触发器执行的操作：insert、update、delete（2）触发时机：引起发生的时间点：before、after（3）触发对象：关联的表（触发器必须依附于某张表，不能独立存在）（4）触发频率：for each row(默认)，每影响一行数据，就触发一次（行级触发器）\n3、语法结构\nCREATE TRIGGER 触发器名称触发时机 触发事件 ON 表名FOR EACH ROW – 行级触发BEGIN– 触发器执行逻辑(SQL语句，条件判断…)END;\n\n4、new 和 old 关键字说明\n  new.字段名 ：引用 插入 | 更新后的新值（insert 和 update 事件可用）\n  old.字段名 ：引用 更新 | 删除前的旧值（update 和 delete 事件可用）\n\n  **注意：**new和old后面的字段名 是 \n– （1）创建日志表：记录对 c_dept表的操作\nCREATE TABLE IF NOT EXISTS c_dept_logs(  id INT PRIMARY KEY auto_increment,  dno INT COMMENT &#x27;记录操作的部门编号&#x27;,  action VARCHAR(255) COMMENT &#x27;记录操作部门表的行为&#x27;,  time_at DATE COMMENT &#x27;记录操作的事件&#x27;);\n\n需求：向部门表插入数据 每次插入一条数据，要在 dept_logs表中记录一条信息\n1、insert 触发器DROP TRIGGER IF EXISTS trigger_dept_insert;CREATE TRIGGER trigger_dept_insertAFTER INSERT ON c_deptFOR EACH ROWBEGIN\t-- 记录新增的日志   INSERT INTO c_dept_logs(dno,action,time_at)        VALUES(NEW.dno, &#x27;insert&#x27;, NOW());END;-- 向c_dept 表中新增数据时，会自动触发trigger_dept_insert执行INSERT INTO c_dept(dname,loc) VALUES(&#x27;事业部&#x27;,&#x27;江西南昌&#x27;);INSERT INTO c_dept(dname,loc) VALUES(&#x27;坐飞机部&#x27;,&#x27;北京朝阳&#x27;);SELECT * FROM c_dept_logs;\n\n\n\n2、update 触发器需求：修改c_dept表的数据，触发 执行\nDROP TRIGGER IF EXISTS trigger_dept_update;CREATE TRIGGER trigger_dept_updateAFTER UPDATE ON c_deptFOR EACH ROWBEGIN    -- 记录更新的日志   INSERT INTO c_dept_logs(dno,action,time_at)         VALUES(NEW.dno, &#x27;update&#x27;, NOW());END;UPDATE c_dept SET dname=&#x27;研发5部&#x27; WHERE dno=8;SELECT * FROM c_dept_logs;\n\n\n\n\n3、delete 触发器需求：删除c_dept表的数据，触发 执行\nDROP TRIGGER IF EXISTS trigger_dept_delete;CREATE TRIGGER trigger_dept_deleteBEFORE DELETE ON c_dept  -- 删除前FOR EACH ROWBEGIN    -- 记录删除的日志    INSERT INTO c_dept_logs(dno,action,time_at)           VALUES(OLD.dno, &#x27;delete&#x27;, NOW()); -- 删除前旧数据END;-- 向c_dept 表中新增数据时，会自动触发trigger_dept_insert执行DELETE FROm  c_dept  WHERE dno=8;SELECT * FROM c_dept_logs;\n\n\n\n4、查看触发器（1）查看所有触发器SHOW TRIGGERS;\n\n\n\n（2）从系统表中查看指定表名的触发器SELECT * FROM information_schema.TRIGGERS WHERE EVENT_OBJECT_TABLE=&#x27;c_dept&#x27;;\n\n\n\n5、删除触发器DROP TRIGGER IF EXISTS 触发器名称;\n\n\n\n触发器的优点（使用场景）\n（1）自动化：在指定的事件和时机下，自动触发执行，无需手动调用\n（例如：自定计算、日志记录）\n\n\n（2）数据一致性（强制实施业务规则）：触发器可以帮助确保表中的业务规则强制执行\n（例如：只能在工作日插入员工信息，价格不能为负数等）\n\n\n（3）简化代码：将重复的逻辑（例如备份、日志）封装在触发器中，避免程序重复编写\n\n缺点：\n\n（1）性能影响：频繁触发的触发器会增加数据库负担\n（2）调试困难：触发器在后台自动执行，出错时难以追踪\n\n**注意事项：**触发器内尽量只写简单逻辑（例如赋值、写日志），复杂业务建议使用存储过程\n14-定时任务1、定时任务定时任务：通常指按预设时间自动执行的数据库操作（如数据清理、统计汇总、备份等）。mysql中，内置的事件(EVENT)机制就是实现定时任务的核心工具mysql提供事件调度器（event scheduler）来执行定时任务\n2、适用场景（1）定时清理数据（例如清理过期日志、垃圾图片信息）（2）数据统计和报表生成（例如每日的销售额汇总）（3）缓存刷新或者数据同步\n3、事件调度器的注意事项（1）权限要求：创建事件需要event权限（2）依赖问题：事件中调用的存储过程 或 表 需要提前存在（3）时间精度：最小执行间隔为 1s，但是频繁执行会影响性能（4）错误处理：时间执行失败，不会自动重试，需要代码中处理异常\n4、语法CREATE EVENT IF NOT EXISTS 定时任务名称ON SCHEDULE AT | EVERY 执行时间 \t-- AT 一次性定时任务, every 是周期定时任务DOBEGIN\t-- sql 逻辑END; \n\n\n\n1.查看事件调度器SHOW VARIABLES LIKE &#x27;event_scheduler&#x27;;  -- ON    -- on表示启用 off禁用\n\n\n\n2、临时启用事件调度器，重启服务器后会失效-- 如果默认是关闭的，需要临时启用SET GLOBAL event_scheduler = ON;\n\n\n\n3.创建一次性执行事件– 在指定时间删除超过2天的日志信息\nDROP EVENT IF EXISTS delete_log_data;CREATE EVENT IF NOT EXISTS delete_log_dataON SCHEDULE AT &#x27;2025-08-07 18:27:00&#x27; -- 指定执行时间DOBEGIN  DELETE FROM c_dept_logs     WHERE time_at &lt; CURRENT_DATE - INTERVAL 2 DAY;END;SELECT * FROM c_dept_logs;\n\n\n\n4.周期性执行事件DROP EVENT IF EXISTS dayly_backup;CREATE EVENT IF NOT EXISTS dayly_backupON SCHEDULE EVERY 7 DAY -- 每7天执行一次STARTS &#x27;2025-08-07 01:00:00&#x27;DOBEGIN  -- 调用存储过程  CALL add_sal();END;\n\n\n\n5.管理定义的事件查看所有事件SHOW EVENTS;\n\n\n\n修改事件ALTER EVENT dayly_backupON SCHEDULE EVERY 3 DAY; -- 修改为3天执行一次\n\n\n\n启用 | 禁用事件ALTER TABLE dayly_backup DISABLE; -- 禁用ALTER TABLE dayly_backup ENABLE; -- 启用\n\n\n\n删除事件DROP EVENT IF EXISTS dayly_backup;\n\n\n\n15-事务1、概述一件事情有n个组成单元 要不这n个组成单元同时成功 要不n个单元同时失败，这就是将n\n个组成单元放到一个事务中\n\n概念：事务是用来控制一组sql语句的，要么全部成功，要么全部失败为什么使用：用于保证事务的完整性\n\n2、事务的特性和隔离级别事务的四大特性（ACID）:\n\n原子性（Atomicity）：是指事务是一个不可分割的整体，事务中的操作要么全部成功，要么全部失败。\n例如：转账业务中减钱和加钱的操作，要么 同时成功，要么同时失败；\n一致性（完整性）（Consistency）：是指一个事务中，事务前后数据的完整性必须保持一致。\n例如：转账业务中，转账前和转账后，总金额必须一致；\n隔离性（Isolation）：多个事务，事务的隔离性是指在并发事务中，一个事务不能被其他事务所干扰，多个并发事务之间数据要相互隔离。\n持久性（Durability）：是指一个事务一旦被提交，该事务对数据库中数据的操作，必须被持久化\n\n事务的四大特性（ACID）是数据库系统中保证数据一致性和可靠性的核心原则。这四个特性分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。下面我们通过一个经典的银行转账例子来逐一解释。\n\n🏦 场景：银行转账假设用户 A 向用户 B 转账 100 元：\n\nA 的账户余额减少 100 元\nB 的账户余额增加 100 元\n\n这个操作必须作为一个事务来执行，以确保数据的正确性。\n\n1. 原子性（Atomicity）\n“要么全部执行，要么全部不执行。”\n\n举例：在转账过程中，如果 A 的账户成功扣了 100 元，但系统在给 B 加钱时突然崩溃了，那么整个操作必须回滚（rollback），A 扣的钱也要退还。\n✅ 原子性确保：  \n\n“转账”这个操作是一个不可分割的整体。即使中间出错，也不会出现“钱消失”的情况。\n\n❌ 如果没有原子性：  \n\nA 少了 100 元，B 没收到钱 → 钱“凭空消失”。\n\n\n2. 一致性（Consistency）\n“事务执行前后，数据库都处于一致状态。”\n\n举例：转账前：  \n\nA 有 500 元，B 有 300 元 → 总金额 &#x3D; 800 元\n\n转账后：  \n\nA 有 400 元，B 有 400 元 → 总金额仍为 800 元\n\n✅ 一致性确保：  \n\n无论事务是否成功，数据库的业务规则（如总金额不变、余额不能为负等）始终被遵守。\n\n❌ 如果没有一致性：  \n\nA 扣了 100 元，B 加了 150 元 → 总金额变成 850 元，破坏了“资金守恒”。\n\n\n💡 注意：一致性是由应用程序和数据库共同维护的，事务的原子性、隔离性、持久性是实现一致性的手段。\n\n\n3. 隔离性（Isolation）\n“并发执行的多个事务之间互不干扰。”\n\n举例：A 正在给 B 转账（事务未完成），同时 C 也在查询 B 的余额。\n✅ 隔离性确保：  \n\n在 A 的转账事务提交之前，C 查询到的 B 的余额仍然是旧值（比如 300 元），不会看到“中间状态”（如 350 元）。\n\n\n这防止了脏读、不可重复读、幻读等问题。\n\n❌ 如果没有隔离性：  \n\nC 看到 B 的余额变成 400 元，但随后 A 的转账失败并回滚，B 实际还是 300 元 → C 读到了“脏数据”。\n\n\n4. 持久性（Durability）\n“一旦事务提交，其结果就是永久性的，即使系统崩溃也不会丢失。”\n\n举例：A 成功给 B 转账 100 元，事务提交后：\n\n系统突然断电或重启\n\n✅ 持久性确保：  \n\n重启后，A 的余额是 400 元，B 的余额是 400 元，转账结果不会丢失。\n\n\n数据库会通过写日志（如 redo log）等方式，确保已提交的事务能被恢复。\n\n❌ 如果没有持久性：  \n\n转账成功了，但一重启，数据又变回转账前的状态 → 用户“白转了”。\n\n\n✅ 总结（用一句话记住 ACID）\n\n\n特性\n一句话解释\n\n\n\nA 原子性\n要么全做，要么全不做\n\n\nC 一致性\n数据始终符合业务规则\n\n\nI 隔离性\n并发事务互不干扰\n\n\nD 持久性\n提交后永不丢失\n\n\n\n💡 所有现代关系型数据库（如 MySQL、PostgreSQL、Oracle）都通过日志、锁、MVCC 等技术来实现这四大特性，确保数据安全可靠。\n\n准备表\nDROP TABLE IF EXISTS `account`;CREATE TABLE `account` (  `id` INT PRIMARY KEY auto_increment,  `name` VARCHAR(50) NOT NULL,  `balance` DECIMAL(10,2) NOT NULL CHECK(balance &gt;= 0) );INSERT INTO account(`name`,balance)   VALUES(&#x27;tom&#x27;,20000.00),(&#x27;rose&#x27;,20000.00);\n\n– 查询数据库的事务提交方式\nSELECT @@autocommit; -- 默认 = 1，表示自动提交SET @@autocommit = 0; -- 修改为手动提交SET @@autocommit = 1;-- 修改为自动提交\n\n\n\n模拟转账业务手动控制事务流程（1）修改数据库提交事务的方式：SET @@autocommit &#x3D; 0;（2）执行事务中的SQL语句（3）如果没有异常，执行 commit 提交事务（4）如果出现异常，执行 rollback 回滚事务\n– （1）修改提交方式\nSET @@autocommit = 0;\n\n– （2）执行SQL语句\n-- 查询余额SELECT balance FROM account WHERE name=&#x27;tom&#x27;;-- tom账户减少10000元UPDATE account SET balance=balance-10000 WHERE `name`=&#x27;tom&#x27;;异常-- rose账户增加1000元UPDATE account SET balance=balance+10000 WHERE `name`=&#x27;rose&#x27;;-- 如果没有异常：COMMIT;-- 如果出现异常：ROLLBACK;\n\n\n\n由数据库控制事务的流程（1）修改数据库提交事务的方式：\nSET @@autocommit = 1（mysql数据库默认为1）\n\n（2）开始事务（3）执行事务中的SQL语句（4）如果没有异常，执行commit（5）如果有异常，执行rollback\n-- 开启事务-- BEGIN; -- 第一种方式开启事务START TRANSACTION; -- 第二种方式开启事务  -- 查询余额  SELECT balance FROM account WHERE name=&#x27;tom&#x27;;  -- tom账户减少10000元  UPDATE account SET balance=balance-10000 WHERE `name`=&#x27;tom&#x27;;  出现异常  -- rose账户增加1000元  UPDATE account SET balance=balance+10000 WHERE `name`=&#x27;rose&#x27;;COMMIT;ROLLBACK;\n\n\n\n使用存储过程完成转账业务操作需求（1）查询余额大于1000的 可以转账,小于1000，提示余额不足（2）出现异常，回滚事务\nDROP PROCEDURE IF EXISTS transfer_money;CREATE PROCEDURE transfer_money(  IN out_id INT, -- 转出账户  IN in_id INT, -- 转入账户  IN money DECIMAL(10,2), -- 转账金额  OUT result_msg VARCHAR(255) -- 转账结果)label: BEGIN  -- 转出账户的余额  DECLARE out_balance DECIMAL(10,2) DEFAULT 0;   -- 判断转入账户是否存在  DECLARE has_in_id INT DEFAULT 0;  -- 异常处理器  DECLARE EXIT HANDLER FOR SQLEXCEPTION   BEGIN    ROLLBACK; -- 回滚事务    SET result_msg := &#x27;转账失败，系统出现异常，请重试！！！&#x27;;  END;  -- 判断转入账户是否存在  SELECT COUNT(*) INTO has_in_id FROM account WHERE id=in_id;  IF has_in_id =0 THEN     SET result_msg := &#x27;转入账户不存在！！！&#x27;;    LEAVE label; -- leave后续代码不执行  END IF;  -- 开始事务  START TRANSACTION;   -- 查询转出账户的余额  SELECT balance INTO out_balance FROM account WHERE id=out_id;  -- 判断余额 与 转账金额 大小  IF out_balance &gt;= money THEN     -- 转出账户减钱    UPDATE account SET balance=balance-money WHERE id=out_id;      -- 模拟的SQL异常--     SELECT * FROM CCC;     -- 转入账户加钱  UPDATE account SET balance=balance+money WHERE id=in_id;  -- 转账完成，提交事务  COMMIT;  SET result_msg := &#x27;转账成功！！！&#x27;;  ELSE     ROLLBACK;    SET result_msg := &#x27;转账失败，您的余额不足！！！&#x27;;  END IF;END;\n\n\n\nSET @result := &#x27;&#x27;;-- 正确转账CALL transfer_money(1,3,1000,@result); SELECT @result; -- 转账成功！！！-- 余额不足CALL transfer_money(3,2,2000,@result); SELECT @result;  -- 转账失败，您的余额不足！！！-- 账号不存在CALL transfer_money(2,6,2000,@result);SELECT @result;  -- 转入账户不存在！！！-- 出现异常CALL transfer_money(1,3,1000,@result);SELECT @result; -- 转账失败，系统出现异常，请重试！！！\n\n\n\n3、事务的并发问题\n1、脏读：是指一个事务读取到了另外一个事务未提交的数据（脏数据）；2、不可重复读：当前事务在读取数据时，另外一个事务修改了数据，导致当前事务对数据的两次查询结果不一致；3、幻读：当前事务读取表数据，另外一个事务对表的数据进行了新增或删除，导致当前事务对表的两次查询结果不一致。\n\n事务的隔离级别\n\n\nRead uncommitted  读未提交： 可能出现任何事物的并发问题\nRead committed 读已提交：解决了脏读问题\nRepeatable read 可重复读：解决了脏读和不可重复读问题（mysql默认）\nSerializable 序列（串行）化： 都不会出现\n\n\n查询 隔离级别\nSELECT @@global.transaction_isolation; -- REPEATABLE-READ是mysql默认的 隔离级别\n\n设置隔离级别\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;    -- 将隔离级别设置为 读未提交 数据SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;    -- -- 将隔离级别设置为 可重复读\n\n\n事务一：Repeatable read 可重复读：解决了脏读和不可重复读问题（mysql默认）\nSTART TRANSACTION;UPDATE account SET balance=balance+1000 WHERE id=3;COMMIT;\n\n事务二：\nSTART TRANSACTION;SELECT balance FROM account WHERE id=3;COMMIT;\n\n\n\n16-数据库三大范式数据库范式的作用：数据库的三大范式是关系型数据库设计中用于规范表结构、减少数据冗余和避免更新异常的重要原则。它们从低到高逐步细化，每一级范式都建立在对上一级范式的满足之上。\n简答：\n1NF：列不可分割（原子性）。2NF：消除非主属性对复合主键的部分依赖（基于1NF）。3NF：消除非主属性之间的传递依赖（基于2NF）。  \n\n注意：范式并非越高越好，过度规范化可能导致表数量过多，查询时需频繁关联表，降低性能。实际设计中需在规范化和查询效率之间权衡，有时会适当保留少量冗余（如反范式设计）。\n\n第一范式：原子性，确保表中的每个列是原子列，不可再分。\n第二范式：在满足第一范式的基础上，保证表中的所有非主键属性必须完全依赖于整个主键，而不能仅依赖于主键的一部分，解决的是复合主键下，表中数据冗余和更新异常的问题\n第三范式：在满足第二范式的基础上，所有的非主键属性之间不能存在直接的依赖关系，主键属性必须直接主键属性，解决的是非主键属性对主键的依赖传递问题（非主键属性之间存在依赖）\n\n三范式解决什么问题1NF: 确保数据的基本单元，为后面的范式打下基础2NF: 确保复合主键情况下，数据冗余和更新异常问题3NF：解决非主键属性 间接 依赖主键问题（非主键属性之间存在依赖传递）\n17-存储引擎mysql体系结构(1)连接层：主要负责连接处理、授权认证、安全方案等功能。(2)服务层：主要负责大多数核心服务功能，比如sql接口，完成缓存查询，布置函数的执行等功能。(3)引擎层：存储引擎主要负责mysql中数据的存储和提取。(4)存储层：主要负责将数据存储到磁盘文件中。\n存储引擎的作用：存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。\n查看数据库支持的存储引擎：\nSHOW ENGINES;-- InnoDB-- MyISAM-- MEMORY\n\n可以查看表使用的存储引擎：\nSHOW CREATE TABLE account;\n\n设置存储引擎创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写： \nCREATE TABLE 表名(建表语句;) ENGINE = 存储引擎名称;\n\n 如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎 \nALTER TABLE 表名 ENGINE = 存储引擎名称;-- 示例：alter table t_emp engine = &#x27;MYISAM&#x27;;\n\n\n\n存储引擎特点1、 InnoDB\n(1)介绍\tInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。(2) 特点DML操作遵循ACID模型，支持事务 ；行级锁 ，提高并发访问性能；支持外键 FOREIGN KEY约束，保证数据的完整性和正确性；(3) 文件xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。(4) InnoDB 存储结构表空间 → 段(1M) → 区(64页) → 页(16k) → 行\n\n查看每张表是否开启了对应的表空间：参数：innodb_file_per_table\nSHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;; -- ON\n\n\non 打开的，表示每张表对应一个表空间文件\n\n\n查看表空间文件\n首先查看  MySQL 的表空间文件 默认存放在数据目录 下，可通过 SQL 命令查询： \nSHOW VARIABLES LIKE &#x27;datadir&#x27;;\n\n\n进入 mysql 数据目录：\n\n\nwindows下默认存放数据目录：在 mysql 安装的 data 目录中\n\n查看表文件内容ibd2sdi xxx.ibd\n\n\n逻辑存储结构\n2、MyISAM(1) 介绍\tMyISAM是MySQL早期的默认存储引擎。(2) 特点    不支持事务，不支持外键    支持表锁，不支持行锁    访问速度快(3) 文件    xxx.sdi：存储表结构信息    xxx.MYD: 存储数据    xxx.MYI: 存储索引\n修改存储引擎：\nALTER TABLE account ENGINE = &#x27;MyISAM&#x27;;\n\n查看数据文件\n3、Memory(1) 介绍\tMemory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。(2) 特点    内存存放    hash索引（默认）(3) 文件    xxx.sdi：存储表结构信息\n4、存储引擎选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\nInnoDB : 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。\nMyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\nMEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n18-1索引1、索引的概念索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n简单来说，数据库中的索引就类似图书的目录，我们可以根据索引快速高效的查找数据\n2、索引的优缺点优势：    (1)提高数据检索的效率，降低数据库的IO成本    (2)通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。劣势：    (1)索引列也是要占用空间的。    (2)索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。\n3、mysql索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构：(1) b+tree 索引：最常见的索引类型(2) hash 索引：底层是hash表实现的，只能用于精准匹配\n4、为什么InnoDB存储引擎选择使用B+tree索引结构？(1)相对于二叉树，b+tree层级更少，搜索效率高；(2)B-tree,无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，同样保存大量数据，只能增加树的高度，导致性能降低；(3) 相对Hash索引，B+tree支持范围匹配及排序操作；\n5、索引的分类(1)主键索引：针对于表中主键创建的索引，默认自动创建，只能有一个关键字：PRIMARY(2)唯一索引：避免同一个表中某数据列中的值重复，可以有多个关键字：UNIQUE(3)普通索引：快速定位特定数据(4)全文索引：全文索引查找的是文本中的关键词，而不是比较索引中的值\n6、根据索引的存储形式又可以分为：(1)聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据(2)二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键\n7、聚集索引选取的规则：\n如果存在主键，主键索引就是聚集索引。\n如果不存在主键，将使用第一个唯一UNIQUE）索引作为聚集索引。\n如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。\n\n8、聚集索引和二级索引谁的查询的效率高？为什么？​    聚集索引的效率高​    聚集索引将数据存储与索引放到了一块，二级索引将数据与索引分开存储，它的索引结构的叶子节点关联的是对应的主键，使用二级索引查询，还是需要回表查询聚集索引\n18-2 索引1、sql性能分析执行命令：\n-- 命令可以提供服务器状态信息-- 查看当前数据库的INSERT、 UPDATE、 DELETE、SELECT的访问频次：show global status like &#x27;Com_______&#x27;;   -- 7个下划线，匹配7个字符\n\n\n2、慢查询日志配置文件的位置：&#x2F;etc&#x2F;my.cnf\n# 开启mysql慢日志查询开关slow_query_log=1#设置慢日志的时间为2秒，sql语句执行时间超过2秒，就会是为慢查询，记录慢查询日志long_query_time=2\n\n设置完成后重启mysql服务器进行测试\n查看慢日志文件中记录的信息 \n# 动态显示文档的最后内容,一般用来查看日志，执行命令：`tail -f b.txt`tail -f /var/lib/mysql/localhost-slow.log\n\n\n\n查询：\nselect * from tb_user where age &gt; 20;\n\n\n慢日志记录：\n\n3、profile详情show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持\nprofile操作：\nSELECT @@have_profiling;   -- 是否支持， yes 表示支持SELECT @@profiling ;   -- 默认状态  0 表示关闭SET @@profiling = 1; -- 开启 profile操作\n\n\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n3.1 查看每一条sql的耗时基本情况\nshow profiles;\n\n\n3.2 查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n\n\n\n 各状态参数解析\n\n\n\n\nStatus\n中文含义\n关键说明\n\n\n\nstarting\n查询启动阶段\nMySQL 初始化查询处理（如解析 SQL、准备执行环境），耗时通常很短。\n\n\nExecuting hook on transaction\n事务钩子执行\n触发事务相关的预处理逻辑（如事务启动、钩子函数），一般耗时极短。\n\n\nstarting\n二次启动阶段（子阶段）\n部分复杂查询会进入子阶段初始化（如子查询、存储过程内部逻辑）。\n\n\nchecking permissions\n权限检查\n验证用户对查询涉及的表、列是否有操作权限，权限未缓存时可能稍慢。\n\n\nOpening tables\n打开表\n打开需要访问的表，获取表锁（如 MyISAM 表的读锁），耗时与表数量相关。\n\n\ninit\n查询初始化\n分配内存、设置查询上下文（如变量、临时表），简单查询此阶段很快。\n\n\nSystem lock\n系统级锁\n申请表级锁（如 FLUSH TABLES 时的锁），或等待全局锁，通常耗时极短。\n\n\noptimizing\n查询优化\n优化器生成执行计划（选择索引、连接顺序等），耗时 0.014875 相对较高，可能因：- 表统计信息过时（需 ANALYZE TABLE）；- 查询逻辑复杂（多表连接、子查询）。\n\n\nstatistics\n统计信息收集\n收集表的统计数据（行数、索引分布等），耗时 0.018313 较高，原因：- 表数据量大；- 统计信息未更新（需 ANALYZE TABLE）。\n\n\npreparing\n执行计划准备\n将优化后的执行计划转换为可执行的操作（如绑定参数、准备迭代器）。\n\n\nexecuting\n查询执行\n实际遍历索引、扫描行（如 Index Scan Table Scan），此阶段耗时低，说明执行本身很快（瓶颈在前序阶段）。\n\n\nend\n执行结束\n清理查询执行的中间状态（如临时变量）。\n\n\nquery end\n查询收尾\n处理结果集的最终步骤（如排序、封装结果）。\n\n\nwaiting for handler commit\n等待存储引擎提交\n等待存储引擎完成事务提交（如写日志、释放锁），耗时短则事务简单。\n\n\nclosing tables\n关闭表\n释放表资源、关闭文件句柄，耗时与表数量相关。\n\n\nfreeing items\n释放内存\n释放查询过程中分配的内存（如缓存的查询计划、临时数据）。\n\n\ncleaning up\n最终清理\n释放线程资源、标记查询结束，耗时极短。\n\n\n3.3 查看指定query_id的SQL语句cpu的使用情况\nshow profile  cpu for  query query_id;\n\n\n\n4、explain 执行计划EXPLAIN或者DESC命令获取MYSQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。\n语法：\n-- 直接在select 语句之前加上关键字  explain /descexplain select 字段列表  from 表名 where 条件;\n\n示例：\n\n解析：\nEXPLAIN 执行计划各字段含义：\n\nId：select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下； id不同，值越大，越先执行)。\nselect_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、 PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等\ntype：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、 ref、 range、 index、all \npossible_key：显示可能应用在这张表上的索引，一个或多个。\nKey：实际使用的索引，如果为NULL，则没有使用索引。\nKey_len：表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\nrows：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\nfiltered：表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。\n\n\ntype列解释（性能从优到劣）：\n\nconst：唯一索引或主键查询\neq_ref：多表关联使用主键或唯一索引\nref：普通索引查询\nrange：索引范围扫描\nindex：全索引扫描\nALL：全表扫描\n\nkey列：实际使用的索引rows列：预估扫描行数\n\n4.1 执行计划：id\n-- 只有一个 idexplain select * from c_teacher where tno = 1;-- 两个相等的idexplain select * from c_teacher t, c_dept d where t.dno = d.dno;-- 两个不等的idexplain SELECT tname, sal FROM c_teacher WHERE sal&gt; (SELECT sal FROM c_teacher WHERE tname=&#x27;秦占豪&#x27;);\n\n\n4.2 执行计划：select_type\nSIMPLE：简单表，即不使用表连接或者子查询\nPRIMARY：主查询，即外层的查询\nUNION：UNION 中的第二个或者后面的查询语句\nSUBQUERY：SELECT&#x2F;WHERE之后包含了子查询\n\n4.3 执行计划：type表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、 ref、 range、 index、all \n const → 最优访问类型之一，表示通过 主键 &#x2F; 唯一索引 找到唯一一行（如 WHERE id = 1，直接定位主键）。 \n\n5、索引使用5.1 验证索引效率-- 创建索引CREATE INDEX index_name ON table_name(column);-- 查看某张表中的所有索引SHOW INDEX FROM tb_user;-- 删除表中指定索引DROP INDEX inde_name ON table_name;ALTER TABLE table_name DROP INDEX index_name,DROP INDEX index_name... ;-- 未建立索引之前，查询数据，查看耗时select * from tb_user where phone=&#x27;13100900001&#x27;;-- 针对字段创建索引create index idx_user_phone on tb_user(phone);-- 再次执行sql查看耗时select * from tb_user where phone=&#x27;13100900001&#x27;;\n\n\n5.2 最左前缀法则如果索引使用了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳过某一列，索引将部分失效(后面的字段索引失效)。\n-- 创建索引CREATE INDEX idx_teacher_gender_job_sal ON c_teacher(gender,job,sal);\n\n\n\nexplain select * from c_teacher where gender = &#x27;女&#x27; and job = &#x27;讲师&#x27; and sal = 29936.29;\n\n最左字段存在，都走索引\n\n注意  key_len： 49 → 40 → 7\nsal&#x3D;9， job &#x3D; 33， gender &#x3D; 7\n\n\n-- 最左在，中间的跳过，那么后面的不走索引explain select * from c_teacher where gender = &#x27;女&#x27;  and sal = 29936.29;\n\n\n-- 和查询顺序没有关系explain select * from c_teacher where job = &#x27;讲师&#x27; and sal = 29936.29 and gender=&#x27;女&#x27;;explain select * from c_teacher where job = &#x27;讲师&#x27; and gender = &#x27;女&#x27; and sal = 29936.29;\n\n\n5.3 范围查询\nexplain select * from c_teacher where gender=&#x27;男&#x27; and job &gt;&#x27;考试专员&#x27; and sal = 29000;\n\n\n5.4 索引列运算\n-- 创建索引CREATE INDEX inx_teacher_tname ON c_teacher(tname);explain select * from c_teacher where tname = &#x27;赵辉&#x27;;explain select * from c_teacher where substring(tname, 1, 1) = &#x27;赵&#x27;;\n\n\n5.5 字符串不加引号\nexplain select * from tb_user where phone = &#x27;13100000015&#x27;;explain select * from tb_user where phone = 13100000015;\n\n\n5.6 模糊查询\nexplain select * from c_teacher where tname like &#x27;%赵&#x27;;explain select * from c_teacher where tname like &#x27;%赵%&#x27;;explain select * from c_teacher where tname like &#x27;赵%&#x27;;\n\n\n\n\n5.7 or 连接条件\nexplain select * from c_teacher where tno=1;explain select * from c_teacher where tno=1 or gender =&#x27;男&#x27;; explain select * from c_teacher where tno=1 and gender =&#x27;男&#x27;;\n\n\n5.8 数据分布影响\n-- 解析：   手机号默认  13100000001  ~  13100000100;wehre phone &gt; &#x27;13100000000&#x27;;    -- 走全表扫描 不走索引  大多数数据满足条件wehre phone &gt; &#x27;13100000050&#x27;;    -- 走全表扫描 不走索引  wehre phone &gt; &#x27;13100000051&#x27;;    -- 走索引             小部分数据满足条件-- 分布影响是指：走全表扫描 比走索引更快\n\n\n5.9 sql提示\nexplain select * from tb_user use index(idx_user_phone) where phone=&#x27;13100000008&#x27;;explain select * from tb_user ignore index(idx_user_phone) where phone=&#x27;13100000008&#x27;;explain select * from tb_user force index(idx_user_phone) where phone=&#x27;13100000008&#x27;;\n\n\n\n\n原本不走索引的情况，也可以强制使用索引：\n\n5.10 覆盖索引\n\n情况一： 聚集索引直接查找数据\n\n情况二： 辅助索引覆盖了查询的数据，不用回表查询\n\n情况三：辅助索引没有覆盖查询数据，需要回表查询\n\nexplain select id,username,email from tb_user where username=&#x27;vofnxyyx&#x27;;CREATE INDEX idx_user_username_email ON tb_user(username,email);\n\n覆盖索引（索引覆盖了查询的字段）\n相同的SQL语句，使用索引覆盖的查询效率更高\n原因：覆盖索引包含了要查询的字段，不会触发回表查询\n\n\n思考：\n\n5.11 前缀索引\nselect count(distinct substring(phone,1,7))/count(*) from tb_user; -- 0.0001select count(distinct substring(phone,1,9))/count(*) from tb_user; -- 0.0100select count(distinct substring(phone,1,11))/count(*) from tb_user; -- 1.0000\n\n\n\n\ncreate index idx_user_email on tb_user(email(11)); -- 根据 email 字段前11个字符创建前缀索引select * from tb_user where email=&#x27;13101999012@pp.com&#x27;;\n\n\n前缀索引查询流程：\n\n5.12 单列索引和联合索引\n联合索引情况：\n\n5.13 小结6、索引设计原则\n1.针对于数据量较大，且查询比较频繁的表建立索引。2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。6.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。\n\n19-SQL优化1、插入优化\n\nmysql --local-infile -u root -p1234set global local_infile =1;load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\\n&#x27;;\n\n\n\n插入数据时可以做哪些优化？\n批量插入数据\n单条INSERT语句插入多行数据：使用一条INSERT语句插入多条记录，减少与数据库的交互次数。\n分批次插入：将数据分成多个批次进行插入，每个批次使用事务提交，避免一次性插入过多数据导致性能问题。\n\n事务管理\n手动控制事务：通过手动开启和提交事务，减少事务的开销。\n批量提交：在插入大量数据时，设置合适的批次大小，进行批量提交，减少事务提交的次数。\n\n主键优化\n主键顺序插入：顺序插入主键可以减少页分裂，提高插入性能。\n\n引擎选择\n选择合适的存储引擎：在需要大量插入数据时，可以考虑使用MyISAM引擎，其插入性能优于InnoDB引擎。\n\n使用LOAD DATA INFILE\n从文件导入数据：使用LOAD DATA INFILE命令从文本文件导入数据，这是MySQL中最快的数据导入方式。\n\nJDBC批量插入优化\n开启rewriteBatchedStatements参数：在JDBC连接中设置rewriteBatchedStatements=true，以优化批量插入性能。\n\nMyBatis批量插入\n使用MyBatis的批量插入功能：结合ExecutorType.BATCH和事务管理，提高插入效率。\n\n调整MySQL配置\n增加max_allowed_packet：适当增加max_allowed_packet参数的值，避免因数据包过大导致的错误。\n\n\n2、主键优化数据组织方式\n\n页分裂\n\n\n页合并：\n\n主键设计原则：\n\n满足业务需求的情况下，尽量降低主键的长度。\n插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。\n尽量不要使用 uuid做主键或者是其他自然主键，如身份证号。\n业务操作时，避免对主键的修改。\n\n\n3、order by优化\n\nexplain select phone,age from tb_user order by phone,age desc;create index idx_user_phone_age on tb_user(phone,age desc);\n\n\n\n\n\n\n\n4、group by 优化\n5、limit 优化6、count 优化\n\n7、update 优化\n总结：一、插入优化（INSERT Optimization）问题：批量插入慢、I&#x2F;O压力大优化方案：\n-- 1. 批量插入代替单条插入（减少事务提交）INSERT INTO users (name, age) VALUES   (&#x27;Alice&#x27;, 25),   (&#x27;Bob&#x27;, 30),   (&#x27;Charlie&#x27;, 28);  -- 一次插入500-1000条最佳-- 2. 手动提交事务（避免自动提交开销）START TRANSACTION;INSERT INTO logs (content) VALUES (...);INSERT INTO logs (content) VALUES (...);COMMIT;-- 3. LOAD DATA 加速（比INSERT快20倍）LOAD DATA INFILE &#x27;/tmp/data.csv&#x27; INTO TABLE orders FIELDS TERMINATED BY &#x27;,&#x27;;-- 4. 并行插入（MySQL 8.0+）ALTER TABLE orders DISABLE SECONDARY_ENGINES;INSERT /*+ SET_VAR(innodb_thread_concurrency=16) */ INTO orders ...;\n\n\n二、主键优化（Primary Key Optimization）问题：页分裂、写入热点优化方案：\n-- 1. 自增INT主键（避免UUID随机写入导致页分裂）CREATE TABLE users (  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 顺序写入  uuid CHAR(36) NOT NULL UNIQUE);-- 2. 禁止更新主键（导致行移动）UPDATE users SET id = 1001 WHERE id = 100; -- ❌ 禁止-- 3. 主键长度压缩（InnoDB二级索引带主键）CREATE TABLE logs (  id BIGINT AUTO_INCREMENT PRIMARY KEY,   data BLOB) ROW_FORMAT=COMPRESSED;  -- 压缩长主键\n\n\n三、ORDER BY 优化问题：Using filesort 性能瓶颈优化方案：\n-- 1. 最左前缀索引覆盖ALTER TABLE orders ADD INDEX idx_status_amount (status, amount);-- 使用覆盖索引避免回表EXPLAIN SELECT id, amount FROM orders WHERE status = &#x27;paid&#x27; ORDER BY amount;  -- type: index, Extra: Using where-- 2. 文件排序优化SET max_length_for_sort_data = 1024;  -- 控制排序缓冲区SET sort_buffer_size = 8*1024*1024;   -- 增大排序内存-- 3. 倒序索引（MySQL 8.0+）CREATE INDEX idx_amount_desc ON orders (amount DESC);\n\n\n四、GROUP BY 优化问题：Using temporary 临时表优化方案：\n-- 1. 索引优化分组ALTER TABLE sales ADD INDEX idx_store_product (store_id, product_id);EXPLAIN SELECT store_id, COUNT(*) FROM sales GROUP BY store_id;  -- type: range, key: idx_store_product-- 2. 关闭隐式排序（MySQL 8.0+）SELECT product_id, SUM(quantity) FROM sales GROUP BY product_id ORDER BY NULL;  -- 避免排序开销-- 3. 大表分组优化（分段聚合）SELECT SUM(cnt) FROM (  SELECT store_id, COUNT(*) AS cnt  FROM sales WHERE store_id BETWEEN 1 AND 100   GROUP BY store_id) tmp;\n\n\n五、LIMIT 优化问题：大偏移量扫描全表优化方案：\n-- 1. 游标分页（基于最后一条ID）SELECT * FROM orders WHERE id &gt; 1000000 ORDER BY id LIMIT 10;  -- 避免 OFFSET-- 2. 延迟关联（覆盖索引+JOIN）SELECT o.* FROM orders oJOIN (SELECT id FROM orders ORDER BY create_time LIMIT 1000000, 10) tmpON o.id = tmp.id;-- 3. 预计算分页（推荐页码限制）SELECT id FROM orders WHERE create_time BETWEEN ? AND ? ORDER BY create_time LIMIT 10;\n\n\n六、COUNT 优化问题：全表扫描慢优化方案：\n-- 1. COUNT(*) vs COUNT(col)SELECT COUNT(*) FROM orders;  -- ✅ 使用星号（无NULL判断）SELECT COUNT(1) FROM orders;  -- 等效COUNT(*)-- 2. 近似计数（允许误差）SHOW TABLE STATUS LIKE &#x27;orders&#x27;;  -- Rows 列（统计估算值）-- 3. 精确计数维护CREATE TABLE counters (  table_name VARCHAR(64) PRIMARY KEY,  cnt BIGINT UNSIGNED NOT NULL);-- 通过触发器/事务维护计数\n\n\n七、UPDATE 优化问题：行锁膨胀、索引更新代价优化方案：\n-- 1. 索引条件更新（避免全表锁）UPDATE orders SET status = &#x27;shipped&#x27; WHERE order_id = 1001;  -- 主键条件-- 2. 分批更新（减少长事务）SET @rows=1;WHILE @rows &gt; 0 DO  UPDATE orders SET price = price*1.05   WHERE create_date &lt; &#x27;2023-01-01&#x27;   LIMIT 1000;  SET @rows = ROW_COUNT();END WHILE;-- 3. 避免更新索引列UPDATE products SET   view_count = view_count + 1,  -- ✅ 非索引列  title = CONCAT(title, &#x27;!&#x27;)    -- ❌ 索引列（触发索引重建）WHERE id = 101;\n\nmysql 管理1、初始数据库MySQL 安装完成后自带的 information_schema、mysql、performance_schema、sys 四个数据库各自承担核心系统功能，以下是详细解析：\n1.1 information_schema：元数据信息库核心作用：存储 MySQL 服务器中所有数据库对象的元数据（结构信息），是只读视图集合（无实际物理文件）。  \n\n关键内容：  \n数据库、表、列、索引、视图、存储过程、函数、触发器的定义；  \n用户权限、表字符集、排序规则等。\n\n\n典型表：  \nSCHEMATA：所有数据库的基本信息（名称、字符集等）；  \nTABLES：所有表的信息（表名、存储引擎、行数等）；  \nCOLUMNS：表的列信息（数据类型、默认值、是否允许空等）；  \nSTATISTICS：索引信息（索引名、类型、唯一性等）。\n\n\n使用场景：  \n开发工具自动生成数据库文档（如表结构导出）；  \n程序动态获取表结构（如 ORM 框架自动建表）；  \n替代 SHOW TABLES&#x2F;SHOW COLUMNS 等命令（更灵活，支持 SQL 过滤）。\n\n\n特点：  \n数据由 MySQL 自动维护，禁止手动修改；  \n是 SQL 标准定义的“数据字典”（类似 Oracle 的 ALL_TABLES）。\n\n\n\n1.2 mysql：系统数据库核心作用：存储 MySQL 服务器的系统级配置与状态信息，是 MySQL 运行的基础。  \n\n关键内容：  \n用户账户与权限（user 表存储用户密码、权限；db&#x2F;tables_priv 表存储数据库&#x2F;表级权限）；  \n系统变量（global_variables 表存储 innodb_buffer_pool_size 等配置）；  \n存储过程、函数、事件（proc&#x2F;event 表）；  \nInnoDB 系统表（innodb_system 存储表空间、索引元数据）；  \n时区信息（time_zone 表）。\n\n\n使用场景：  \n管理用户权限（如 CREATE USER&#x2F;GRANT 会修改 user&#x2F;db 表）；  \n调整系统参数（如 SET GLOBAL innodb_buffer_pool_size=1G 会更新 global_variables）；  \n维护 InnoDB 表空间（如 ALTER TABLE ... IMPORT TABLESPACE 依赖 innodb_system）。\n\n\n特点：  \n严禁随意修改表结构（可能导致 MySQL 崩溃）；  \n升级 MySQL 时需特别注意该数据库的兼容性。\n\n\n\n1.3 performance_schema：性能监控库核心作用：实时采集 MySQL 服务器的性能指标与运行时事件，用于诊断性能瓶颈。  \n\n关键内容：  \nSQL 语句执行统计（events_statements_summary_by_digest 记录 SQL 执行次数、耗时）；  \n锁与事务信息（metadata_locks 记录元数据锁；innodb_lock_waits 记录 InnoDB 行锁等待）；  \n等待事件（wait_classes_global_by_avg_latency 统计各类等待事件的平均延迟）；  \n线程与连接（threads&#x2F;sessions 记录当前连接的状态）。\n\n\n使用场景：  \n定位慢查询（通过 events_statements_summary_by_digest 筛选高耗时 SQL）；  \n诊断锁冲突（如 SELECT * FROM performance_schema.metadata_locks WHERE locked_by != &#39;&#39;）；  \n分析资源消耗（如 SELECT * FROM performance_schema.file_summary_by_instance 查看 IO 消耗）。\n\n\n特点：  \n数据存储在内存中，服务器重启后丢失；  \n开销极低（默认开启，对性能影响&lt;5%）；  \n是 MySQL 5.5+ 引入的“内置性能侦探”。\n\n\n\n1.4 sys：简化性能诊断的工具库核心作用：基于 information_schema 和 performance_schema 封装易用的视图与存储过程，降低性能分析门槛。  \n\n关键内容：  \n性能视图（sys.schema_table_statistics 显示表的行数、大小、索引效率；sys.session 显示当前会话的详细状态）；  \n锁诊断（sys.innodb_lock_waits 整合锁等待信息，支持一键杀死阻塞事务）；  \n存储过程（sys.sql_kill_blocking_connection() 终止阻塞连接；sys.config() 调整性能监控参数）；  \n原始数据视图（带 x$ 前缀的视图保留原始单位，如 x$wait_classes_global_by_avg_latency）。\n\n\n使用场景：  \n快速查看表统计信息（SELECT * FROM sys.schema_table_statistics WHERE table_schema=&#39;your_db&#39;）；  \n分析 IO 消耗（SELECT * FROM sys.io_global_by_file_by_bytes）；  \n一键处理锁阻塞（CALL sys.sql_kill_blocking_connection(阻塞线程ID)）。\n\n\n特点：  \nMySQL 5.7+ 默认存在（5.6 需手动安装）；  \n完全依赖 information_schema 和 performance_schema，本身不存储数据；  \n是 DBA 日常运维的“瑞士军刀”。\n\n\n\n1.5 小结：协作关系\n\n\n数据库\n定位\n数据来源\n典型用途\n\n\n\ninformation_schema\n元数据“字典”\n数据库对象定义\n查结构、生成文档\n\n\nmysql\n系统配置中心\n权限、变量、InnoDB元数据\n用户管理、系统调优\n\n\nperformance_schema\n性能监控“黑匣子”\n运行时事件、锁、SQL统计\n慢查询、锁冲突、资源消耗分析\n\n\nsys\n性能诊断“工具包”\n基于前两者的视图封装\n快速定位问题、一键运维\n\n\n通过这四个数据库的协作，MySQL 实现了**“结构管理→系统配置→性能监控→诊断优化”**的完整闭环。\n2、常用工具举例说明常见的mysql管理工具，并说明作用mysql客户端、mysqladmin、mysqlbinlog、mysqlshow、mysqldump、mysqlimport  和 source\n\n\n\n工具\n主要场景\n\n\n\nmysql\n日常数据库操作&#x2F;脚本执行\n\n\nmysqldump\n数据备份&#x2F;迁移\n\n\nmysqlbinlog\n数据恢复&#x2F;审计\n\n\nmysqladmin\n服务器状态监控&#x2F;管理\n\n\nmysqlshow\n快速查看数据库结构\n\n\nmysqlimport\n批量数据导入\n\n\nsource\n恢复备份&#x2F;执行大型SQL脚本\n\n\n1.mysql（命令行客户端工具）\n作用：\n\n连接 MySQL 服务器并执行 SQL 命令\n支持批处理脚本操作\n远程连接管理数据库\n\n2.mysqladmin（管理客户端）\n作用：\n\n检查服务器状态和配置\n创建&#x2F;删除数据库\n刷新权限&#x2F;日志\n关闭服务器\n\n3.mysqlbinlog（二进制日志工具）\n作用：\n\n解析二进制日志文件（binlog）\n数据恢复和审计\n主从复制故障排查\n\n4.mysqlshow（元数据查看工具）\n作用：\n\n显示数据库&#x2F;表&#x2F;列结构\n统计数据库对象信息\n快速查看表状态\n\n5.mysqldump（数据备份工具）\n作用：\n\n逻辑备份数据库\n生成 SQL 格式转储文件\n支持全库&#x2F;单库&#x2F;单表备份\n\n6.mysqlimport（数据导入工具）\n作用：\n\n批量导入文本文件数据\n高效加载分隔符格式数据\n与 mysqldump 的 -T 选项配对使用\n\n7.source（SQL 脚本执行命令）\n作用：\n\n在 MySQL 客户端内执行 SQL 脚本\n恢复 mysqldump 备份\n批量执行 DDL&#x2F;DML 语句\n\n2.1 mysql客户端mysql该 mysql不是指 mysql服务，而是指 mysql的客户端工具。语法：mysql [options]database]选项：-u,–user&#x3D; name #指定用户名-p,–password&#x3D; name #指定密码-h,–host&#x3D; name #指定服务器IP或域名-p,–port&#x3D; port #指定连接端口-e,–execute&#x3D; name #执行SQL语句并退出\nmysql- uroot -p1234 db01 -e &quot; select * from stu&quot;;\n\n\n\n\n本地目录下运行cmd（A:\\Programs\\Mysql\\mysql8\\mysql-8.0.23-winx64\\bin）\n-h参数：指定服务器 ip地址\n当前登录的是 192.168.242.129 服务器的 mysql 数据库\nmysql -h192.168.242.129 -uroot -p1234 #连接虚拟机的数据库mysql -uroot -proot #登录本地mysql\n\n\n\n-e 可以在mysql客户端执行SQL语句，不用连接到mysql数据库再执行，对于一些批处理脚本，这种方式尤其方便\n-e参数：执行sql语句，并退出\n登录数据库，执行指定库下的 sql语句，执行完成后输出结果，并退出数据库。\nmysql -uroot -proot test -e &quot;select * from c_dept&quot;;\n\nmysql -h192.168.242.129 -uroot -p1234 sc0701 -e &quot;select * from c_teacher where tno=1&quot;\n\n\n2.2 mysqladminmysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态，创建并删除数据库等。\n通过帮助文档查看选项：\nmysqladmin --help\n\n\n查看当前数据库的版本：\nmysqladmin -uroot -p1234 version\n\n\n删除指定的数据库：\nmysqladmin -uroot -p1234 drop &quot;db&quot;\n\n\n2.3 mysqlbinlog由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具。\n语法：\tmysqlbinlog[ options] log-files1 log-files2…\n选项：-d, –database&#x3D; name \t指定数据库名称，只列出指定的数据库相关操作。-o, –offset&#x3D;# \t忽略掉日志中的前n行命令。-r, –result-file&#x3D; name \t将输出的文本格式日志输出到指定文件。-s, –short-form \t显示简单格式，省略掉一些信息。– start-datatime&#x3D;date1 –stop-datatime&#x3D; date2 \t指定日期间隔内的所有日志。– start-position&#x3D;pos1 –stop-position&#x3D;pos2 \t指定位置间隔内的所有日志。\n显示MySQL服务器的系统变量：\nmysqladmin -uroot -proot variables\n\n\nll /var/lib/mysql #查看binlog日志文件在哪里\n\n\n查看指定的binlog日志文件：\nmysqlbinlog /var/lib/mysql/binlog.000005\n\n\n-d参数：查看指定的数据库日志：\nmysqlbinlog -d sc0701 /var/lib/mysql/binlog.000005\n\n\n2.4 mysqlshowmysqlshow客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。语法：\tmysqlshow [options] [db_name] [table_name[col_name]]]选项：–count\t显示数据库及表的统计信息(数据库，表均可以不指定)\ni\t显示指定数据库或者指定表的状态信息\n示例：\n#查询每个数据库的表的数量及表中记录的数量mysqlshow -uroot -p2143 --count#查询test库中每个表中的字段数，及行数mysqlshow -uroot -p1234 test --count#查询test库中book表的详细情况mysqlshow -uroot -p1234 test --count\n\n\n\n统计 mysql中的库：有多少表，有多少行数据：\nmysqlshow -uroot -p1234 --count \n\n\n统计指定数据库中有哪些表，表中有哪些字段，表中的数据行：\nmysqlshow -uroot -p1234  sc0701 --count \n\n\n统计指定表的信息：\nmysqlshow -uroot -p1234  sc0701  c_teacher --count \n\n\n2.5 mysqldumpmysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。\n语法：\tmysqldump [options] db_name[tables]\tmysqldump [options]–database&#x2F;-B db1[db2 db3…]\tmysqldump [options]–all-databases&#x2F;-A\n连接选项：-u, –user&#x3D;name\t指定用户名-p, –password[&#x3D; name]\t指定密码-h, –host&#x3D;name\t指定服务器ip或域名-P, –port&#x3D;#\t指定连接端口(本地默认3306)\n输出选项：–add-drop-database\t在每个数据库创建语句前加上drop database语句–add-drop-table\t在每个表创建语句前加上drop table语句，默认开启；不开启(–skip-add-drop-table)-n, –no-create-db\t不包含数据库的创建语句-t, –no-create-info\t不包含数据表的创建语句-d –no-data\t不包含数据-T, –tab&#x3D;name\t自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件\n数据库备份（备份指定数据库）\nmysqldump -h192.168.242.129 -uroot -p1234 sc0701  &gt; A:\\sc0701.sql\n\n\n备份指定库下的指定表：\nmysqldump -h192.168.242.129 -uroot -p1234 sc0701 c_teacher &gt; A:\\c_teacher.sql\n\n\n查看允许导出的目录：\nshow variables like &#x27;secure_file_priv&#x27;;\n\n\n将数据库s0701中的表和表中的数据导入到指定目录\nmysqldump -uroot -p1234 -T /var/lib/mysql-files/ sc0701\n\nll /var/lib/mysql-files/\n\n每一张表会生成两个文件：sql文件备份结构.txt文件备份数据\n\n查看备份目录下的sql文件：\ncat /var/lib/mysql-files/c_dept.sql\n\n\n恢复数据：\nmysql --local-infile -uroot -p1234 #登录时添加 --local-infile 表示允许加载本地文件\n\n -- 开启 加载本地文件set global local_infile=1;-- 加载本地文件-- terminated by &#x27;,&#x27;  指定数据的分隔符load data local infile &#x27;/root/tb_user_200w&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\\n&#x27;;\n\n\n\n2.6 mysqlimport  和 sourcemysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件。语法：mysqlimport[options] db name textfile1[textfile2…]示例：\nmysqlimport -uroot -p1234 test /tmp/city.txt\n\n如果需要导入sql文件，可以使用mysql中的source指令：\n语法：source &#x2F; root&#x2F; xxxx. sql\n先选择数据库sc0701,导入表结构：\n注意：source时sql命令\nsource /var/lib/mysql-files/c_teacher.sql\n\n\n再导入数据：\nmysqlimport -uroot -p1234 sc0701 /var/lib/mysql-files/c_teacher.txt\n\n\n数据库锁1、锁概述1.1 为什么需要锁\n多用户同时操作数据库时，可能出现 脏读、不可重复读、幻读 等问题。\n示例：\n事务 A 修改数据，事务 B 读取未提交的脏数据（脏读）；\n事务 A 更新期间，事务 B 重复读数据却得到不同结果（不可重复读）；\n事务 A 插入数据，事务 B 查询时 “看到” 不存在的新数据（幻读）。\n\n\n\n1.1 介绍锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU 、RAM 、I&#x2F;O）的争用以外，数据也是  一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访 问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\n定义：  数据库锁是 数据库管理系统（DBMS）用于协调并发事务对共享资源访问的机制，通过 “锁资源” 实现 互斥或共享访问，保证数据一致性。 \n1.2 分类MySQL中的锁，按照锁的粒度分，分为以下三类：\n\n全局锁：锁定数据库中的所有表。\n\n表级锁：每次操作锁住整张表。\n\n行级锁：每次操作锁住对应的行数据\n\n\n维度 1：按锁的粒度（锁定范围）\n\n\n\n锁类型\n锁定范围\n并发能力\n开销\n典型场景\n\n\n\n表锁\n整个表\n低\n小\n全表更新（如 ALTER TABLE）\n\n\n页锁\n数据页（磁盘块）\n中\n中\n早期数据库（如 MySQL MyISAM）\n\n\n行锁\n单行记录（基于索引）\n高\n大\n高频单行更新（如 InnoDB）\n\n\n示例：\n\n表锁：LOCK TABLES user WRITE;（禁止其他事务读 &#x2F; 写）；\n行锁：InnoDB 中 UPDATE user SET balance=100 WHERE id=1;（仅锁定 id&#x3D;1 的行）。\n\n维度 2：按锁的类型（访问权限）\n（1）共享锁（Shared Lock，S 锁）\n\n特性：允许多个事务同时加锁，用于 只读操作（如 SELECT ... LOCK IN SHARE MODE）；\n互斥规则：S 锁与 S 锁兼容（可共享），但与 排他锁（X 锁）互斥。\n\n（2）排他锁（Exclusive Lock，X 锁）\n\n特性：禁止其他事务加锁，用于 修改操作（如 INSERT/UPDATE/DELETE 自动加 X 锁）；\n互斥规则：X 锁与 所有锁（S&#x2F;X）互斥（独占资源）。\n\n兼容矩阵：\n\n\n\n\nS 锁（读）\nX 锁（写）\n\n\n\nS 锁\n兼容\n冲突\n\n\nX 锁\n冲突\n冲突\n\n\n维度 3：按锁的模式（辅助管理）\n以 InnoDB 为例，引入 意向锁 快速判断表级锁与行级锁的冲突：\n\n意向共享锁（IS 锁）：事务计划对行加 S 锁，先在表上加 IS 锁；\n意向排他锁（IX 锁）：事务计划对行加 X 锁，先在表上加 IX 锁。\n\n作用：避免全表扫描判断行锁冲突（通过表级意向锁快速决策）。\n维度 4：按锁的算法（InnoDB 行锁细节）\nInnoDB 的行锁基于 索引 实现，细分三类算法（解决幻读问题）：\n\n记录锁（Record Lock）：锁定 具体行记录（如 WHERE id=1，锁定 id&#x3D;1 的行）；\n间隙锁（Gap Lock）：锁定 索引区间（如 WHERE id BETWEEN 1 AND 5，锁定 (1,5) 的间隙，防止插入新数据）；\n临键锁（Next-Key Lock）：记录锁 + 间隙锁（默认模式，如锁定 id&#x3D;5 及之前的间隙，解决幻读）。\n\n2、全局锁2.1 介绍​    全局锁就是对整个数据库实例加锁，加锁后整个数据就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\n\n2.2 演示 \nflush tables with read lock;\n\n\n\n使用 cmd 登录 mysql 演示\nmysql -h192.168.242.129 -uroot -p1234\n\n\n\n\n2.3 特点数据库中加全局锁，是一个比较重的操作，存在以下问题：1.如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。2.如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。\n在InnoDB引擎中，我们可以在备份时加上参数–single-transaction 参数来完成不加锁的一致性数据备份。\nmysqldump --single-transaction - uroot -proot itpan &gt; itpan.sql\n\n\n\n2.4 小结1、全局锁的作用对整个数据库实例加锁，加锁后整个数据就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\n作用本质通过 FLUSH TABLES WITH READ LOCK 命令冻结 整个数据库实例，进入全局只读状态。\n阻塞对象✅ 所有 DML 写操作：  \n\nINSERT&#x2F;UPDATE&#x2F;DELETE  \n带写操作的 SELECT ... FOR UPDATE✅ 所有 DDL 操作：  \nCREATE&#x2F;ALTER&#x2F;DROP✅ 未提交事务的提交请求：  \n显式提交的 COMMIT  \n隐式提交的 DDL 语句\n\n核心场景  \n\n数据备份  \n\n确保备份文件数据与元时间点一致（物理备份如 mysqldump）  \n非事务引擎（如 MyISAM）的唯一安全备份方式\n\n\n主从协调  \n\n精确获取 binlog 位置点：  \nFLUSH TABLES WITH READ LOCK; -- 锁库SHOW MASTER STATUS;          -- 记录 File/PositionUNLOCK TABLES;               -- 立即释放\n\n\n高危维护  \n\n系统表修复（如 mysql.user）  \n全局级字符集变更\n\n\n\n2、使用全局锁的弊端是什么？怎么解决在数据库上添加全局锁，那么在备份期间都不能执行更新操作，那么业务基本上就得停摆解决方式：使用主从复制， 在从库上添加全局锁，备份从库数据（）\n\n\n\n3、表级锁3.1 介绍​    表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MySAM、InnoDB、DB等存储引擎中。\n对于表级锁，主要分为以下三类：\n\n表锁\n\n元数据锁（ meta data lock ，MDL）\n\n意向锁\n\n\n3.2 表锁\n读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。\n演示共享读锁\n\n\n演示独占写锁\n\n\n3.3 元数据锁(meta data lock, MDL)MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。\nMDL锁主要作用是维护表元数据的一致性，在表上有活动事件的时候，不可以对元数据进行写入操作。为了避免DML与DL冲突，保证读写的正确性。\n在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。\n\n分类：\n\n元数据（共享）读锁\n元数据（共享）写锁\n元数据排他锁\n\n元数据共享读锁 和 元数据共享写锁是兼容的元数据共享读锁、元数据共享写锁 两者 和 元数据排他锁都是互斥的\n\n\n\n演示：\n共享读锁和共享写锁兼容\n\n共享写锁和排他锁也是互斥的\n\n共享读锁 和 排他锁 互斥\n\n查看元数据锁\nselect object_type, object_schema, object_name,lock_duration from performance_schema.metadata_locks;\n\n\n\n元数据锁（MDL）的作用\nMySQL 的 元数据锁 用于保护 表结构（元数据） 不被并发修改，确保以下场景的一致性：\n\n当事务查询表数据时，防止其他事务同时执行 ALTER TABLE 修改表结构；\n保护列统计信息（用于优化器生成执行计划）不被并发更新。\n\n字段解析\n\n\n\n字段名\n含义\n\n\n\nobject_type\n锁保护的对象类型（如 TABLE 表、SCHEMA 数据库、COLUMN STATISTICS 列统计）\n\n\nobject_schema\n对象所属的数据库（此处均为 performance_schema，MySQL 的性能监控数据库）\n\n\nobject_name\n具体的对象名称（如表名、统计信息关联的表名；SCHEMA 类型无具体对象，故为 NULL）\n\n\nlock_duration\n锁的持续时间： - TRANSACTION：锁在事务周期内保持（事务提交 &#x2F; 回滚后释放）； - STATEMENT：锁在语句执行周期内保持（语句结束后释放）。\n\n\n\n3.4 意向锁​    为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。\n\n1**.意向共享锁(IS)**：由语句select…lock in share mode添加。2.意向排他锁(IX)：由insert、update、delete、select…for update添加。\n\n\n1.意向共享锁(IS)：与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。2.意向排他锁(IX)：与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。\n可以通过以下 sql，查看意向锁及行锁的加锁情况：\nselect object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;\n\n\n\n演示 意向共享锁\n\n\n演示意向排他锁\n\n意向锁的核心作用：\n为了避免 DML 在执行时，加的行锁与表锁冲突，在 InnoDB 引擎中引入了意向锁可以使表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查\n\n\n\n4、行级锁4.1 介绍行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度应用。应用在InnoDB存储引擎中。\nInnoDB的数据是基于锁行的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录级的锁。\n对于行级锁，主要分为以下三类：1.行锁(Record Lock)：锁定索引记录间隙（不含该记录），确保索引记录间隙不被删除，防止其他事务在这个间隙进行 insert，产生幻读。在幻读高级别下支持。2.间隙锁(Gap Lock)：锁定间隙和同级锁，同时锁住数据，并锁住数据前面的间隙。在InnoDB高级别下支持。\n3.临键锁(Next-KeyLock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。\n\nInnoDB实现了以下两种类型的行锁：1.共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。2.排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。\n\n\n4.2 演示默认情况下, InnoDB在REPEATABLE READ事务隔离级别运行, InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。\n1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。\n2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。\n可以通过以下 sql，查看意向锁及行锁的加锁情况：\nselect object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;\n\n\n\n演示行共享锁\n\n\n演示 行排他锁\n\n非索引键添加行锁会升级为表锁：\n\n\n\n间隙锁&#x2F;临键锁-演示默认情况下, InnoDB在REPEATABLE READ事务隔离级别运行, InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。1.索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。2.索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。3.索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。\n\n​    注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。\n\n\n6、锁分类小结\n全局锁：锁住数据库示例，一般用于数据备份\n表级锁：锁住表的\n表锁\n表共享读锁：都可以读，都不可以写\n表独占写锁：当前客户端可以写，可以读；其它客户端不能读，不能写\n\n\n元数据锁（自动添加）\n元数据共享读锁：\n元数据共享写锁：\n元数据排他锁：（alter 语句添加元数据排他锁，和其它两个元数据共享锁互斥）\n\n\n\n\n行级锁\n行锁\n共享锁\n排他锁\n\n\n间隙锁\n临键锁\n\n\n\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"Oracle笔记(总)","url":"/2025/09/18/Oracle%E7%AC%94%E8%AE%B0(%E6%80%BB)/","content":"数据库介绍1、数据库介绍1.1 数据库英文：Database\n简单的说，数据库就是一个存放数据的仓库，在日常工作中，常常需要把相关的数据放进这样的仓库，并根据管理的需要进行相应处理。\n1.2 数据库规范数据库中的数据都有一定规律结构，相同类型的数据放在一起，不同类型的数据之间相互隔离\n数据库由统一的规则来读写：由SQL语言专门来读写数据库，一般都是由程序来读写数据库内容\n1.3 常用数据库常用的数据库有：DB2、Oracle、Mysql、SQL server、SQLite\n1.4 数据库分类根据存储模型可以将数据库划分为【关系型数据库】和【非关系型数据库】\n关系型数据库：是建立在关系模型基础上的数据库，简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。\n标准数据查询语言SQL就是一种基于关系型数据库的语言，这种语言执行对关系型数据库中数据的检索和操作\n什么是二维表：有行有列的表格，例如 Excel\n关系型数据库（表与表之间有关系：体现为主外键）\n\n\n\n分类\n产品\n特点\n\n\n\n小型\naccess、foxbase\n负载量小，用户大概100人以内（留言板、信息管理系统）；成本在千元之内，对安全性要求不高\n\n\n中型\nsqlserver、mysql\n负载量日访问量在5000~10000之间；成本在万元以内（商务网站），满足日常安全需求\n\n\n大型\nsybase、db2、oracle\n海量负载，可以处理海量数据（sybase &lt;Oracle&lt;db2 海量处理能力）；安全性高，相对贵\n\n\n1.5 数据库管理系统\n简称：DBMS\n数据库管理系统（Database Management System）是一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS,他对数据库进行统一的管理和控制，以保证数据库的安全性和完整性，用户通过DBMS访问数据库中的数据，数据库管理员也通过DBMS进行数据库的维护工作。它可以使多个应用程序和用户用不同的方法在同一时刻或不同时刻去建立、修改和访问数据库。\n数据库和数据库管理是一个东西吗？\n\n数据库：存储数据的地方（就是一些数据文件而已）\n\n数据库管理系统：用来管理数据以及用户操作数据的软件\n\n\n2 、Oracle介绍\n2.1 Oracle Database又叫 Oracle RDBMS，或者简称 Oracle，是甲骨文公司的一款关系型数据库管理系统，平常所说的Oracle是指Oracle数据管理系统。Oracle数据库管理系统是管理数据库访问的计算机软件（Oracle Database Manager System）。\n它由 Oracle数据库和Oracle实例（instance） 构成（区分mysql，mysql没有实例的概念）。\n2.2 Oracle数据库物理操作系统文件或磁盘的集合。Oracle数据库包括 数据文件ORA或者DBF、控制文件、联机日志、参数文件。\n2.3 Oracle实例位于物理内存的数据结构，他只是一个后台进程，或者一个后台资源的集合，通过这个后台进程可以连接上某一个数据库。\nOracle用他们来管理数据库访问，用户如果要存取数据库里的数据（也就是硬盘上的文件），必须通过Oracle实例才能实现，不能直接读取硬盘上的文件。\n实际上，Oracle实例就是平常所说的数据库服务（service）。\n在任何时刻，一个实例只能与一个数据库关联，访问一个数据库；而同一个数据库可由多个实例访问（RAC）\n2.4 表空间表空间是一个用来管理数据存储的逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属于一个表空间（类似于windows中的文件夹，里面可以放很多文件）\n作用：方便存储管理，提高IO性能，备份和恢复\n分类：永久性、临时性、撤销表空间\n2.5 用户用户是在实例下建立的，不同实例可以建相同名字的用户\nOracle数据库建好后，要想在数据库里面建表，必须先为数据库建立用户，并且为用户指定表空间\n有两个默认的用户 sys 和 system\n\n\n\n用户\nSYS\nSYSTEM\n\n\n\n地位\nOracle的一个超级用户\nOracle默认的系统管理员\n\n\n作用\n主要用来维护系统信息和管理实例\n通常用来管理Oracle数据库的用户、权限和存储等\n\n\n登陆身份\n只能以SYSDBA或SYSOPER角色登录\n可以以Normal方式登录\n\n\n2.6 权限不同的用户拥有不同的权限\n权限：权限指执行特定类型SQL 命令或访问其他对象的权利\n系统权限和对象权限：\n\n系统权限：允许用户执行某些数据库操作，如创建表就是一个系统权限\n\n对象权限：允许用户对数据库对象（如表、视图、序列等）执行特定操作\n\n\n2.7 角色为了简化权限管理，引入了角色的概念角色： 是具有名称的一组权限的组合\n常用系统预定义角色有三个：\n\nCONNECT：临时用户，只能登录系统\n\nRESOURCE：更为可靠和正式的用户，可以 进行数据库的大部分操作\n\nDBA：数据库管理员角色，拥有管理数据库的最高权限\n\n\n2.8 表有了数据库、表空间和用户，就可以用自定义的用户在自己的表空间中创建表了，有了表就可以存储数据了\nOracle、MySQL、 sqlserver 关系型数据库都是以二维表存储数据的数据库\n**二维表：**指的是有行和列的表格\n2.9 数据文件数据文件是数据库的物理存储单位，数据库的数据是存储在表空间中的，真正是在某一个或多个数据文件中，而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间，一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只有删除其所属的表空间才行\n一、DDL1、创建表空间Create Tablespace my_tablespaceDatafile &#x27;C:\\Users\\Pan\\Desktop\\sc250701\\oracle\\my_tablespace.dbf&#x27; -- 数据文件 文件路径Size 100m     -- 文件大小Autoextend On Next 32m Maxsize Unlimited;  -- 文件大小达到最大的时候，自动扩容\n\n删除表空间-- Drop Tablespace my_tablespace;   -- 删除无任何数据对象的表空间Drop Tablespace my_tablespace Including Contents And  Datafiles; -- 删除有数据对象的表空间\n\n2、创建用户Create User pan  -- 用户名Identified By root  -- 密码Default Tablespace my_tablespace;  -- 默认表空间\n\n3、分配权限\nconnect： 临时用户\n\nresource：更为可靠的正式用户\n\ndba：数据库管 理员角色\nGrant Connect,Resource,Dba To pan; \n\n4、创建teacher表Create Table teacher ( tno Number(4) Not Null, tname Varchar2(50) Not Null, tid Char(18), gender Char(2), birthday Date);\n\n5、添加主键约束\n设置tno字段为 主键约束（oracle中没有主键自增）\n\nALTER TABLE teacher ADD constraint pk_teacher_tno PRIMARY KEY(tno);\n\n6、删除约束ALTER TABLE TEACHER DROP constraint pk_teacher_tno;\n\n7、添加检查约束ALTER TABLE teacher ADD constraint ck_teacher_gender CHECK(gender IN (&#x27;男&#x27;,&#x27;女&#x27;));INSERT INTO TEACHER VALUES(101,&#x27;赵辉&#x27;,&#x27;362326197805281911&#x27;,&#x27;男&#x27;,NULL);\n\n8、创建表的时候添加 约束CREATE TABLE dept(  id NUMBER(6),  dname VARCHAR2(255),  loc VARCHAR2(255),  constraint uq_dname UNIQUE(dname), -- 唯一约束  constraint pk_id PRIMARY KEY(id) -- 主键约束);\n\n9、drop，truncate，deleteDROP TABLE dept;DELETE FROM TEACHER WHERE tno=101;truncate TABLE TEACHER;\n\n\n\noracle 数据类型1、字符型  1.1 char 类型：固定长度字符串，位数不足时默认补空格  1.2 varchar2 类型：可变长字符串\n2、数值类型  number：整数和浮点数，最多存储38位数字  语法：number(p,s)\n\np：表示精度（总长度）\n\ns：表示小数位（四舍五入）例如：3.14159 → 3.142\n\n\n例如：number(10,3) 表示总长度为10，小数位长度3\n\n  123.456 -&gt; 123.456123.4567 -&gt; 123.4571234567.8987 -&gt; 1234567.89912345678.8989 存不进，总长度为10，小数位占3，整数位只能是7位\n\n3、日期类型  3.1 date：存储的是 年月日时分秒  3.2 timestamp：存储的是年月日时分秒(秒值包含小数)\n4、lob类型blob：二进制对象，适合存储音视频文件、图形文件等数据clob：字符格式的大型对象，适合存储长文本数据\n二、DML1、序列序列 sequence：是 oracle 提供的用于产生一系列唯一数字的数据库对象\n创建语法：\n\n​\tcreate sequence 序列名称   –创建序列\n\n[start with n] –序列的起始值 (递增默认是 minvalue, 递减默认 maxvalue)\n[increment by n]; –递增的序列值\n\n\n注意：名称一般以 sq_ 开头\n使用序列：\n\n序列名.currval – 查询当前值\n序列名.nextval – 获取下一个值\n\n注意：第一次使用序列，必须使用 nextval\n创建序列  创建 起始值为1001，每次递增1的序列\nCREATE sequence sq_teacherSTART WITH 1001INCREMENT BY 1; -- 默认为1 可以不写\n\n\n\n2、dual 虚拟表作用：本身不存储数据，为了辅助 sql 语句的完整性\nSELECT sq_teacher.nextval FROM dual;SELECT sq_teacher.currval FROM dual;\n\n\n\n3、INSERTINSERT INTO TEACHER(tno,tname) VALUES(sq_teacher.nextval,&#x27;赵辉&#x27;);show variables like &#x27;autocommit&#x27;;\n\n\n\n4、updateUPDATE TEACHER SET tname=&#x27;张三&#x27; WHERE tno=1011;\n\n\n\n5、deleteDELETE FORM TEACHER WHERE tno=1009;\n\n\n\n三、DQLDQL：查询语句1、基础查询SELECT * FROM teacher;SELECT tno FROM teacher;\n\n\n\n2、AS语句 + 单引号 和 双引号的区别SELECT tno AS &quot;教师编号&quot;, tname AS &quot;tName&quot; FROM teacher;\n\n单引号：引用一个字符串常量(字面量)双引号：引用的是关键字，表示对象、字段名、别名等等\n注意：别名加双引号的作用是：区分大小写\nSELECT * FROM TEACHER WHERE tname=&#x27;赵辉&#x27;;SELECT * FROM TEACHER WHERE tname=&quot;赵辉&quot;; -- 报错\n\n\n\n3、去重：DISTINCTSELECT sal FROM TEACHER;SELECT DISTINCT sal FROM TEACHER;\n\n\n\n4、运算符号SELECT tname &quot;姓名&quot;,sal *12 &quot;年薪&quot; FROM TEACHER;\n\n\n\n5、空值处理：NVL 和 COALESCE注意：任何值和null值进行运算，结果都是null\nSELECT tname &quot;姓名&quot;,sal+comm &quot;薪水&quot; FROM TEACHER;SELECT tname &quot;姓名&quot;,sal+NVL(comm,0) &quot;薪水&quot; FROM TEACHER;SELECT tname &quot;姓名&quot;,sal+COALESCE(comm,0) &quot;薪水&quot; FROM TEACHER;\n\n\n\n6、连接符 CONCAT(ch1, ch2) 和 || CONCAT()接收两个参数拼接\nSELECT CONCAT(CONCAT(&#x27;编号是：&#x27;,tno),CONCAT(&#x27;,姓名是：&#x27;,tname)) AS &quot;基本信息&quot; FROM TEACHER;SELECT &#x27;编号是：&#x27;|| tno || &#x27;,姓名是：&#x27;|| tnameAS &quot;基本信息&quot; FROM TEACHER;\n\n\n\n7、子查询exists子查询：\n用于判断子查询是否返回至少一行数据作用：常用于存在性验证、反向筛选(not exists)逻辑：\n\n对主查询的每一行，执行一次子查询，判断子查询是否有结果（大于等于1行）\n\n如果子查询找到第一条匹配的记录，立即停止子查询(短路执行)，直接返回true，主查询会保留该行\n\n如果子查询没有匹配记录，返回false，主查询排除该行\n\n\n语法：\nSELECT 主表字段  FROM 主表  WHERE EXISTS(\tSELECT 1 -- 固定使用1（不查询字段） ， * 也可以，不推荐\tFROM 子查询表\tWHERE mgr.tno = t.mgrno);\n\n注意：select 1 的意义子查询的select列表可以写任意值(select *)，但是select 1更高效（优化器会忽略字段的内容，仅判断存在性）  \nSELECT 1 FROM dual;  \n\n\n\n使用场景（存在性验证）需求：查询有下属（是部门经理）的教师信息\nSELECT mgr.tno &quot;经理编号&quot;, mgr.tname &quot;经理名称&quot;FROM teacher mgr WHERE EXISTS(\tSELECT *\tFROM teacher t\tWHERE mgr.tno = t.mgrno );\n\n（方向筛选）需求：查询没有下属（是部门经理）的教师信息\nSELECT mgr.tno &quot;经理编号&quot;, mgr.tname &quot;经理名称&quot;FROM teacher mgr WHERE NOT EXISTS(\tSELECT 1\tFROM teacher t\tWHERE mgr.tno = t.mgrno );\n\n练习：查询有员工的部门编号和部门名称\nSELECT d.deptno, d.dnameFROM  DEPT dWHERE EXISTS(\tSELECT 1\tFROM EMP e\tWHERE e.deptno=d.deptno);\n\n\n\n8、联合查询UNION 去重  \nUNION ALL 不去重,并集\nSELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1006)UNION SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1007);SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1006)UNION ALLSELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1007);INTERSECT -- 求交集SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1006)INTERSECT -- 求交集SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1007);SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1006)MINUS -- 求第一个查询结果中没有在后面的查询结果中出现的记录SELECT tno, tname, gender FROM teacher WHERE tno IN (1002,1004,1007);-- 1006\n\n\n\n9、分页查询oracle中，提供了伪列：就像一个表列，但是它并没有存储在表中，伪列可以从表中查询，但是不能插入、更新和删除他们的值\n常用的伪列有两种\n(1) rowid：是表中行的存储地址，该地址可以唯一的标识数据库中的一行rowid 是一个18位字符，标识该行在数据库中的相对唯一的物理位置作用：只在数据库内部使用，通常用于快速查找数据行\n了解：18位字符采用 base64编码16：该行数据所在的数据对象id79：该行数据所在的相对数据文件 id1015：该行数据所在的数据块编号1618位：该行数据行编号\nSELECT tname ,ROWID FROM TEACHER;\t\t--rowid表示该行在数据库中的物理地址\n\n​\t\t\n(2) Rownum：分页查询Rownum是查询返回的结果集中行的序号，可以使用它来限制查询返回的行数\n注意事项：\n\n\nrownum 不能以任何基表的名称作为前缀\n子查询中的 rownum 必须要有别名，否则还是不会查出记录（因为 rownum 不是哪个表中的列，如果不起别名，那么不知道 rownum 是于查询的列还是主查寻的列)\nrownum 永远按照默认的顺序生成\nrownum 只能使用**&lt;，&lt;&#x3D;**，不能使用&#x3D;，&gt;，&gt;&#x3D;\n子查询可以间接使用：&#x3D;，&gt;，&gt;&#x3D;\n\n\nSELECT rownum,tno,tname FROM TEACHER;\t-- 查询出 rownum，在结果中显示SELECT t.rownum,t.tno,t.tname FROM TEACHER t; \t-- 报错，不能给rownum加前缀\n\n练习：查询教师表中前5个老师的信息，并且按工资从高到低排序\nSELECT rowid,rownum,tno,tname,sal FROM TEACHER WHERE rownum &lt;= 5ORDER BY sal DESC;\n\n查询第6个老师的信息，查询第6个老师之后的老师信息\nSELECT * from teacher where rownum = 6;  -- 空行SELECT * from teacher where rownum &gt; 6;  -- 空行SELECT t.*, ROWNUM rn from teacher t WHERE rn = 6; -- 报错\n\n解决方式：\n使用子查询，将子查询的结果当做一张表，然后从新的表中查询 rn&#x3D;6\nSELECT * FROM (SELECT t.*, rownum rn FROM TEACHER t) WHERE rn=6SELECT t.*, ROWNUM rn from teacher t WHERE rn = 1;\n\n练习：获取教师表中薪水最高的前5人\n-- 1. 按工资排序-- 2. 将排序好的结果当作表，取前5人SELECT * FROM (\tSELECT *  FROM TEACHER t  ORDER BY sal DESC) \tWHERE rownum &lt; 6;\n\n获取教师表中新水排名第6的老师信息\nSELECT * FROM (\tSELECT t.*,rownum rn  FROM TEACHER t ORDER BY sal DESC ) WHERE rn=6;\n\n获取薪水排名在6~10 的教师信息\nSELECT * FROM ( -- rownum 在 order by 之前执行 -- 先给行加上行号，当作列放到 t 表\tSELECT t.*,rownum rn  FROM TEACHER t ORDER BY sal DESC)WHERE rn BETWEEN 6 AND 10;\n\n使用子查询\nSELECT * FROM (\tSELECT t.*,rownum rn  FROM (\t\tSELECT * FROM TEACHER ORDER BY sal DESC\t) t WHERE rownum &lt;=10 ) WHERE rn &gt;= 6;\t\t\t\t\n\n\n\n–每页查询5条数据，查询第3页使用子查询\nSELECT * FROM (\tSELECT t.*,rownum rn  FROM (\t\tSELECT * FROM TEACHER ORDER BY sal DESC\t) t WHERE rownum &lt;=10 -- 记录数*页码) WHERE rn &gt;= 5;\t\t--记录数 * (页码-1)\n\n练习：查询教师表数据，查第3页，每页查3条数据\nSELECT * FROM (SELECT t.*,rownum rn  FROM  TEACHER t  WHERE rownum &lt;=9 ) WHERE rn &gt;= 6;\t\t\t\n\n\n​\t\n小结：1、mysql中如何实现分页查询\n\n1.在mysql中使用 limit 关键字实现分页查询\n2.limit 关键字后面可以跟 2个参数，第一个参数表示 起始的索引值，第二个参数表示查询的每页记录数\n3.limit 后面也可以只跟一个参数，此时该参数指的是所有记录中的前n条记录（也可以理解位第一页的数据）；\n4.**mysql 8.0 **以后新增了一个分页语法，是 limit 记录数 offset 起始索引\n\n2、oracle中如何实现分页查询oracle 中是通过rownum 伪列和子查询 实现分页查询的\n先通过子查询对数据进行排序，再在外部查询中使用ROWNUM进行分页。\n四、sql函数1、数字函数round() ：四舍五入trunc() ：截断SELECT ROUND(3.14159, 3) FROM dual; -- 3.142 四舍五入SELECT TRUNC(3.14159, 3) FROM dual; -- 3.141 截断SELECT deptno, TRUNC(AVG(sal),2) &quot;avgsal&quot;FROM TEACHER GROUP BY deptno;\n\n\n\n2、字符串函数instr()：​\t查找指定字符在字符串中的第一次出现的位置\n-- 存在，就返回当前字符的位置，不存在，返回0SELECT INSTR(&#x27;Abcdc&#x27;, &#x27;c&#x27;) FROM dual; -- 3SELECT INSTR(&#x27;Aabcdc&#x27;, &#x27;H&#x27;) FROM dual; -- 不存在， 返回 0SELECT INSTR(&#x27;万里长城万里长&#x27;,&#x27;万里&#x27;) FROM dual; -- 1\n\n\n\nsubstr()：​\t截取字符串\nSELECT SUBSTR(&#x27;万里长城万里长&#x27;,0,3) FROM dual; -- 万里长-- 可以从0开始，起始位置 0和1 结果一样SELECT SUBSTR(&#x27;万里长城万里长&#x27;,1,3) FROM dual; -- 万里长\n\n\n\nlength()：​\t字符串长度（mysql 中 length()返回字节长度）\nSELECT LENGTH(&#x27;万里长城万里长&#x27;) FROM dual;  -- 7\n\n\n\nreplace()：​\t替换\nSELECT replace(&#x27;万里长城万里长&#x27;,&#x27;长城&#x27;,&#x27;黄河&#x27;) FROM dual;  -- 万里黄河万里长\n\n\n\nconcat()：​\t拼接两个字符串\nSELECT CONCAT(&#x27;长城&#x27;,&#x27;黄河&#x27;) FROM dual; -- 长城黄河\n\n\n\n3、转换函数3.1 to_char、to_date、to_number\n时间通配符：年： y，四位使用 yyyy月： m，两位使用 mm日： d，两位使用 dd时： h，两位使用 hh，24小时写法：hh24分： mi，代表两位分钟数秒： s，两位使用 ss\n\nmysql中插入日期类型的字段，可以使用日期格式的字符串oracle中不行\n-- mysqlINSERT INTO t_emp(empno, ename, hiredate) VALUES (7777, &#x27;tom&#x27;, &#x27;2025-08-27&#x27;); -- oracle：INSERT INTO emp(empno, ename, hiredate) VALUES (7777, &#x27;tom&#x27;, &#x27;2025-08-27&#x27;); --报错\n\n3.1 日期转换 to_dateSELECT TO_DATE(&#x27;2025-08-07&#x27;, &#x27;yyyy-mm-dd&#x27;) FROM dual;      -- 2025-08-07 00:00:00      SELECT TO_DATE(&#x27;2025-08-07 14:00:00&#x27;, &#x27;yyyy-mm-dd hh:mi:ss&#x27;) FROM dual;   -- 2025-08-07 14:00:00SELECT TO_DATE(&#x27;2025-08-07 20:00:00&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;) FROM dual;   -- 2025-08-07 20:00:00INSERT INTO emp(empno, ename, hiredate) VALUES (7777, &#x27;tom&#x27;, TO_DATE(&#x27;2025-08-07&#x27;, &#x27;yyyy-mm-dd&#x27;)); \n\n符合日期格式的数字也可以转换SELECT TO_DATE(20250807, &#x27;yyyy-mm-dd&#x27;) FROM dual;      -- 2025-08-07 00:00:00SELECT TO_DATE(20250807140000, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;) FROM dual;      -- 2025-08-07 14:00:00\n\n3.2 字符串转换函数 to_char日期转换字符串SELECT SYSDATE FROM dual; -- 系统时间SELECT TO_CHAR(SYSDATE,&#x27;yyyy-mm-dd hh:mi:ss&#x27;) FROM dual;\n\n注意：日期转换为字符串时，特殊的分隔符，需要使用双引号\nSELECT TO_CHAR(SYSDATE,&#x27;yyyy&quot;年&quot;mm&quot;月&quot;dd&quot;日&quot; hh&quot;时&quot;mi&quot;分&quot;ss&quot;秒&quot;&#x27;) FROM dual;    -- 2025年08月27日 04时36分20秒\n\n数字转换字符串格式中的9 代表一个数字，不能换成其他数字\nSELECT TO_CHAR(123456789,&#x27;999,999,999&#x27;) FROM dual;    -- 123,456,789  SELECT TO_CHAR(123456789,&#x27;99,999,999&#x27;) FROM dual; --  ###########，不能匹配到长度\n\n查询教师表中教师信息，工资的整数部分，每三位逗号隔开\nSELECT tno, tname, TO_CHAR(sal, &#x27;999,999.99&#x27;) FROM TEACHER;  -- 29370.95 -&gt; 29,370.95\n\n3.3 数字转换函数 to_numberSELECT TO_NUMBER(&#x27;20&#x27;) + 10 FROM dual;  -- 30SELECT TO_NUMBER(&#x27;abc&#x27;) + 10 FROM dual; -- 报错，要求是数字SELECT &#x27;20&#x27; + 10 FROM dual;  -- 30\n\n\n\n4、日期函数获取当前系统时间 sysdateSELECT SYSDATE FROM dual; -- 2025-08-27 16:48:43mysql：SELECT NOW();\n\n\n\n加减月份计算SELECT ADD_MONTHS(SYSDATE, 1) FROM dual;  -- +1月SELECT ADD_MONTHS(SYSDATE, 5) FROM dual;  -- +的月份超过12，年份进1\n\n-- 返回日期所在月份的最后一天SELECT LAST_DAY(SYSDATE) FROM dual;-- 查询今年的2月份的天数SELECT LAST_DAY(TO_DATE(&#x27;2025-02-01&#x27;, &#x27;yyyy-mm-dd&#x27;))  FROM dual;-- 返回两个时间中间的月份数SELECT TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(&#x27;2003-01&#x27;, &#x27;yyyy-mm&#x27;)),2) FROM dual;\n\n\n\n\n日期计算SELECT SYSDATE + 1 FROM dual;SELECT SYSDATE - 3 FROM dual;\n\n\n\n5、其他函数5.1 空值处理 NVLSELECT tno,tname,sal+NVL(comm,0) AS &quot;薪水&quot; FROM TEACHER;\n\n5.2 decode​\t相当于mysql中case when语法：  decode(条件,值1,返回值1,值2,返回值2... 默认值)\n  匹配不上返回默认值\nSELECT DECODE(10,  10, &#x27;结果为10&#x27;, 20 , &#x27;结果为20&#x27;, &#x27;没有结果&#x27;) FROM dual;  SELECT DECODE(20,  10, &#x27;结果为10&#x27;, 20 , &#x27;结果为20&#x27;, &#x27;没有结果&#x27;) FROM dual;SELECT DECODE(30,  10, &#x27;结果为10&#x27;, 20 , &#x27;结果为20&#x27;, &#x27;没有结果&#x27;) FROM dual; \t-- 没有匹配的，返回默认值\n\n\n\nDECODE 函数的语法和作用是什么？与 CASE WHEN 有何区别?语法：decode(条件,值1,返回值1,值2,返回值2... 默认值)区别: decode 是 oracle 特有函数 ,  CASE WHEN 是 sql标准, 支持复杂逻辑(范围判断)\n五、plsqlplsql是oracle对SQL语言的过程化扩展\nDECLARE   -- 声明  说明部分(声明变量、游标(光标)、异常(意外))BEGIN   -- 开始  sql语句序列(DML)END;  -- 结束\n\n\n\n1、hello worldDECLARE   -- 声明BEGIN  -- 程序开始：可以写SQL语句、选择结构、循环结构...  dbms_output.put_line(&#x27;hello world&#x27;);END;\n\n\n\n2、变量声明变量并赋值\nDECLARE   -- 先声明，后赋值  sname VARCHAR2(10);BEGIN  -- 在执行程序的过程中给变量赋值  sname := &#x27;tom&#x27;;   dbms_output.put_line(sname);END;\n\nDECLARE   -- 初始化变量  sname VARCHAR2(10) :=&#x27;jack&#x27;;BEGIN  dbms_output.put_line(sname);END;\n\n将查询结果赋值给变量\nDECLARE   -- 声明变量  v_tname VARCHAR2(10);BEGIN  SELECT t.tname INTO v_tname     FROM TEACHER t WHERE tno=1002;  dbms_output.put_line(&#x27;姓名是：&#x27;|| v_tname);END;\n\n\n\n\n3、引用变量类型  在声明变量的时候引用表中某一个字段的数据类型  语法：变量名 表名.列名%type\nDECLARE   -- 声明变量  v_tname TEACHER.tname%type;  v_tno TEACHER.tno%type;BEGIN  SELECT t.tno, t.tname INTO v_tno, v_tname     FROM TEACHER t WHERE tno=1002;  dbms_output.put_line(&#x27;编号：&#x27;||v_tno||&#x27; 姓名：&#x27;||v_tname);END;\n\n\n\n4、记录变量类型  记录表中一行的类型  语法：变量名 表名%rowtype;\nDECLARE  p EMP%rowtype; -- 声明变量p，表示一行中的任意一个记录BEGIN  -- 将一行数据赋值给变量p  SELECT * INTO p FROM EMP WHERE empno=7369;  dbms_output.put_line(p.empno || &#x27;,&#x27; || p.ename||&#x27;,&#x27;|| p.sal);END;\n\n-- 从一行数据中筛选部分字段 赋值给变量p--   SELECT e.ename, e.job INTO p FROM EMP e  WHERE e.empno=7369;--   dbms_output.put_line(p.ename);\n\n\n\n\n5、if选择结构DECLARE  v_num NUMBER :=2;BEGIN  IF v_num &gt; 5      THEN dbms_output.put_line(v_num||&#x27;大于5&#x27;);    ELSE dbms_output.put_line(v_num||&#x27;不大于5&#x27;);  END IF;END;\n\nDECLARE  v_num NUMBER :=2;BEGIN  IF v_num &gt; 5      THEN dbms_output.put_line(v_num||&#x27;大于5&#x27;);    ELSIF v_num &lt; 5      THEN dbms_output.put_line(v_num||&#x27;小于5&#x27;);    ELSE dbms_output.put_line(v_num||&#x27;等于5&#x27;);  END IF;END;\n\n\n\n6、循环结构loop循环语法：loop\n  exit when 退出条件;\nend loop;\n循环打印 1~5 数字\nDECLARE  v_num NUMBER := 1;BEGIN  LOOP      IF v_num&gt;5 THEN        EXIT;      END IF;  dbms_output.put_line(v_num);  v_num := v_num + 1;  END LOOP;END;\n\nDECLARE  v_num NUMBER := 1;BEGIN LOOP    EXIT WHEN v_num &gt; 5;\tdbms_output.put_line(v_num);\tv_num := v_num + 1;  END LOOP;END;\n\n求和：从1开始累加，当和不大于20，输出最后一个数值1+2+3+4+5+6   – 5\nDECLARE v_sum NUMBER := 0; i NUMBER := 1;BEGIN LOOP  v_sum := v_sum + i;   -- 2  4  7 11  16  22exit when v_sum &gt; 20;  i := i + 1; END LOOP; dbms_output.put_line(i - 1);END;    -- 输出5\n\n\n\n7、游标 Cursor类似java集合声明语法：cursor 游标名 is select语句\n\n  %found：检验游标是否成功，通常在fetch语句前使用，         当游标按照条件查询出一条结果，返回true  %isopen：判断游标是否处于打开状态，试图打开一个已经打开的游标，将会出错  %notfound：与%found相反，当按照条件无法查询到记录时，返回true  %rowcount：循环执行游标读取数据时，返回检索出的记录数据的行数\n\n使用步骤：(1)打开游标(2)循环取值(3)关闭游标\nDECLARE  -- 声明游标  CURSOR cur_teacher IS SELECT tno,tname,sal FROM teacher;  v_tno teacher.tno%type;  v_tname teacher.tname%type;  v_sal teacher.sal%type;BEGIN  -- 打开游标  OPEN cur_teacher;   -- 循环取值    LOOP      FETCH cur_teacher INTO v_tno,v_tname,v_sal;          EXIT WHEN cur_teacher%notfound; -- 取不到值，退出循环\t\tdbms_output.put_line(v_tno||&#x27;-&#x27;||v_tname||&#x27;-&#x27;||v_sal);\tEND LOOP;  -- 关闭游标  CLOSE cur_teacher;END;-- 输出-- 1056-杨晓磊-20812.41-- 1057-黄芳菊-12711.46-- 1058-李红勤-21119.95   ...\n\nDECLARE  CURSOR cur_teacher IS SELECT * FROM teacher; -- 查询所有字段  v_teacher teacher%rowtype; -- 使用一个变量接收一行数据BEGIN  OPEN cur_teacher;  LOOP    FETCH cur_teacher INTO v_teacher;    \tEXIT WHEN cur_teacher%notfound; -- 取不到值，退出循环\tdbms_output.put_line(v_teacher.tno || &#x27;-&#x27; || v_teacher.tname||&#x27;-&#x27;|| v_teacher.sal);  END LOOP;     CLOSE cur_teacher;END;\n\n声明有参数的游标语法：cursor 游标名(参数名 参数类型) is select语句\n打印输出20号部门的员工信息\nDECLARE  cursor cur_emp(v_deptno emp.deptno%type) IS    SELECT * FROM emp WHERE deptno=v_deptno;  -- 声明变量接收一行数据   v_emp emp%rowtype;BEGIN  -- 打开游标，传递参数  OPEN cur_emp(20);  LOOP    FETCH cur_emp INTO v_emp; -- 循环取值\tEXIT WHEN cur_emp%notfound; \tdbms_output.put_line(v_emp.empno || &#x27;-&#x27; || v_emp.ename||&#x27;-&#x27;|| v_emp.deptno);  END LOOP;  CLOSE cur_emp;END;-- 输出-- 7369-SMITH-20-- 7566-JONES-20-- 7788-SCOTT-20-- 7876-ADAMS-20-- 7902-FORD-20\n\n练习：为emp表员工涨工资，从最低工资开始调整每人涨10%，但是工资总和不能超过5万计算涨工资人数 和 涨工资后的工资总和，并输出\n8、异常 Exception异常(例外)语法：\nDECLAREBEGIN  -- 业务逻辑  -- 异常  exception    -- 异常处理    when 异常1 then 异常处理语句1;    when 异常2 then 异常处理语句2;    when 异常3 then 异常处理语句3;    when others then 处理其他异常语句;END;\n\n\n常见异常：zero_divide 除零异常value_error 类型转换异常too_many_rows 查询出多条记录，赋值给一行记录的变量no_data_found 没有找到数据\n\nDECLARE a NUMBER; v_emp emp%rowtype;  -- 保存一行记录BEGIN -- 业务逻辑 -- a := 10 / 0; -- a := &#x27;张三&#x27;; -- select * into v_emp from emp; select * into v_emp from emp where empno = 321; exception   when zero_divide then     dbms_output.put_line(&#x27;除零异常...&#x27;);      when value_error then     dbms_output.put_line(&#x27;类型转换异常...&#x27;);      when too_many_rows then     dbms_output.put_line(&#x27;多行记录异常...&#x27;);      when others then     dbms_output.put_line(&#x27;其它异常...&#x27; || sqlerrm );  -- sqlerrm 接收错误信息END;\n\n\n\n9、存储过程 Procedure语法：or replace-存在就替换，不存在就创建\ncreate [or replace] procedure 存储过程名(参数 in | out 参数类型...)is | as  -- 声明部分begin  -- 业务逻辑end;\n\n调用方式一：call 存储过程名();\n调用方式二：DECLAREBEGIN  存储过程名();END;\n需求：给指定员工涨薪，并打印涨薪前和涨薪后的薪资\nCREATE OR REPLACE PROCEDURE pro_update_sal(v_empno IN emp.empno%type, -- 给谁涨工资v_money IN NUMBER -- 涨多少(注意：参数不能指定精度，如NUMBER(5,2)错误))IS   v_sal emp.sal%type;BEGIN  -- 记录原来的薪资  SELECT sal INTO v_sal FROM emp WHERE empno=v_empno;  -- 输出更新前的薪资  dbms_output.put_line(&#x27;原来的薪资：&#x27; || v_sal);  -- 更新工资  UPDATE emp SET sal = sal + v_money WHERE empno = v_empno;  -- 输出更新后的薪资  dbms_output.put_line(&#x27;更新后的薪资：&#x27; || (v_sal+v_money));  COMMIT; END;\n\nCALL pro_update_sal(7521,1000.00);BEGIN pro_update_sal(7369, 1000.00);END;\n\n\n\n10、触发器 Trigger当用户执行了 INSERT|UPDATE|DELETE操作，可以触发一系列的其他动作\n语法；\nCREATE [or replace] trigger 触发器名before | after -- 触发时机insert | update | delete -- 触发事件on 表名[for each row] -- 触发类型（语句级触发器 和  行级触发器）DECLAREBEGINEND;\n\n触发器的类型：(1)语句级触发器：在指定的操作语句 之前或之后执行一次，不管这条语句影响多少行(2)行级触发器(for each row)：触发语句作用的每一条记录都被触发– 在行级触发器中 使用old 和new关键字获取原来的值和新值\nnew 使用语法：  获取新的薪资 :new.salold 使用语法：  获取旧薪资 :old.sal\n插入员工之后，输出：欢迎新员工入职\nCREATE OR REPLACE TRIGGER tri_welcomeAFTER INSERT ON empDECLARE BEGIN  dbms_output.put_line(&#x27;欢迎你，菜鸟&#x27; );END;INSERT INTO emp(empno,ename) VALUES(6666,&#x27;蔡徐坤&#x27;);\n\n触发器中抛出异常使用触发器实现数据校验\n需求：非工作日不能插入员工信息\nCREATE OR REPLACE TRIGGER tri_add_empBEFORE INSERT ON empDECLARE   v_day VARCHAR2(10); -- 变量保存当前星期BEGIN  SELECT TO_CHAR(SYSDATE,&#x27;day&#x27;) INTO v_day FROM dual;  -- 判断周几  IF v_day =&#x27;星期四&#x27; THEN    dbms_output.put_line(&#x27;周末不能添加员工！！！&#x27;);    -- 抛出异常，让系统崩溃，这样数据就不会提交    raise_application_error(-20001,&#x27;周末不能办理入职！！！&#x27;);  END IF;END;\n\nINSERT INTO emp(empno, ename) values (7791, &#x27;lancy&#x27;);INSERT INTO emp(empno,ename) VALUES(1586,&#x27;马嘉祺&#x27;);SELECT TO_CHAR(SYSDATE,&#x27;day&#x27;) FROM dual;\n\n\n\n11、视图 View创建一个视图，展示教师姓名和部门名称\nCREATE OR REPLACE VIEW vi_teacher AS SELECT t.tno, t.tname, NVL(d.dname,&#x27;其他部门&#x27;) &quot;部门名称&quot;FROM teacher t LEFT JOIN dept d ON t.deptno=d.deptno;SELECT * FROM vi_teacher;DROP VIEW vi_teacher;\n\n\n\n12、同义词 Synonym同义词的目的是为了简化对目标对象的访问语法：CREATE [public] SYNONYM 同义词名 FOR 对象;\n公用同义词：所有用户都能访问私有同义词：只有创建的用户才能访问\nCREATE PUBLIC SYNONYM tea FOR teacher; -- 公用同义词CREATE SYNONYM myemp FOR emp; -- 私有同义词SELECT * FROM tea;\n\n\n\n13、序列 sequence序列 sequence：是 oracle 提供的用于产生一系列唯一数字的数据库对象\n创建语法：\n\n​\tcreate sequence 序列名称   –创建序列\n\n[start with n] –序列的起始值 (递增默认是 minvalue, 递减默认 maxvalue)\n[increment by n]; –递增的序列值\n\n\n注意：名称一般以 sq_ 开头\n使用序列：\n\n序列名.currval – 查询当前值\n序列名.nextval – 获取下一个值\n\n注意：第一次使用序列，必须使用 nextval\n创建序列  创建 起始值为1001，每次递增1的序列\nCREATE sequence sq_teacherSTART WITH 1001INCREMENT BY 1; -- 默认为1 可以不写\n\n调用序列：\nSELECT sq_teacher.nextval FROM dual;SELECT sq_teacher.currval FROM dual;\n\n\n\n\n\n– 练习 游标：– 需求：为 emp 表员工涨工资，从最低工资开始调整没人涨10%，但是工资总额不能超过 5 万– 计算涨工资人数 和 涨工资后的工资总额，并输出\n– 练习  触发器：– 需求：判断 员工涨薪后的薪资 必须大于 涨薪前的薪资– 如果小于，抛出异常\nupdate emp  set sal &#x3D; sal + 1000 where empno &#x3D; 7369;  – okupdate emp  set sal &#x3D; sal - 1000 where empno &#x3D; 7369;  – 没门的\n– 练习：触发器– 需求：使用 触发器实现 模拟 mysql 的主键自增效果\ninsert into dept(deptno, dname, loc) VALUES (序列.nextval,  ‘招生部’, ‘江软’);\ninsert into dept VALUES (null,  ‘招生部’, ‘江软’);insert into dept(dname, loc) VALUES (‘招生部’, ‘江软’);\n","categories":["Oracle"],"tags":["Oracle"]},{"title":"Linux学习笔记(总)","url":"/2025/09/18/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%80%BB)/","content":"一. Linux命令基础到进阶第一章 命令入门1、Linux的目录结构\n\n/，根目录是最顶级的目录了\nLinux只有一个顶级目录：/\n路径描述的层次关系同样适用/来表示\n&#x2F;home&#x2F;itpan&#x2F;a.txt，表示根目录下的home目录内有itpan目录，内有a.txt\n\n演示home家目录\n\nsu shucd /lscd /homelscd shullls\n\n常用的目录功能：\n \nHOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。\n\n普通用户的HOME目录，默认在：/home/用户名\n\nroot用户的HOME目录，在：/root\n\n\nFinalShell登陆终端后，默认的工作目录就是用户的HOME目录\n2、linux 命令基础格式无论是什么命令，在linux 中，命令有通用的格式\ncommand  [-选项] [参数]  ## []表示可选\n\n\ncommand： 表示命令，例如 ls、cd…\n-选项： 可选的，命令的一些选项，可以通过选项控制命令的行为细节\n参数：可选，命令的参数，多数用于命令指向的目标\n\n命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。\n比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。\n查看命令的帮助：help可以通过：命令 --help查看命令的帮助手册\nmkdir --help\n\n\n\n\n\n查看命令的详细手册：man可以通过：man 命令查看某命令的详细手册\nq 退出\n3、列出目录信息：ls功能：列出目录信息\n语法：ls [-l -h -a] [参数]\n\n参数：被查看的目录，不提供参数，表示查看当前工作目录\n-l，以列表形式查看目录中的内容\n-h，配合-l，以更加人性化的方式显示文件大小\n-a，显示隐藏文件\n\nls -la\t#以列表的形式查看当前目录，包括隐藏的文件&#x2F;目录\n演示：\nlsls -lls -a ls -a -lls -al  # 多个选项一起使用可以简写\n\n \n \n多个选项简写：\n \n查看指定目录中的内容\nls /var/temp/  # 查看/var/temp/目录下的内容\n\n \n \n带参数查看指定目录的内容\nls -l /var/tmp/\n\n\n\n \n \nls -l 命令可以简写为 ll\n \n4、隐藏文件、目录在Linux中以.开头的，均是隐藏的。\n默认不显示出来，需要-a选项才可查看到。\n5、常用的技巧命令5.1 清屏：clear (快捷键 ctrl + c) （Windows中cmd中cls清屏）5.2 强制退出：ctrl + c5.3 退出&#x2F;登出(用户)： exit &#x2F;快捷键 ctrl + d \n5.4 查看使用过的历史命令：history5.5 !命令前缀：执行上一次匹配的前缀的命令 \n5.6 历史命令搜索 ctrl + r\n如果搜到了，回车可以直接执行\n\n键盘左右键可以获取命令，不执行\n\n\n\n5.7 其他快捷操作\nctrl+a：跳到命令的开头\nctrl+e：跳到命令的结尾\nctrl+左右方向键：向左或右跳一个单词\n\n6、关机：shutdown作用：关闭系统，在关闭之前传递信息给所有使用者正在执行的程序，该命令也可以用来重启，需要管理员root权限执行\n语法： shutdown [选项] time [message] \n常用语法：\nshutdown #关机命令，centos6之前是关机，之后是延迟1分钟关机shutdown -h now\t#立即关机shutdown +1\t&quot;警告信息&quot;\t#延迟1分钟后关机，并显示警告信息shutdown -r +1 &quot;警告信息&quot; #表示1分钟后重启，并显示警告信息shutdown -c #取消当前的关机操作\n\n选项说明：\n\n-t seconds：设定在几秒钟之后进行关机程序。\n-k：并不会真的关机，只是将警告讯息传送给所有使用者。\n-r：关机后重新开机。\n-h：关机后停机。\n-n：不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\n-c：取消目前已经进行中的关机动作。\n-f：关机时，不做fcsk动作(检查Linux档系统)。\n-F：关机时，强迫进行fsck动作。\ntime：设定关机的时间。\nmessage：传送给所有使用者的警告讯息。\n\n \n补充：halt 命令\n作用：直接关闭系统，不重启\n7、重启：reboot作用：用于重新启动计算机\n\n（通常不需要带选项）需要管理员root权限\n\n\n-n：在重开机前不做将记忆体资料写回硬盘的动作\n-w：并不会真的重开机，只是把记录写到 &#x2F;var&#x2F; log&#x2F; wtmp档案里\n-d：不把记录写到 &#x2F;var&#x2F; log&#x2F; wtmp档案里（-n这个参数包含了-d）\n-f：强迫重开机，不呼叫 shutdown 这个指令\n-i：在重开机之前先把所有网络相关的装置先停止\n\n8、显示登陆用户：who作用：显示系统中有哪些使用者正在上面（上线）\n\n通常需要快速重启服务器，在重启之前需要检测有没有终端在连接，如果有可能就不会重启\n\n常用语法：\nwho\t#显示当前登录的系统用户who -H #显示当前登录的系统用户,含标题信息\n\n \n9、小结9.1 Linux命令基础格式command [-选项] [-参数]\n9.2 ls命令语法ls [-l -a -h] [路径]\n9.3 当前目录和home目录 \n\n\nlinux终端启动后默认 home 目录作为当前的工作目录\nhome目录：指用户在系统的专属目录\n\n9.4 隐藏文件\n\n在linux中，以.开头的文件、目录会自动隐藏\n需要通过 -a选项展示出来-a\n\n10、补充10.1命令提示符:[root@centos-shu ~]# [shu@centos-shu root]$\n\n提示当前可以输入命令进行交互，同时也会交代一些基础的信息\n\n\n当前用户名：root\n当前主机名：@centos-shu\n当前所在的目录名称：~，表示当前用户的家目录\n当前用户的权限：# 表示管理员权限(root用户)，$ 表示普通权限(普通用户)\n\n\n \n10.2 家目录家目录就是自己的家，用户在自己的家目录中拥有所有权限\n10.3 短选项和长选项命令结构：命令名 选项 参数\n\n命令名：命令结构的第一个部分\n选项： \n\n短选项：由一个减号- 开头的选项，短选项名称都是一个字母，可以缩写（将多个短选项的字母连接在一起）（例如：ls -al   –&gt;   ls -a -l）\n长选项：由两个减号--开头的选项，减号后面的内容就是 选项名称，长选项名称一般是一个完整的单词\n\n\n第二章 目录切换操作1、pwd命令pwd 命令来自：print work directory\n功能：展示当前工作目录\n语法：pwd\n\n没有选项，没有参数，直接输入即可\n\n演示：\npwd # 展示当前所在的目录路径cd /var/tmp/pwd\n\n\n\n \n2、cd命令cd 命令来自： change directory,变换目录\n功能：切换工作目录\n语法：cd [目标目录]\n参数：目标目录，要切换去的地方，不提供 默认切换到当前登录用户HOME目录\n\ncd 命令无需选项，只有参数，表示要切换到那个目录下\n\n演示：\ncd /var/tmp/ # 切换到指定路径pwdcd # 不加参数，默认切换到home目录\n\n\n\n \n3、小结3.1 pwd 命令的作用\n输出当前所在的工作目录\n3.2 cd命令的作用\n切换到当前的工作目录\n\n没有选项，只有参数\n\n第三章路径和路径符1、相对路径、绝对路径\n相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;/开头的称之为相对路径\n相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test目录内的a.txt文件\n\n绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;/开头的称之为绝对路径\n绝对路径从根开始描述路径\n\n\n演示：\npwdllcd 桌面 # 通过相对路径进入桌面目录cdcd /home/shu/桌面 # 通过绝对路径进入桌面目录\n\n\n\n\n2、特殊路径符\n.，表示当前，比如.&#x2F;a.txt，表示当前目录内的a.txt文件\n..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录\n~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录\n\n演示：\ncd /home/shu/桌面cd .. # 返回上一级目录cd ../.. # 返回上两级目录cd ~ #切换到家home目录\n\n\n\n\n3、小结3.1 相对路径和绝对路径\n\n相对路径：从当前目录出发的路径\n绝对路径：从/根目录出发的路径\n\n3.2 特殊路径符\n\n.\t表示当前\n..   表示上级目录\n../..   表示上级的上级目录\n~    表示用户的home家目录\n\n第四章 目录操作1、创建目录：mkdirmkdir 命令来自：make dirctory\n功能：创建目录\n语法：mkdir [-p] 参数\n\n选项：-p，可选，表示创建前置路径\n参数：被创建目录的路径\n\ncd /home/shu/桌面mkdir aaa # 创建aaa目录llmkdir bbb/ccc # 创建多级目录时，如果前置目录不存在，则无法创建mkidr -p bbb/ccc # 添加 -p 选项，表示如果前置路径中的目录不存在，则创建前置路径中的目录\n\n\n\n\n\n\n2、删除空目录：rmdir语法：rmdir [-p] 参数\n\n-p 选项：如果删除了子目录，当前目录为空目录，那么当前目录也会被删除\n参数：要删除的目录名称\n\n\n\n\n\n3、小结mkdir命令的语法和作用\n创建目录\n-p选项的作用\n可选，表示创建前置路径（用于创建多级目录）\n第五章 文件操作命令1、创建文件：touch功能：创建文件\n语法：touch 参数\n\n参数：被创建的文件路径\n\ntouch a.txt # 在当前目录中创建a.txt文件lltouch aaa/a.sql # 在指定的路径下创建a.sql文件ll aaa\n\n\n\n\n批量创建文件\ntouch &#123;1,2&#125;.txt #创建 1.txt 2.txttouch &#123;a..d&#125;.txt #创建a.txt b.txt c.txt d.txt\n\n\n\n\n\n2、查看短文本文件：cat功能：查看文件内容\n语法：cat 参数\n\n参数：被查看的文件路径\n没有选项，只有必填参数\n\ncat a.txt #查看当前目录下的a.txt中的内容cat aaa/a.sqlcat /home/shu/桌面/a.txt #查看指定路径下的文件中的内容\n\n\n\n\n\n补充：tac命令\n反转查看文件内容\n3、查看长文本文件：more功能：查看文件，可以支持翻页查看\n语法：more 参数\n\n参数：被查看的文件路径\n在查看过程中：\n空格键翻页\nq退出查看\n\n\n\nmore aaa/abc.txt #分页展示文件中的内容\n\n\n\n\n\n4、less 命令：作用：查看长文本文件，可以分页查看，每次只显示一页内容\n语法L：less [选项] 文件\n主要选项：\n\n空格键：显示下一页内容。\n\nEnter 键：显示下一行内容。\n\nq 键：退出 less。\n\n\n\n5、复制文件：cpcp命令来自于：copy\n功能：复制文件、目录\n语法：cp [-r] 参数1 参数2\n\n参数1，被复制的\n参数2，要复制去的地方\n选项：-r，可选，复制目录使用\n\n示例：\n\ncp a.txt b.txt，复制当前目录下a.txt为b.txt\ncp a.txt test&#x2F;，复制当前目录a.txt到test目录内\ncp -r test test2，复制目录test到当前目录内为test2存在\n\ncp a.txt b.txt # 将a.txt复制到b.txt文件llcat b.txt\n\n\n\n\n复制目录：\ncp bbb ppp # 复制目录 ——失败cp -r bbb ppp #复制目录时，需要添加 -r 选项\n\n\n\n\n\n6、移动&#x2F;改名：mv命令mv 命令来自于：move\n功能：移动文件、目录\n语法：mv [-选项] 参数1 参数2\n\n参数1：被移动的\n参数2：要移动去的地方，参数2如果不存在，则会进行改名\n-i选项：在mv过程中，如果指定的目录中有同名文件，询问是否覆盖旧文件\n-f 选项(force)：在mv过程中，在移动过程中，不询问直接移动覆盖\n\n\n\n\n命令形式\n运行结果\n\n\n\nmv 源文件名 目标文件名\n将源文件名改名为目标文件名\n\n\nmv 源文件名 目标目录名\n将源文件移动到目标目录中\n\n\nmv 源目录名 目标目录名\n如果目标目录存在，则源目录移动到目标目录， 如果目标目录不存在，则源目录改名为目标目录名\n\n\nmv 源目录名 目标文件名\n报错\n\n\n演示：\nmv a.txt a-bak.txt #改名：文件 -&gt; 文件lsmv b.txt bbb #移动：文件 -&gt; 目录ls bbbmv bbb ddd #改名：目录 -&gt; 不存在的目录lsmv aaa ddd #移动：存在的目录 -&gt; 另一个目录lsmv a-bak.txt bbb/b.txt #报错：文件  -&gt; 文件\n\n\n\n\nmv选项演示：\nlsls dddtouch b.txtmv -i b.txt ddd # -i选项：有同名文件时，询问是否覆盖touch b.txtmv -f b.txt ddd # -f选项：有同名文件时，不询问直接覆盖\n\n\n\n\n7、删除：rmrm 命令来自于：remove\n功能：删除文件、目录\n语法：rm [-r -f] 参数...参数\n\n参数：支持多个，每一个表示被删除的，空格进行分隔\n选项：-r，删除目录使用\n选项：-f，强制删除，不会给出确认提示，一般root用户会用到\n\n\nrm命令很危险，一定要注意，特别是切换到root用户的时候，不要使用 -rf 选项。\nrm -rf &#x2F; \n普通用户删除内容不会弹出提示，只有root管理员用户删除内容有提示\n所以普通用户用不到 -f 选项\n\n演示：\nlsrm a-bak.txt # 删除文件，不需要添加选项rm ppp # 不能直接删除目录，需要添加 -r 选项rm -r ppp # 删除目录，需要加 -r 选项su root\t#切换到root管理员lsrm -r ddd # 会提示 n退出rm -rf ddd #管理员账户删除时，可以使用 -f，表示强制删除，不会提示\n\n\n批量删除文件：\nrm 1.txt 2.txtlsrm &#123;a..d&#125;.txt\n\n\n\n\n\n\n\n8、小结8.1 touch 命令的作用\n\n语法：touch 参数  （参数：被创建的文件（路径） ）\n\n批量创建的语法：touch {1,2(数字&#x2F;字母 有序)}.文件后缀\n\n\n8.2 cat 命令的作用\n\n语法：cat 参数 （参数：被查看的文件路径）\n注意：没有选项，只有必填参数\n\n8.3 more 命令的作用\n\n翻页：空格键翻页\n退出查看：q退出查看\nmore 命令 和cat 命令的区别，\nmore是翻页查看文件\ncat查看所有文件内容\n应用场景（more 大段文本）\n\n\n\n8.4 cp命令\n\n语法：cp [-r] 参数1 参数2 \n\n参数1，被复制的\n参数2，要复制去的地方\n选项：-r，可选，复制目录使用\n\n\n复制文件\n\n复制目录\n\n\n8.5 mv命令\n\n语法： mv [-选项] 参数1 参数2\n\n语法情形\n- \n\n\n\n命令形式\n运行结果\n\n\n\nmv 源文件名 目标文件名\n将源文件名改名为目标文件名\n\n\nmv 源文件名 目标目录名\n将源文件移动到目标目录中\n\n\nmv 源目录名 目标目录名\n目标目录存在，则源目录移动到目标目录， 如果目标目录不存在，则源目录改名为目标目录名\n\n\nmv 源目录名 目标文件名\n报错\n\n\n\n选项 -i 和 -f\n\n-i  选项：在mv过程中，如果指定的目录中有同名文件，询问是否覆盖旧文件\n\n-f  选项：在 mv 过程中，覆盖已有的目标文件时不给给提示\n\n\n8.6 rm 命令\n\n语法： rm [-r -f] 参数…参数\n\n参数：支持多个，每一个表示被删除的，空格进行分隔\n选项：-r，删除目录使用\n选项：-f，强制删除，不会给出确认提示，一般root用户会用到\n\n\n删除文件&#x2F;目录\n\n\n第六章 查找命令1、查看命令路径：which功能：查看命令的程序本体文件路径\n语法：which 参数\n\n参数：被查看的命令\n\n\nlinux命令本质上是一个 二进制 可执行程序  ，类似于 windows 中 .exe程序\n\nwhich cd # which 查看命令程序存放在哪里which pwdwhich mkdirwhick touch\n\n\n\n\n\n2、搜索文件：find功能：搜索文件\n语法1按文件名搜索：find 路径 -name 参数\n\n路径，搜索的起始路径\n-name选项：表示根据名称搜索\n参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件\n\n\n通配符 * \n\ntest*：表示以test开头\n*txt：表示以txt结尾\n*test*：表示包含test内容\n\n\nsu rootll -l /var/tmp/find /var/tmp/ -name &quot;sssd*&quot; # 查找/var/tmp/路径下 名字为 sssd开头 的文件find /var/ -name &quot;*txt&quot; # 查找/var/路径下 名字为 txt结尾 的文件\n\n\n\n\n语法2，根据文件大小查找文件：find 起始路径 -size + | -n[kMG]\n\n+、-：表示大于和小于\nn：表示数字大小，\nkMG：表示单位，k(小写字母)表示kb，M表示MB，G表示GB\n\nfind /var -size -1k # 表示查找/var/ 目录下小于1kb的文件\n\n\n3、关键字筛选：grep功能：过滤关键字\n语法：grep [-n] 关键字 文件路径\n\n选项 -n，可选，表示在结果中显示匹配的行的行号。\n选项  -i ,可选，表示在搜索时忽略大小写\n选项  -v, 可选，表示搜索不包括关键字的行\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\n\n\n参数文件路径，可以作为管道符的输入\n\n\ngrep &quot;关键字&quot; a.txt # 把包含关键字的行展示出来grep -n &quot;关键字&quot; a.txt # 把包含关键字的行展示出来，并且加上行号grep -i &quot;关键字&quot; a.txt # 搜索时忽略大小写grep -v &quot;关键字&quot; a.txt # 展示不包含关键字的行##关于进程ps -ef | grep &quot;关键字&quot; #查找包含关键字的进程信息，包括当前grep进程ps -ef | grep &quot;关键字&quot; | grep -v  #查找包含关键字的进程信息，不包括当前grep进程ps -ef | grep -c sshd #查找包含sshd个数\n\n\n\n\n4、统计数量：wc功能：统计\n语法：wc [-c -m -l -w] 文件路径\n\n选项，-c，统计bytes数量\n选项，-m，统计字符数量\n选项，-l，统计行数\n选项，-w，统计单词数量\n参数，文件路径，被统计的文件，可作为内容输入端口\n\n\n参数文件路径，可作为管道符的输入\n\n\n5、动态展示末尾：tail功能：查看文件尾部内容\n语法：tail [-f] 参数\n\n参数：被查看的文件\n选项：-f，持续跟踪文件修改(动态展示文件内容,常用于查询正在改变的日志文件)\n\n常用语法：\ntail a.txt\t\t\t#默认显示最后10行tail -3 a.txt\t\t#显示文件的最后3行tail -f a.txt\t\t#动态显示最后10行tail -4f a.txt\t\t#动态显示最后4行tail -n+2 a.txt\t\t#显示文件a.txt内容，从第2行至文件末尾tail -c 40 a.txt\t#动态显示40个字符\n\n\n\n\n6、展示头部内容：head功能：查看文件头部内容\n语法：head [-n] 参数\n\n参数：被查看的文件\n选项：-n，查看的行数\n\nhead -5 hello.txt\t#查看前5行数据\n\n\n小结which命令\n\n查找命令的程序文件路径\n语法：which 参数( 参数：被查看的命令 )\n\nfind命令\n\n语法1，根据文件名称查找： find 路径 -name 参数\n\n路径，搜索的起始路径\n\n-name 选项：表示根据名称搜索\n\n参数，搜索的关键字，支持通配符 * ， 比如： *test 表示搜索任意以test结尾的文件\n\n通配符 *\ntest* ： 表示 以 test 开头的\n*txt ：表示 以 txt 结尾的\ntest ：表示 包含 test 内容的\n\n\n\n\n\n语法2，根据文件大小查找： find 起始路径 -size + | -n[kMG]\n\n+ 、 - ：表示大于和小于\nn ：表示数字大小\nkMG：表示单位， k (小写字母)表示 kb，M表示MB，G表示GB\n\n\n\n第七章 管道符、echo和重定向1、管道符 |写法：|\n功能：将符号左边的结果，作为符号右边的输入\n示例：\ncat a.txt | grep itpan，将cat a.txt的结果，作为grep命令的输入，用来过滤itpan关键字\n可以支持嵌套：\ncat a.txt | grep itpan | grep itpan\n# 将管道符左边的结果当做右边的命令的输入#\n\n\n\n\ncat hello.txtcat hello,txt | grep -n &quot;奔流&quot;\n\n\n\n\n#嵌套cat hello,txt | grep -n &quot;君不见&quot; | grep -n &quot;奔流&quot;\n\n\n\n\n2、输出：echo功能：输出内容\n语法：echo 参数\n\n参数：被输出的内容（最好用引号包裹）\n注意：输出的内容有特殊符号或者空格的，建议加上双引号\n\necho &quot;Hello World&quot;\t#输出内容\n\n\n3、&#96;反引号功能：被两个反引号包围的内容，会作为命令执行\n示例：\n\necho `pwd`，会输出当前工作目录\n\necho `pwd`\t#单作命令执行\n\n\n\n\n4、输出重定向符功能：将符号左边的结果，输出到右边指定的文件中去\n\n&gt;，表示将左边命令的结果 覆盖输出 到右边指定的文件中\n&gt;&gt;，表示将左边命令的结果追加输出 到右边指定的文件中\n2&gt;，将符号左边内容错误输出重新转到右边的内容中，覆盖原内容\n2&gt;&gt;，将符号左边内容错误输出重新追加右边的内容中\n&amp;&gt; ，将符号左边内容的标准输出和错误输出重新转到右边的内容中，覆盖原内容\n&amp;&gt;&gt; ，将符号左边内容的标准输出和错误输出重新追加转到右边的内容中\n\n\n注意：如果重定向的文件不存在，则自动创建文件\n\necho &quot;字符串&quot; &gt; 文件\t\t#覆盖文件内容echo &quot;字符串&quot; &gt;&gt; 文件\t#追加文件内容cat 不存在的文件 &amp;&gt;&gt; err.log\t#将命令执行失败的结果追加到 error.log 文件中echo &quot;select * from teacher&quot; &gt; teacher.sql #重定向覆盖写cat teacher.sqlecho &quot;select * from teacher where tno=1&quot; &gt; teacher.sql\n\n\n\n\ntail -f teacher.sqlecho &quot;select tname,gender from teacher order by gender&quot; &gt;&gt; teacher.sql #重定向追加写\n\n\n\nll abc ls: 无法访问abc: 没有那个文件或目录#将左边命令错误的信息写入log.txt文件ll abc 2&gt; log.txtcat log.txtls: 无法访问abc: 没有那个文件或目录#将左边命令错误的信息覆盖写入log.txt文件cat abc 2&gt;&gt; log.txt\n\n\n#左边内容的标准输出和错误输出都会写入文件中cat student.txt &amp;&gt; student.log #标准输出覆盖写入日志文件cat student.sql &amp;&gt;&gt; student.log #错误输出追加写入日志文件\n\n\n注意：&amp;&gt;或者&amp;&gt;&gt;，标准输出和错误输出都能写入到右边的文件中\n\n\n5、输入重定向功能：重定向后可以从文件&#x2F;指定文本块获取输入\n\n命令 &lt; 文件 ：通过输入流将文件内容输入到命令中\n命令 &lt;&lt; tag：：通过输入流将两个相同 tag 之间的内容输入到命令中\n\n&#x3D;&#x3D;tr命令替换文件中的字符&#x3D;&#x3D;\nvim student.txt #准备测试文件tom:85:Chinesejack:95:Englishrose:75:Math\n\n\n\ntr &quot;5&quot; &quot;*&quot; &lt; student.txt #将右边读取的文件内容，代入到左边的命令中，不修改源文件\n\n\n\ntr 命令的作用：字符替换(将第一个字符集中的字符替换为字符集中的字符)\n输入重定向的逻辑：&lt; student.txt ，将 student.txt文件的内容传递给tr命令，作为tr命令的输入\n\n&#x3D;&#x3D;使用cat 命令打印多行文本&#x3D;&#x3D;:\n# &lt;右边是一个多行文本块#将多行文本块的内容带入左边 cat 命令cat &lt;&lt; EOF 你好很高兴认识你EOF\n\n \n\ncat命令默认读取内容，通常情况下 从文件中读取，使用&lt;&lt; EOF 改变了输入源\n输入重定向的逻辑&lt;&lt; EOF：表示输入从当前行开始，直到遇到单独一行的EOF为止，中间的内容“你好 很高兴认识你”会被cat命令读取\n注意：EOF是约定的标记符，也可以换成其他任意字符串\n\n总结：管道符 |\n\n功能：将符号左边的结果，作为符号右边的输入\n支持嵌套\n\n第八章 编辑器vi&#x2F;vim1、vi 介绍vi 是’visual interface’的简称，是 Linux 中最经典的文本编辑器原生的\n2、vim 介绍vim 是从 vi 发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便的编程功能特别丰富\n3、vi&#x2F;vim 模式在 windows 中 我们想要操作 a. txt 文本:双击打开文本(阅读文本内容)→编辑内容→保存退出\n\nvi&#x2F;vim模式主要分为以下三种：\n\n命令模式（打开文本阅读）：通过vim 文件名命令就进入了&#x3D;&#x3D;命令模式&#x3D;&#x3D;，不能输入文字\n编辑模式(编写内容)：在命令模式下按i键进入编辑模式，此时可以写入内容，按ESC键退出&#x3D;&#x3D;编辑模式&#x3D;&#x3D;，回到&#x3D;&#x3D;命令模式&#x3D;&#x3D;\n末行模式：在&#x3D;&#x3D;命令模式&#x3D;&#x3D;下输入:分号进入&#x3D;&#x3D;末行模式&#x3D;&#x3D;，左下角出现冒号，此时可以敲命令并执行（w保存&#x2F;q退出&#x2F;wq保存并退出…)\n\n三种模式的切换：\n\n4、进入编辑模式命令从命令模式讲入编辑模式提供了以下命令：\n\n\n\n命令\n说明\n功能\n\n\n\ni\ninsert\n在当前字符前插入文本\n\n\nl\ninsert\n在行首插入文本\n\n\na\nappend\n在当前字符后添加文本\n\n\nA\nappend\n在行末添加文本\n\n\no\n\n在当前行后面插入一个空行\n\n\nO\n\n在当前行前面插入一个空行\n\n\n命令模式快捷键\n\n\n5、末行模式命令底线命令快捷键\n\n\n命令\n说明\n\n\n\n:q\n仅退出\n\n\n:q!\n不保存强制退出\n\n\n:wq\n保存并退出\n\n\n:wq!\n保存并强制退出\n\n\n \n6、vim定位行语法：vim 文件 +行数\n打开文件并定位到具体行数\nvim hello.txt +5\n\n \n7、vim异常处理\n如果vim异常退出，在磁盘上可能会保存交换文件(.原文.swp)\n\n例如，在编辑 a.txt 时，会生成一个 a.txt.swp 交换文件\n\n\n解决方式：\n先退出vim编辑器，删除交换文件：rm .a.txt.swp\n然后就可以正常编辑a. txt文件\n\n没有删除选项\n先退出vim编辑器，手动删除交换文件：rm.a.txt.swp\n然后就可以正常编辑a.txt文件了\n\n\n\n第九章 文本处理器: awk和sed1、文本文件处理：awk1.1、awk介绍AWK是一种处理文本文件的语言，是一个强大的文本分析工具\n语法：\n\n\n\n选项名称\n作用\n\n\n\n-F ‘;’\n-F 表示分割，该选项表示使用指定的字符（任意字符）;分割\n\n\n$+数字\n获取第几段的内容\n\n\n$0\n获取当前行内容\n\n\nOFS&#x3D;”字符”\n输出的是段内容以指定字符分隔\n\n\nNF\n表示当前行共有多少个字段\n\n\n$NF\n代表最后一个字段\n\n\n$(NF-1)\n代表倒数第二个字段\n\n\nNR\n代表处理的是第几行\n\n\n1.2、需求：文本score.txt，内容\nxuzhu 68 99 26duanyu 98 66 96qiaofeng 78 44 36yangguo 38 33 86guojing 88 22 66huangrong 98 44 46\n\n有以下需求：\nduan 和 huang 的学生成绩搜索含有 duan 和 huang 的学生成绩每一行按照指定分割符切割，再输出切割后的每一个小段每一行按照空格切割，再输出切割后的每一个小段，多个小段中间以指定符号（例如： →符号）间隔每一行按照空格切割，将第一段内容转成大写并显示每一行按照空格切割，计算第四列的总分并显示每一行按照空格切割，计算第四列的总分并显示，显示总分，总人数（总行数）每一行按照空格切割，计算第四列的总分并显示，显示总分，总人数和平均分```\n\n\n\n1.3、搜索指定的字段语法：awk &#39;字段&#39; 文件\ncat score.txt | awk &#x27;/duan|huan/&#x27; #从cat结果中，搜索含 duan|huan的内容\n\n \n1.4、根据指定分割符和小标显示语法：awk -F &#39;指定分割字符&#39; &#39;&#123;print $1,$2...&#125;&#39;文件\n\n-F 表示分割，指定分割符\nprint 表示打印\n$+数字，表示获取第几段内容\n\ncat score.txt | awk -F &#x27; &#x27; &#x27;&#123;print $1,$2,$3,$4&#125;&#x27;cat score.txt | awk -F &#x27; &#x27; &#x27;&#123;print $1,$2&#125;&#x27;\t#awk对源文本进行处理，返回想要的结果\n\n\n\n\n\n1.5、按照指定的字符分隔段语法：awk -F &#39;分割符&#39; &#39;&#123;OFS=&quot;段分隔符&quot;&#125;&#123;print $1...&#125;&#39; 文件\n\nOFS选项指定段的分隔符\n\n#原文本使用空格分割段，使用-分隔段输出awk -F &#x27; &#x27; &#x27;&#123;OFS=&quot;-&quot;&#125;&#123;print $1,$2,$3,$4&#125;&#x27; score.txtawk -F &#x27; &#x27; &#x27;&#123;OFS=&quot;\\t&quot;&#125;&#123;print $1,$2,$3,$4&#125;&#x27; score.txt\n\n\n\n\n1.6、awk函数常用函数：\n\n\n\n函数名\n作用\n\n\n\ntoupper()\n转大写\n\n\ntolower()\n转小写\n\n\nlength()\n返回字符长度\n\n\n语法：awk -F &#39;分割符&#39; &#39;&#123;print 函数名($1),$2...&#125;&#39; 文件\n#将第一个字符转大写awk -F &#x27; &#x27; &#x27;&#123;OFS=&quot;\\t&quot;&#125;&#123;print toupper($1),$2,$3,$4&#125;&#x27; score.txt#求字符串长度awk -F &#x27; &#x27; &#x27;&#123;print length($1)&#125;&#x27; score.txt\n\n\n\n\n1.7、awk计算语法：awk &#39;BEGIN&#123;初始化操作&#125;&#123;每行都执行&#125;END&#123;结束时操作&#125;&#39;文件名\n注意：BEGIN、END大写\n\n\n\n选项名称\n作用\n\n\n\nNF\n表示当前行共有多少个字段\n\n\n$(NF-1)\n代表倒数第二个字段\n\n\n$NF\n代表最后一个字段\n\n\nNR\n代表处理的是第几行\n\n\nawk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125;END&#123;print total&#125;&#x27; score.txt#NR处理的行数，值和总人数一样awk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125;END&#123;print total,NR&#125;&#x27; score.txt awk -F &#x27; &#x27; &#x27;BEGIN&#123;&#125;&#123;total=total+$4&#125;END&#123;print total,NR,total/NR&#125;&#x27; score.txt \n\n\n\n\n2、流式编辑器：sed2.1 sed介绍sed (Stream Editor) 是 linux 下的流编辑器，核心逻辑是逐行读取文本，将每行放入“模式空间”处理后输出，直到所有行处理完毕\n适合批量文本编辑、替换、删除等操作，无需打开文件交互，常用于脚本自动化\n语法：\nsed [选项] &#39;脚本内容&#39; [待处理的文件路径]\n\n如果不指定文件则使用 - ，则从标准输入读取数据\n脚本内容使用单引号包裹，格式：[行范围] 操作 [操作参数]\n\n2.2 打印操作（p）脚本P(print)作用：打印匹配的行\nvim test.txt #准备文件cat test.txtline 1 line 2line 3line 4line 5\n\n&#x3D;&#x3D;打印指定的行&#x3D;&#x3D;：输出第三行：\nsed -n &#x27;3p&#x27; test.txt#或者head -3 test.txt | tail -1\n\n\n选项 -n ：静默输出(默认情况下sed会打印原文＋处理结果，-n只显示脚本处理的结果)\n脚本处理3p ：表示打印 第3行\n\n&#x3D;&#x3D;使用正则匹配打印内容&#x3D;&#x3D;:vim log.txt #准备测试文件info:starterror: connection filedinfo: retryerror: timeout\n\n匹配打印包含 error 的行:\nsed -n &#x27;/error/p&#x27; log.txt\n\n\n/error/：正则表达式，匹配包含 error 的行\np：打印匹配行\n\n\n2.3 删除操作(d)脚本d(delete)作用：删除匹配行\n&#x3D;&#x3D;删除最后一行&#x3D;&#x3D;：(删除line 5)\nsed &#x27;$d&#x27; test.txt #删除最后一行，并输出结果，源文件内容不变#删除指定行，&#x27;$5d&#x27;-删除第5行\n\n\n\n$：表示最后一行\nd：删除匹配的行\n\n\n 注意：\n\n将源文件的内容取出来，删除最后一行，显示\n源文件本身里面的内容不会被删除\n\n\n2.4 追加(a)和插入(i)作用：\n\na（append）：在匹配行之后追加内容\ni（insert）：在匹配行之前插入内容\n\n&#x3D;&#x3D;在 error 行前插入提示&#x3D;&#x3D;\nsed &#x27;/error/i \\== error content ==&#x27; log.txt\n\n\n2.5 替换操作(c和s)\nc (change)：替换整行内容为新内容\ns (substitute)：替换行内部分内容(支持正则)\n\n&#x3D;&#x3D;替换error行&#x3D;&#x3D;:sed &#x27;/error/c \\=== errorline replaced ===&#x27; log.txt\n\n\n&#x3D;&#x3D;替换行内文本&#x3D;&#x3D;:sed &#x27;s/error/ERROR/&#x27; log.txt\n\n\n\n脚本 &#39;s/old/new&#39; ：替换每行第一个”old” 为”new”\n\n&#x3D;&#x3D;全局替换&#x3D;&#x3D;：使用 g 标记全局sed &#x27;s/error/ERROR/g&#x27; log.txt\n\n\n2.6 正则扩展和分组引用(-r选项)sed命令选项-r ：开启正则扩展，支持括号()分组和\\1\\2引用分组内容\n&#x3D;&#x3D;提取并重组文本内容&#x3D;&#x3D;:\nvim student.txt #准备文件tom:85:Chinesejack:92:Englishrose:76:Math\n\n提取”姓名+科目”，并重组为：’科目：姓名‘\nsed -r &#x27;s/([a-zA-Z]+):[0-9]+:([a-zA-Z]+)/\\2: \\1/&#x27; student.txt\n\n\n\n\n([a-zA-Z]+) ：分组1，匹配姓名(字母)\n\n[0-9]+ ：匹配分数(数字)\n\n([a-zA-Z]+) ：分组2，匹配科目(字母)\n\n\\2: \\1 ：引用分组2和分组1，重组为科目：姓名\n\n\n\n2.7 直接修改源文件(-i选项)sed命令默认只输出到屏幕，不修改源文件，-i 选项直接修改源文件\n&#x3D;&#x3D;替换源文件的内容&#x3D;&#x3D;:\n将test.txt文件中的line 2 内容替换为 第二行\nsed -i &#x27;s/line 2/第二行/&#x27; test.txt\n\n\n2.8 多脚本操作(-e选项)sed命令的-e选项允许一条sed命令指定多个脚本（对同一行执行多次处理）\n&#x3D;&#x3D;先删除最后一行，再替换内容 line 为 row&#x3D;&#x3D;\nsed -e &#x27;$d&#x27; -e &#x27;s/line/row/&#x27; test.txt\n\n\n2.9 小结选项：\n\n-n ：静默输出结果\n-r ：开启正则扩展(支持分组，引用组)\n-i ：直接修改源文件\n-e ：执行多个脚本\n\n脚本：\n\np ：打印处理结果\nd ：删除\na 和 i ：追加和插入\nc 和 s ：替换操作\n\n总的来说：sed 是文本处理工具，通过逐行读取+模式空间处理+输出的流程，实现打印、删除、替换、追加等操作\n尤其适合脚本自动化和日志处理\n3、小结awk在使用过程中主要用作分析文本\n\n简单来说，就是通过awk将文件逐行读入，以分割符将每行切片，切开的部分再进行分析处理\n\n第十章 用户和用户组1、切换和提权：su和sudo1.1 切换用户：su语法：su [-] [用户]\n\n注意：\n\n从普通用户切换到管理员用户需要输入管理员密码\n管理员—普通用户，不需要密码\n\n\n演示：\nsu --help #查看帮助文档su shusu -c ls root #切换到 root 用户，执行 Is 命令,执行完命令后回到 原来 用户\n\n常见用法和选项：\n\n1.su 或 su -：\n\n切换到超级用户（root）身份。使用 - 选项会将当前环境变量切换到 root 用户的环境变量，类似于登录为 root 用户。\n\n\n2.su ：\n\n切换到指定用户名  的用户身份。需要输入目标用户的密码来进行身份验证。\n\n\n3.su -c ““：\n\n切换用户执行命令，执行完后再回到原来的使用用户\n\n以超级用户身份执行指定的 ，而无需切换到该用户。\n\n\n\n4.su -l  或 su –login ：\n\n切换到指定用户名  的用户身份，并加载目标用户的环境变量。\n\n\n5.su -s ：\n\n使用指定的 shell 来切换用户身份。例如，su -s &#x2F;bin&#x2F;bash 将切换到 bash shell。\n\n\n\n请注意，使用 su 命令需要知道目标用户的密码。而且，默认情况下，只有超级用户（root）可以切换到其他用户身份。在某些发行版中，还需要将用户添加到合适的用户组中才能使用 su 命令。\n1.2 提升权限：sudo作用：控制用户对系统命令的使用权限，root用户允许的权限\n给普通用户授权root权限\n语法： sudo [选项]\n选项说明：\n\n-V 显示版本编号\n-h会显示版本编号及指令的使用方式说明\n-I 显示出自己 (执行 sudo 的使用者)的权限\n-v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行 (N 预设为五)会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码\n-k 将会强迫使用者在下一次执行 sudo 时问密码 (不论有没有超过 N 分钟)\n\n[shu@localhost ~]$ ls /rootls: 无法打开目录/root: 权限不够#当前普通用户没有查看 / root 目录的权限sudo ls #第一次使用需要密码sudo ls /root\n\n\n\n常见用法和选项：\n\n1.sudo ：\n\n以超级用户权限执行指定的 。\n\n\n2.sudo -l：\n\n显示当前用户可以使用 sudo 执行的命令列表。\n\n\n3.sudo -i 或 sudo su：\n\n切换到超级用户的交互式 shell 环境，使用户能够在该环境下执行多个命令。\n\n\n4.sudo -u  ：\n\n以指定用户  的身份执行指定的 。\n\n\n5.sudo -s 或 sudo –shell：\n\n在当前 Shell 中切换到超级用户身份，并保留原有的环境变量。\n\n\n6.sudo visudo：\n\n使用文本编辑器打开 &#x2F;etc&#x2F;sudoers 文件，编辑 sudo 配置。\n\n\n7.sudo -k：\n\n使 sudo 会话的时间戳过期，要求重新验证密码。\n\n\n8.sudo -V 或 sudo –version：\n\n显示 sudo 的版本信息。\n\n\n9.sudo -h 或 sudo –help：\n\n显示 sudo 命令的帮助信息。\n\n\n\n\n注意，使用 sudo 命令需要具有适当的权限，并且用户需要在 &#x2F;etc&#x2F;sudoers 配置文件中正确配置才能成功使用。在某些发行版中，可能还需要将用户添加到特定的 sudo 用户组中。\n\n2、用户管理2.1用户管理命令\n创建用户：useradd [选项]用户名\n用户密码：passwd [选项]用户名\n修改用户：usermod 选项 用户名（必须有选项）\n删除用户：userdel [选项]用户名\n\n注意：对于用户的操作都需要管理员权限\n选项：\n\n-c：comment 指定一段注释性描述。\n-d：目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g：用户组 指定用户所属的用户组。\n-G：用户组，用户组 指定用户所属的附加组。\n-s：Shell文件 指定用户的登录Shell。\n-u：用户号指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号\n\n2.2 添加用户：useradd2.3 设置密码：passwduseradd tomsu tom #切换用户验证cd /home/ #查看home目录验证passwd tom #给tom用户设置密码\n\n\n注意：\n\n输入密码没有提示也不显示\n密码长度要求大于8位\n密码不能是回文（123321…）\n\n\n2.4 修改用户：usermodusermod -l tomcat tom #将tom用户改名为tomcat#如果tom用户正在被 进程使用，需要先杀死进程，然后修改kill -9 PID(进程号)ll /home/\n\n\n\n\n\n2.5 删除用户：userdeluserdel tomcatsu tomcat #验证\n\n-r选项，删除用户的同时，删除其家目录\nuserdel -r 用户名\n\n\n\n3、用户组管理为了方便用户管理，linux提出了组的概念：\n\n解析：\n\n新增一个用户，会默认创建一个组（当前用户自己）\n例如：创建 tom 用户，那么就会默认创建一个 tom 的组，一个用户可以有一个或多个组\n\nll /home/\n\n\ndrwx——. 21 shu(用户)  shu(用户组)    4096 9月   2 15:35 shu\n\n3.1 用户组命令\n创建用户组：groupadd [选项] 组名\n修改用户组：groupmod [选项] 组名\n查询用户所属组：groups  组名\n删除用户组：groupdel  组名\n\n注意：需要管理员权限\n3.2 新增用户组：groupaddgroupadd 是用于在Unix和Linux系统上创建新用户组的命令。用户组是一种将多个用户组织在一起以便于管理文件和权限的方式。以下是有关 groupadd 命令的详细信息：\n功能：\ngroupadd 命令用于创建新的用户组，它允许系统管理员或特权用户在系统上定义一个新的组。用户组通常用于组织用户，以便在文件访问权限和其他系统权限方面进行更细粒度的控制。\n常见参数：\n\n1.-g, –gid GID：指定用户组的数值标识（Group ID），通常是一个非负整数。这个参数允许您明确设置用户组的GID，如果不指定，默认将分配下一个可用的GID。\n\n2.-r, –system：创建一个系统用户组。系统用户组通常用于系统进程和服务，其GID的范围通常较低。这个参数会将GID范围限制在较低的范围内。\n\n3.-f, –force：即使GID已存在，也创建用户组。这对于在使用相同GID的现有用户组的情况下创建用户组很有用。\n\n\n\ngroupadd kaifazu #创建\n\n1.创建一个名为 mygroup 的用户组：\ngroupadd mygroup\n\n2.创建一个系统用户组：\ngroupadd --system sysgroup\n\n3.指定GID创建用户组：\ngroupadd -g 1001 mygroup\n\n4.创建用户组，即使GID已存在：\ngroupadd --force existinggroup\n\n实战中的使用：\n在实际应用中，groupadd 命令用于创建用户组，这在多用户环境中对文件和目录的权限管理非常有用。用户组允许管理员将多个用户组织在一起，并为它们分配相同的权限或访问级别。\n例如，您可以创建一个用户组来管理某个项目的文件，只有组内的用户才能访问这些文件。\n在实际运用中，通常需要以超级用户或拥有适当特权的用户身份运行 groupadd 命令。系统管理员通常使用此命令来维护用户组，以确保系统上的适当文件和目录权限。要详细了解 groupadd 命令的用法和系统上的特定约定，请查阅您所使用的系统的文档或手册。\n3.3 修改用户组：groupmodgroupmod 是一个用于修改现有用户组的命令，它可用于Unix和Linux系统。这个命令允许管理员或特权用户更改用户组的各种属性，如名称、GID（Group ID）和成员。以下是有关 groupmod 命令的详细信息：\n功能：\ngroupmod 命令的主要功能是修改现有用户组的属性。这包括更改用户组的名称、GID以及添加或删除用户组的成员。\n常见参数：\n\n1.-g, –gid GID：指定用户组的新GID。这可用于更改用户组的Group ID。\n\n2.-n, –new-name NEW_NAME：指定用户组的新名称。使用此参数可以更改用户组的名称。\n\n3.-o, –non-unique：允许使用非唯一的GID。通常GID必须唯一，但使用此参数可以允许多个用户组具有相同的GID。\n\n4.-A, –add-user USER：向用户组添加成员。\n\n5.-R, –remove-user USER：从用户组中移除成员。\n\n\n示例：\n#1.更改用户组的名称：groupmod -n yunweizu kaifazugroupmod -n newgroupname oldgroupname#这会将名为 oldgroupname 的用户组的名称更改为 newgroupname。#2.更改用户组的GID：groupmod -g 1001 mygroup#这会将名为 mygroup 的用户组的GID更改为 1001。#3.添加成员到用户组：groupmod -A username mygroup#这会将名为 username 的用户添加到名为 mygroup 的用户组中。#4.从用户组中移除成员：groupmod -R username mygroup这会从名为 mygroup 的用户组中移除名为 username 的用户。\n\n\n\n实战中的使用：\n在实际应用中，groupmod 命令用于修改现有用户组的属性，这对于管理用户组和其成员非常有用。\n例如，如果您需要更改用户组的名称、GID或成员，可以使用 groupmod 命令轻松完成。通常需要以超级用户或拥有适当特权的用户身份运行 groupmod 命令，因为修改用户组的属性可能涉及到文件和目录的权限。\ngroupmod 命令使管理员能够更好地管理系统中的用户组，并确保它们适应系统的需求。要详细了解 groupmod 命令的用法和系统上的特定约定，请查阅您所使用的系统的文档或手册。\n3.4 查看用户组：cat  /etc/groupcat  /etc/group | grep &quot;kaifazu&quot;#输出root:x:0:bin:x:1:daemon:x:2:sys:x:3:。。。\n\n\n第二种：groups 用户名\n\n查看：group shu，shu用户属于shu和wheel两个用户组\n\nwheel组是一个用于管理系统权限的特殊用户组\nwheel组控制哪些用户可以通过 su 或者 sudo 命令切换到超级用户\n\n\ngroups shugroups root\n\n\ngroups 是一个用于显示用户所属用户组的命令，它在Unix和Linux系统中非常常用。这个命令允许用户查看与其关联的用户组，以便确定他们在系统中的组成员身份。以下是有关 groups 命令的详细信息：\n功能：\ngroups 命令的主要功能是列出当前登录用户所属的用户组。每个用户在系统中可以属于一个主要组以及多个附加组，groups 命令会显示所有这些组的名称。\n常见参数：\n\n1.- username：指定要查看其所属用户组的用户的用户名。如果未提供用户名，则默认为当前登录用户。\n\n示例：\n#1.查看当前登录用户所属的用户组：groups#这会列出当前登录用户所属的主要用户组以及附加用户组的名称。#2.查看指定用户所属的用户组：groups username#这会列出指定用户名的用户所属的主要用户组以及附加用户组的名称。\n\n\n实战中的使用：\n在实际应用中，groups 命令通常用于以下情况：\n1.确定用户的权限：通过查看用户所属的用户组，系统管理员或普通用户可以确定用户在系统上具有哪些文件和目录的访问权限。\n2.管理文件和目录权限：知道用户所属的用户组对于在Unix&#x2F;Linux系统上分配文件和目录权限非常重要。管理员可以使用这些信息来设置适当的文件权限，以确保用户可以访问所需的资源。\n3.协作和文件共享：在多用户环境中，groups 命令可以用来查找共享相同项目或任务的用户，以便更好地进行协作和文件共享。\ngroups 命令是一个非常基本且有用的命令，它使用户能够了解其在系统中的组成员身份，而管理员可以使用它来管理文件和目录的权限。通常，任何用户都可以运行 groups 命令以查看自己所属的组。如果需要查看其他用户的组信息，通常需要相应的权限。\n3.5 删除用户组：groupdelgroupdel 是用于在Unix和Linux系统上删除现有用户组的命令。用户组是一种将多个用户组织在一起以便于管理文件和权限的方式。以下是有关 groupdel 命令的详细信息：\n功能：\ngroupdel 命令的主要功能是删除现有的用户组，从系统中将用户组的相关信息和配置项删除。这包括用户组的名称、GID（Group ID）以及与该用户组关联的用户组目录。\n常见参数：\n\n1.-f, –force：强制删除用户组，即使该用户组还有成员。如果用户组仍有关联的用户，使用此参数将删除用户组，并且相关用户将不再属于任何用户组。\n\n示例：\n#1.删除名为 mygroup 的用户组：groupdel mygroup#2.强制删除用户组（即使该用户组还有成员）：groupdel --force mygroup\n\n实战中的使用：\n在实际应用中，groupdel 命令用于删除不再需要的用户组。这可能发生在以下情况下：\n1.当一个项目或部门完成后，相关的用户组不再需要。\n2.当需要重新组织权限和文件系统结构时，某些用户组可能变得多余。\n3.当需要整理和清理系统上的用户组时，可以使用 groupdel 删除不再使用的组。\n请注意，删除用户组可能会影响与该组关联的文件和目录的权限，因此在实际操作中需要谨慎。通常需要以超级用户或拥有适当特权的用户身份运行 groupdel 命令。要详细了解 groupdel 命令的用法和系统上的特定约定，请查阅您所使用的系统的文档或手册。\n4、管理用户组成员：gpasswd4.1 gpasswd 介绍gpasswd命令是 etc/group和/etc/gshadow管理工具，用于将一个用户添加到组或者从组中删除\n4.2 gpasswd 使用语法：gpasswd [选项] 组名 \n\n#新增三个用户和一个用户组useradd user1useradd user2useradd user3groupadd kaifazu\n\n4.3 添加用户到组：-agpasswd -a 用户名 组名gpasswd -a user1 kaifazugpasswd -a user2 kaifazugpasswd -a user3 kaifazu\n\n\n\n4.4 查看组中用户grep &quot;组名&quot; /etc/groupgrep &quot;kaifazu&quot; /etc/group\n\n4.5 删除用户组 -dgpasswd -d 用户名 组名gpasswd -d user1 kaifazu\n\n\n5、配置文件5.1 用户的配置文件用户的配置文件存储在/etc/passwd\n文件中的每一行是一个用户信息，都具有相同的格式，使用 : 冒号分割成多个段\n\n[root@localhost ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin\n\n用户信息 字段解析\n\n从左到右：\n\n1.用户名\n2.密码占用符x\n3.用户id\n4.用户所属的组id\n5.说明解释\n6.用户的家目录\n7.用户默认shell\n/bin/bash，表示用户可以通过bash登录\n/sbin/nologin，表示用户不能登录系统\n\n\n\n\n修改用户说明内容：\nusermod -c &quot;测试用户&quot; user1\n\n \n用户的密码信息保存在/etc/shadow文件中\n文件中的每一行是一个用户密码信息，都具有相同的格式，使用 : 冒号分割成多个段\n\ngrep &quot;shu&quot; /etc/shadow \n\n\n[root@localhost ~]# grep &quot;shu&quot; /etc/shadow shutdown:*:17834:0:99999:7:::shu:$6$$KEB/QaM0rMZgLzqv0laYsDlHrwBneh53LaafJE5Ts2FHjzWNGtrD23pgnFpH6zMn/zAyv0XEj6hz.S/4hPF250:20313:0:99999:7:::\n\n字段解析：\n\n从左到右：\n简洁：用户名:加密密码:最后修改日期:最小天数:最大天数:警告天数:不活动天数:失效日期:保留字段\n\n1.用户名\n2.加密后的密码\n3.最后一次修改密码的时间戳（单位 天）\n4.密码的最小年龄（修改密码的最短时间间隔，0表示随时可以修改，1表示1天后可以修改）\n5.密码的有效期，99999表示永不过期\n6.密码过期警告提前显示的天数，7表示提前7天显示密码过期消息\n7.宽限期；指密码过期后还可以使用多少天\n8.账号的有效期\n\n\n5.2 用户组的配置文件用户组的信息存储在 /etc/group 文件中\n文件中的每一行是一个用户组信息，都具有相同的格式，使用 : 冒号分割成多个段\n\n字段解析\n\n从左到右：\n\n1.用户组名称\n2.用户组密码占位符\n3.GID\n4.组里面的成员信息，多个成员使用，号分隔\n\n\n6、免密登陆在linux中有两种登录方式，一种是使用密码登录，另外一种是使用密钥登录\n使用密钥可以使用免密登陆的效果\n\n从安全角度考虑，一般会禁用密码登录，强制使用密钥登录\n密钥是一个十六进制的内容，会存储在一个文件中\n密钥是通过算法生成，分为\t公钥和私钥\n\n\n简述 SSH 免密登录的原理。\n\n客户端生成非对称密钥对，ssh-keygen -t 密钥算法\n公钥上传至服务端authorized_keys\n登录时客户端用私钥签名\n服务端用公钥验证签名\n\n\n密钥信息摘要算法，常见的有：MD5，SHA-1…\n对称加密：通过待加密内容和一个密钥，混合通过算法加密后，可以得到一个密文\n非对称加密：分为公钥和私钥，常见的加密方式有 DSA, ECDSA, RSA\n6.1 创建密钥对语法：ssh-keygen -t 密钥算法\nssh-keygen -t ecdsa #生成密钥对\n\n#是否将密钥保存在默认文件，直接回车即可Enter file in which to save the key (/root/.ssh/id_ecdsa):#设置密钥的密码保护（完全免密，不需要密码保护，直接回车）Enter passphrase (empty for no passphrase):\n\n\n查看生成文件：\ncd ~/.ssh/\n\n\n6.2 部署公钥到服务端（配置 authorized_keys）服务端通过 ~/.ssh/authorized_keys文件存储 新人的公钥列表，客户端用私钥匹配公钥即可免密登陆\n\n注意：进入 .ssh 目录查看，有两种情况\n\n有authorized_keys文件，将.pub公钥的内容追加写入\t该文件即可： cat 公钥文件 &gt;&gt; authorized_keys\n没有authorized_keys文件，将公钥文件改名为authorized_keys 文件即可\n\n\ncd ~/.ssh #进入.ssh目录mv id_ecdsa.pub authorized_keys #没有authorized_keys 文件则改名\n\n\n接下来，将私钥下载到 windows，找一个合适的地方保存\n\nWindows 中保存私有的路径也是 ~&#x2F;.ssh 目录下载完成后 linux 中的 私钥文件就没有用了，可以删除\n注意：在 windows 下使用 cmd 执行命令\n\nwindows中cmd操作\nscp root@192.168.242.129:/root/.ssh/id_ecdsa C:\\Users\\NINGXIU\\.ssh\\id_ecdsa\n\n\n随后即可免密登陆\nssh username@hostnamessh root@192.168.242.129#完整命令ssh [-i 执行使用的私钥路径] [-p 指定端口号] 用户名@主机地址ssh -i C:\\Users\\NINGXIU\\.ssh\\id_ecdsa -p 22 root@192.168.242.129\n\n\n6.3 配置登录\n\n7、 安全加固为了系统安全，我们需要执行或者说修改一些东西，使服务器的安全性更好\n7.1  移除没有必要的用户\n清理冗余用户和限制系统伪用户登录(最小化用户攻击面)\n\n删除系统中没有必要使用的所有用户\nuserdel 用户名\n\n对于需要存在，但是不需要登录用户，全部禁止登录操作（nologin）\n\n修改方式：\nusermod -s &#x27;/sbin/nologin&#x27; 用户名 #禁止登录#或者usermod -L 用户名 #锁定用户账号（临时禁用） -L lock锁usermod -U 用户名 #取消锁定账号# 解释：通过 -L 锁定账号，本质上是在用户的密码前面加上！号，使密码验证失效\n\n\n\n将user1用户修改为nologin（root权限）\n&#x3D;&#x3D;方式一&#x3D;&#x3D;：禁止登录\nusermod -s /sbin/nologin user1 #禁止登录su user1 #验证#取消禁止登录usermod -s /bin/bash user1 #改回原来的路径\n\n\n&#x3D;&#x3D;方式二&#x3D;&#x3D;：锁定用户账号（临时禁用）\nusermod -L tom #临时禁用tom用户，锁定tom用户su tom #从root用户切换到ton用户，可行，跳过了密码验证su root su shusu tom #普通用户切换到tom，输入密码切换失败。原因：没有跳过密码验证， usermod-L锁住用户密码，实现用户禁用效果\n\n\n验证密码禁用：查看用户密码信息\ncat /etc/passwd | grep &quot;tom&quot;  \n\n\n 取消锁定\nusermod -U tomcat /etc/passwd | grep &quot;tom&quot; \n\n\n7.2 设置用户无操作自动退出\n用户长时间离开终端，设置自动退出shell，避免他人冒用会话（防止会话滥用）\n\n修改系统配置文件 /etc/profile \n#在系统配置文件中添加\t系统变量：export TMOUT=600  #单位默认为 s 秒,600即10echo &quot;export TMOUT=600&quot; &gt;&gt; /etc/profilesource /etc/profile\n\n\n解释：\n\n/etc/profile 是系统级shell配置文件，所有用户登陆时会加载该文件；\nTMOUT是控制shell空闲超时的环境变量，单位为“秒”\n\n\n\n7.3 设置最多记录的历史命令条数\n限制历史命令记录与退出清理痕迹（减少敏感信息泄露）\n防止敏感命令（如含密码的 mysql -p、ssh 登录记录）被恶意用户查看，降低信息泄露风险，同时满足安全审计要求。\n\n有的时候我们敲的命令中，可能包含一些敏感信息，因此，记录过多的历史记录就存在风险\n修改系统配置文件 /etc/profile \n#可以先查看一下是否存在环境变量HISTSIZE，如果存在就修改原有的，如果不存在就新增#有HISTSIZE环境变量就修改HISTSIZE=50 #仅保留50条命令历史#没有就新增export HISTSIZE=50source /etc/profile\n\n\n\n解释：HISTSIZE 是控制 shell 历史命令缓存数量的环境变量，设为50表示只保留最近的50条命令\n\n\n&#x3D;&#x3D;用户退出时清空历史记录&#x3D;&#x3D;\n修改用户的配置文件(普通用户下配置)：~/.bash_logout\nvim ~/.bash_logout#在配置文件里添加内容:history -cclearsource ~/.bash_logout\n\n \n\n解释：\n\n~/.bash_logout 是用户退出 shell时自动执行的脚本\nhistory -c 清空当前 shell 的历史命令缓存， clear 清屏，隐藏终端的历史内容\n\n\n7.4 强化密码策略\n强化强密码规则+有效期（提升密码的安全性）\n\n可以通过修改用户密码默认设置的配置文件，实现修改对用户密码的要求。\n\n场景：要求密码长度&gt;&#x3D;9， 90天内必须更换、密码到期前7天提示，至少1天后才能再次修改\n\n&#x3D;&#x3D;新用户密码策略&#x3D;&#x3D;\n修改系统默认密码策略 /etc/login.defs 文件\nPASS_MAX_DAYS  90   # 密码最长有效时间为 90天PASS_MIN_DAYS  1    # 密码修改时间间隔至少为 1 天（防止频繁修改密码）PASS_MIN_LEN   9    # 密码最小长度为 9 （对 root 用户无效，需要额外配置）PASS_WARN_AGE  7    # 密码到期前 7 天开始提示用户修改\n\n\n\nvim /etc/login.defssource /etc/login.dfs\n\n\n\n解释：\n\n/etc/login.defs是用户账号默认配置文件，上图参数控制新用户的密码策略（之前的用户不受影响）\n\n\n&#x3D;&#x3D;对已有用户应用密码策略&#x3D;&#x3D;\n使用chage命令修改\n#-M 90 设置最大有效期90天； -m 1设置最小时间间隔1天； -w 7 设置到期警告天数7天chage -M 90 -m 1 -W 用户名#通过-1选项产看当前用户的密码策略chage -l 用户名\n\n\n\n\n给 root用户单独配置密码长度\n/etc/login.defs设置PASS_MIN_LEN 对root无效，需要单独设置\n\n修改PAM（可插拔认证模块）密码质量模块的配置文件/etc/security/pwquality.conf\nvim /etc/security/pwquality.confsource /etc/security/pwquality.conf\n\n\n\n\n\n当前是注释状态，如果需要修改，放开注释，设置自定义的值即可\n解释：\nPAM（可插拔认证模块）的配置文件/etc/security/pwquality.conf中minlen变量控制密码最小长度，对所有用户生效（包括root）\n\n小结：安全加固的核心逻辑\n1.最小化用户权限（删除冗余用户、禁止不必要登录）\n2.限制会话时长(自动退出) TMOUT\n3.减少敏感痕迹(历史命令有效期) HISTSIZE\n4.强化密码复杂度(长度、有效期)\n\n四个维度，降低系统被攻击或滥用的风险\n第十一章\t权限管理1、目录和文件的基本属性1.1查看属性\n文件或者目录的详细信息，从左到右：\n\n权限（A区域）：记录当前文件或者目录的权限信息，第一个字符代表文件的类型：\nd 代表文件夹(目录)；- 表示文件； l 表示软链接文件\n后面的 r、w、x、-四个字符分别表示可读、可写、可执行、无权限\n\n\n硬链接数（B区域）：通俗的讲就是有多少种方式可以访问当前的文件或目录\n属主（C区域）：文件或者目录所属的用户\n属组（D区域）：文件或者目录所属的组\n大小（E区域）：文件（字节）或者目录的大小\n时间（F区域）：最后一次访问时间\n名称（G区域）：文件或目录的名称，以 . 开头的表示隐藏文件\n\n1.2 权限属性第一个区域（10位字符）展示的是文件或目录的权限属性\n[shu@localhost ~]$ ll总用量 4drwxr-xr-x. 2 shu shu    6 8月  13 22:55 公共drwxr-xr-x. 2 shu shu    6 8月  13 22:55 模板drwxr-xr-x. 2 shu shu    6 8月  13 22:55 视频drwxr-xr-x. 2 shu shu    6 8月  13 22:55 图片drwxr-xr-x. 2 shu shu    6 8月  13 22:55 文档drwxr-xr-x. 2 shu shu    6 8月  13 22:55 下载drwxr-xr-x. 2 shu shu    6 8月  13 22:55 音乐drwxr-xr-x. 9 shu shu 4096 9月   1 11:10 桌面\n\n权限属性解析如图：\n\n权限解释：\n\n权限分为属主权限，属组权限和其它用户权限三个部分，每个部分都是3个字符表示\n\n读，写，执行权限\n\n使用四个字符代表权限\n\nr：表示可读权限，可以查看当前文件或目录的内容\nw：表示可写权限，可以编辑(修改)当前文件或目录的内容\nx：表示可执行权限，可以执行当前脚本文件\n-：表示没有当前权限\n\n\n案例：a.txt文件的权限属性 -rwxr-xr-x\n\n1.3 属主和属组权限属主：文件或目录所属用户\n属组：文件或目录所属组\n\n 例如：公共 是一个目录，属主是shu，属组也是shu\n\ndrwxr-xr-x. 2 shu shu    6 8月  13 22:55 公共\n\n2、修改属组和属主属性2.1 修改属组：chgrpchgrp 命令用于变更文件或目录的所属组（change group），需要管理员权限执行\n常用语法：\nchgrp [-v] 用户组 目录sudo chgrp  root aaa #将 aaa 目录的属组修改为 rootsudo chgrp -v root aaa #将 aaa 目录的属组修改为 root(-v 显示提示语句)\n\n\n2.2 更改属主和属组：chown使用chown命令修改属主和属组（change owner）\n语法：\nchown [-R] 属主名 文件或目录名\t# 更改文件或目录的属主chown [-R] 属主名:属组名 文件或目录名 #同时更改属主和属组\n\n选项-R：表示递归处理指定目录以及子目录下的所有文件\n演示：\nchown root aaa/a.txt #更改aaa/a.txt文件的属主为rootchown root:root aaa/b.txt #同时更改aaa/b.txt文件属主和属组为rootchown shu:root aaa/c.txt #仅修改属组chown root:root bbb #修改bbb文件夹的属主和属主，目录中的内容没有同步修改chown -R  root:root bbb #-R递归修数 bbb 目录中的子目录或文件的属主属组属性\n\n\n\n3、修改权限属性3.1 数字权限文件或目录的基本权限有9个，分别是owner&#x2F;group&#x2F;others三个身份都有各自的的&#x2F;r&#x2F;w&#x2F;x权限\n数字权限对照表：\n读r-4\n写w-2\n执行x-1\n无权限- 0\n\n示例：bbb目录的权限信息 rwxrwxr-x\n\n权限可以使用数字代替，例如：owner权限&#x3D; rwx&#x3D;4+2+1&#x3D;7,7表示可读可写可执行group权限&#x3D; rwx&#x3D;4+2+1&#x3D;7,7表示可读可写可执行others权限&#x3D; r-x&#x3D;4+0+1&#x3D;5,5表示可读不可写可执行\n例如：r-xr-xr--对应的数字权限：554例如：r-xr-----对应的数字权限：540\n3.2 符号权限\nuser属主，使用符号u表示\n\ngroup属组，使用符号g表示\n\nothers其它用户，使用符号o表示\n\nall 所有身份，使用符号a表示\n\n\n添加、减少和设定使用+号，-号和=号来表示\n权限使用 r 、 w 、x\n通过符号修改权限\n\n需求：将.txt文件的权限修改为：可读可写可执行，可读不可写可执行，可读不可写可执行\nchmod u=rwx,g=rx,o=rx b.txt #给u添加x权限，g和o身份设置为rx权限，中间不能有空格chmod o-x b.txt #减少权限chmod a=rwx c.txt #给所有身份设定权限\n\n\n\n\n\n&#x3D;&#x3D;递归修改目录中所有内容的权限&#x3D;&#x3D;使用-R 选项实现\nchmod -R 644 aaa #使用数字递归修改权限chmod -R u+x,g=rwx,o+x aaa #使用符号递归修改权限\n\n\n\n练习：公司有一个开发团队(dev-group)，团队中有三个用户：java，erlang，golang用户\n有一个文件目录 &#x2F;tmp&#x2F;work 供用户开发\n实现：三个用户都对 &#x2F;tmp&#x2F;work 目录具有读写权限\n#创建三个用户和组，添加进组，创建文件目录，设置所有用户都可读写#创建三个用户和组useradd javauseradd erlang useradd golanggroupadd dev-group#添加用户进组gpasswd -a java dev-groupgpasswd -a erlang dev-groupgpasswd -a golang dev-group#查看组成员grep &quot;dev-group&quot; /etc/group  #创建文件目录mkdir -p  /tmp/work#修改目录属组为dev-groupchgrp -R dev-group tmpchgrp -R dev-group tmp/work#查看/tmp/work目录ll /tmp | grep work #设置所有用户可读写chmod -R 775 /tmp/work\n\n\n\n\n\n3.3 修改权限：chmod通过数字修改权限\n示例：修改atxt的权限，修改为：可读不可写可执行，可读不可写可执行，可读不可写可执行(755)\nchmod 755 a.txt \n\n\n\n第十二章 Linux常用操作1、yum源1.1 yum介绍\nCentOS系统使用：\nrpm 的方式的安装（类似于Windows下执行的exe安装包）\nyum [install remove search] [-y] 软件名称（类似于Windows下在应用商店安装，需要联网）\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\nUbuntu系统使用\napt [install remove search] [-y] 软件名称\ninstall 安装\nremove 卸载\nsearch 搜索\n-y，自动确认\n\n\n\n\n\n\nyum 和 apt 均需要root权限\n\n1.2 yum源介绍yum操作需要一个yum库，也就是yum源\n安装centos默认使用centos的yum源（国外的，很慢）目前国内也有很多优秀的 yum 源（比如：阿里、网易、搜狐）\nLinuxMirrors: GNU&#x2F;Linux 一键更换系统软件源脚本 (gitee.com)命令：\nbash &lt;(curl -sSL https://gitee.com/SuperManito/LinuxMirrors/raw/main/ChangeMirrors.sh)\n\n\n\n1.3 更换阿里yum源权限：root权限（在root账户进行操作）\n步骤：\n# 1.安装 wget 工具yum install -y wget# 2.备份原来的yum源cd /etc/yum.repos.d/  # 进入配置文件的目录mv CentOS-Base.repo  CentOS-Base.repo.bak #改名操作#3.下载阿里云的yum文件wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#查看下载的CentOS-Base.repo文件cat CentOS-Base.repo#4.删除之前的centos缓存，重新加载yum源文件yum clean all#5.新建缓存文件yum makecache#验证yum search tomcat\n\n\n\n\n\n验证：\n\n2 、软件安装与卸载2.1 软件安装的方式在Linux中有4中软件安装的方式\n\n源码安装：是下载好对应软件的源码，在本地编译使用\n二进制安装：是指下载别人已经编译好的软件二进制代码，在本地使用\nrpm安装：指的是 红帽包管理器（Redhat Package Manager），类似于Windows中的.exe安装程序\nyum安装：类似从软件商城中安装的方式，使用yum命令直接从软件仓库下载安装到本地使用（需要联网操作）\n\n2.2 安装 tree（root权限下操作）\ntree是一个以树形结构查看目录的工具\nyum search tree #搜索treeyum install -y tree #安装tree，-y表示一直确认treeyum remove tree -y #卸载tree\n\n\n\n\n验证：\n\n3、系统命令：systemctl3.1 基本使用功能：控制系统服务的启动关闭等\n语法：systemctl start | stop | restart | disable | enable | status 服务名\n\nstart，启动\nstop，停止\nstatus，查看状态\ndisable，关闭开机自启\nenable，开启开机自启\nrestart，重启\nis-enable, 验证状态\n\n启动mysql：\nsystemctl start mysqld #开启服务systemctl restart mysqld #重启服务systemctl stop mysqld #停止服务systemctl status mysqld #查看状态 systemctl is-enabled mysqld #验证状态\n\n\n\n3.2 防火墙防火墙常用命令：\n#1.查看已开放的端口号firewall-cmd --list-ports#2.开放端口firewall-cmd --add-port=3306/tcp --permanent#3.删除端口号firewall-cmd --remove-port=3306/tcp --permanent#4.重启防火墙#4.注意：添加或删除端口后，都需要重启防火墙firewall-cmd --reload#以下系统命令谨慎使用#关闭防火墙systemctl stop firewalld#禁止防火墙开机自动启动systemctl disable firewalld\n\n\n\n\n4、软链接：ln功能：创建文件、目录软链接（快捷方式）\n语法：ln -s 参数1 参数2\n\n-s 选项：表示创建软链接（固定用法）\n参数1：被链接的路径（原文件的绝对路径）\n参数2：要链接去的地方（快捷方式的名称和存放位置）\n\n\n注意：软链接指向源文件，在访问软链接的时候，实际访问到的是源文件中的数据\n\nmkdir -p aaa/bbb/ccc/ddd/eee #创建目录vim aaa/bbb/ccc/ddd/eee/abc.txt #编辑内容cat aaa/bbb/ccc/ddd/eee/abc.txt ln -s aaa/bbb/ccc/ddd/eee/abc.txt cba.txt #创建软链接cat cba.txt\n\n\n\n\n软链接和 mv移动的区别是什么？\nmv移动，是将原文件移动到目标路径下，原文件的路径发生改变软链接 只是在目标位置创建了一个访问原文件的快捷方式，原来的文件路径并没有发生变化（软链接只是一个指向，并不是物理移动）\n5、日期和时区5.1 日期命令 date语法：date [-d] [+格式化字符串]\n\n-d 按照给定的字符串显示日期，一般用于日期计算\n\n格式化字符串：通过特定的字符串标记，来控制显示的日期格式\n\n%Y   年%y   年份后两位数字 (00..99)\n%m   月份 (01..12)\n%d   日 (01..31)\n%H   小时 (00..23)\n%M   分钟 (00..59)\n%S   秒 (00..60)\n%s   自 1970-01-01 00:00:00 UTC 到现在的秒数（时间戳）\n\n\n\n示例：\n\n按照2022-01-01的格式显示日期\ndate +%Y-%m-%d\n\n按照2022-01-01 10:00:00的格式显示日期\ndate &quot;+%Y-%m-%d %H:%M:%S&quot; \n\n \n\n-d选项日期计算\n\n支持的时间标记为：\n\nyear 年\nmonth月\nday天\nhour小时\nminute分钟\nsecond秒\n\n-d选项可以和格式化字符串配合一起使用\n\ndate -d &quot;+1 day&quot; +%Y%m%d #显示后一天日期date -d &quot;+1 day&quot; +%Y%m%d #显示前一天日期date -d &quot;-1 month&quot; +%Y%m%d #显示上一月日期date -d &quot;+1 month&quot; +%Y%m%d #显示下一月日期date -d &quot;-1 year&quot; +%Y%m%d #显示前一年日期date -d &quot;+1 year&quot; +%Y%m%d #显示下一年日期\n\n \ndate &quot;+%Y-%m-%d %s&quot; #时间戳，单位秒\n\n\n5.2、修改时区：localtime 文件修改时区为中国时区\ncat /etc/localtime rm -f /etc/localtime \t#删除系统自带的localtime#在/etc目录下 创建软链接，名称为localtime，指向/usr/.../上海 时区信息sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #设置时区-东八区\n\n\n\n\n\n5.3、校准系统时间：ntp工具功能：同步时间\n安装：yum install -y ntp\n\n安装完成后，启动ntpd服务，会定期校准系统时间\n\n启动管理：systemctl start | stop | restart | status | disable | enable ntpd\nyum install -y ntpsystemctl start nptdsystemctl enable nptd #开机自启ntpdate -u ntp.aliyun.com #手动校准时间\n\n手动校准时间（需要 root 权限）：ntpdate -u ntp.aliyun.com\n5.4 虚拟机设置时间同步在虚拟机上设置时间同步\n\n6、ip和主机名6.1 ip地址每一台联网的电脑都会有一个IP地址，用于和其他计算机进行通讯\nIP地址有两个版本：v4和v6 版本\n格式：a.b.c.d\n\nabcd为0~255的数字\n\n特殊IP：\n\n127.0.0.1，表示本机\n0.0.0.0\n可以表示本机\n也可以表示任意IP（看使用场景）\n\n\n\n查看ip：ifconfig\n\n6.2 主机名功能：Linux系统的名称\n查看：hostname\n设置：hostnamectl set-hostname 主机名\nhostnamehostnamectl set-hostname 新名字#重新登陆即可看到修改后的主机名称\n\n\n6.3 域名解析IP地址很难记忆，生活中一般通过字符地址访问服务器，例如在浏览器中通过www.baidu.com(域名)访问百度的服务器地址\n域名通过 域名解析 访问到服务器\n模拟域名解析，访问本地的linux服务器\n修改C:\\Windows\\System32\\drivers\\etc\\下hosts文件：\n\n添加192.168.242.129 centos-shu\n\n\n\n6.4 配置VMware固定IP1.修改VMware网络\n\n\n2.设置Linux内部固定IP(静态IP)\n修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33\n\nvim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33\n\n示例文件内容：\nTYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;\t\t\t## 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot;\t\t## IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot;\t\t## 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot;\t\t## 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot;\t\t\t## DNS1服务器，和网关一致即可\n\n\n\n\n7、进程管理7.1 查看进程信息：ps命令功能：查看进程信息\n语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx\n\n-e 选项：显示全部的进程\n-f 选项：以完全可视化的形式展示信息\n\n\nUID：进程所属的用户id\nPID：进程的进程号\nPPID：进程的父id（启动了当前进程的其他的进程）\nC：此进程的CPU占用率（百分比）\nSTIME：进程的启动时间\nTTY：启动此进程的终端序号，？问号 表示非终端启动\nTIME：进程占用CPU的时间\nCMD：进程对应的名称或启动路径或启动命令\n\n\n并发、并行\n并发：两个或多个事件在一个时间段发生并行：两个或多个事件在同一时刻运行\n\n程序、进程、线程\n程序：我们电脑上安装的各种应用就是程序（例如QQ、腾讯视频…）\n\n本质上讲，程序就是一段可以完成某些特定功能的静态的代码块\n\n进程：程序运行起来，就是一个进程\n\n本质上讲，进程就是程序的一次执行过程，或者说是正在运行的程序，是系统进行资源分配的基本单位\n\n 线程：进程中的一个执行路径，是进程中的单个顺序控制流，是CPU的基本调度单位，一个进程可以是一个线程的，也可以是多个线程的（单线程进程和多线程进程）\n\n查看指定进程使用管道符，配合grep 查看指定的进程：\n\n可以根据进程名称、进程号、用户id 等过滤指定进程\n\ntailps -ef | grep tail #根据进程名称查找ps -ef | grep 56726 #根据进程号查找\n\n\n\n\n进程的其他操作：\nps -A  #显示系统的所有进程信息(只展示部分信息：PID、TIME、CMD)ps -u user #显示指定用户user的进程信息\n\n\n\n7.2 终止进程：kill命令功能：用于删除（停止）执行中的程序\n语法：kill [-s &lt;信息名称或编号&gt;][进程]或者kill [-l &lt;信息编号&gt;]\n\n-s &lt;信息名称或编号&gt;：指定信息\n-l &lt;信息编号&gt;：列出全部的信息名称\n\n查看信息编号：\n\n信息编号有64个，最常用的编号是 9， sigkill 表示强制终止进程\n\n\ntailps -ef | grep tail#强制终止57485这个进程,-9是信息编号，表示强制终止kill -9 57485\n\n\n\nkillall：终止所有进程\nkillall -u shu #终止shu用户下的 所有进程\n\n\n\n7.3 补充：pkill 终止（杀死）进程作用:\n\n终止正在运行的进程，以根据特定的条件（如进程名称）来匹配和终止进程。\n\n用于停止应用程序或服务的运行，或者用于清理不响应的或占用系统资源的进程。\n\n\n参数:\n1.-u &lt;用户名&gt;：指定要终止的进程所属的用户。\n2.-n：仅终止进程的最新（最后启动的）实例。\n3.-o：仅终止进程的最旧（最早启动的）实例。\n4.-x：精确匹配进程名称，不使用模糊匹配。\n5.-f：匹配进程的全命令行（包括参数）。\n6.-t &lt;终端&gt;：指定要终止的进程所在的终端。\n7.-signal：指定要发送给匹配进程的终止信号。常见的信号包括 -TERM（默认，相当于 kill 命令的 SIGTERM）和 -KILL（相当于 kill 命令的 SIGKILL）。\n示例:\n1.终止名为 myapp 的进程：\n  pkill myapp\n这将终止所有名称为 myapp 的进程。\n2.终止用户名为 user1 的所有进程：\n  pkill -u user1\n这将终止用户 user1 拥有的所有进程。\n3.终止具有完整命令行 myapp –option 的进程：\n  pkill -f myapp –option\n这将终止命令行中包含 myapp –option 的进程。\n4.终止名称为 myapp 的进程，使用 SIGKILL 信号：\n  pkill -9 myapp\n这将使用 SIGKILL 信号强制终止名为 myapp 的进程。\n使用情况\n\n1.停止应用程序或服务：当需要停止正在运行的应用程序或服务时，可以使用 pkill 根据其名称来终止相关进程。\n2.清理资源：用于清理不响应或不需要的进程，以释放系统资源。\n3.脚本和自动化：pkill 可以在脚本中使用，以便自动化地终止特定条件下的进程，例如，当系统资源耗尽或出现故障时。\n4.诊断和故障排除：用于诊断问题或故障排除，以终止问题进程，然后重新启动它们或采取其他必要的措施。\n\n\n注意，pkill 可能需要以超级用户权限运行，以便终止其他用户的进程或特定系统进程。在使用时，请谨慎，以免误终止重要的进程。\n\n8.网络传输8.1 端口的概念端口：是设备与外界通讯交流的出入口\n虚拟端口：是计算机内部的端口，不可见，是用来操作系统和外部进行交互使用的\n\nip相当于小区地址，小区中有很多住户（端口），端口相当于住户的门牌号，通过端口找到具体的程序\nlinux可以支持65535个端口\n公认端口：1~1023，一般用于系统内置或知名的程序预留使用\n注册端口号：1024~49151(端口号可以随意使用)\n动态端口：&gt;49151，通常不会固定绑定程序，用于临时使用\n\n8.2 查看端口占用：nmap命令功能：查看端口占用情况\n语法：nmap ip地址\nyum install -y nmap #安装nmap工具nmap 127.0.0.1 #查看本机的端口占用情况\n\n\n8.3 查看端口占用：netstat命令功能：查看指定端口占用\n用法：netstat -anp | grep xxx\nnetstat -anp | grep 3306 #查看3306端口被哪个进程使用netstat -anp | grep 9090 #没反应表示9090端口没有被使用\n\n需要root权限\n\n8.4 测试网络联通：ping作用：测试网络是否连通\n语法：ping [-c num] 参数\n\n-c 选项：检查的次数，如果不指定，将无限次持续检查\n参数：IP地址或者主机名，被检查的服务器IP地址或者主机名\n\nping baidu.comping -c 5 baidu.com #测试5次\n\n\n\n\n8.5 文件下载器：wget作用：是非交互式的文件下载器，可以在命令行内下载网络文件\n语法：wget [-b] url\n\n-b 选项：可选，表示后台下载，会将日志写入到当前工作目录的wget-log文件\n\nurl：下载的链接地址\n\n\nwget http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz\n\n\n\n\n8.6 发送网络请求：curl作用：发送http网络请求，可以用于下载文件、获取信息等语法：curl [-O] url\n\n-O 选项：用于下载文件，当url是下载连接时，可以使用此选项保存文件\n\nurl参数：要发起请求的网络地址\n\n\ncurl cip.cc #返回当前网络信息\n\n\n下载压缩包：\ncurl -O http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz\n\n\n8.7 跨系统传输文件：scp作用：跨设备、跨系统传输文件到linux系统中\n语法：\n#将 文件1 传输到 文件2 的文件scp [选项] [[用户名]@设备ip或设备名称:]文件1 \t[[用户名]@设备ip或设备名称:]文件2\n\n\n\n#本地windows传输至linuxscp &quot;d:\\test.txt&quot; root@192.168.242.129:/root\n\n\n\n#linux传输至windows 有问题scp &quot;hello.txt&quot; ningxiu@127.0.0.1:/d:\n\n\n\n9、系统信息查看9.1 查看系统版本查看centos版本： cat /etc/centos-release\n查看内核版本： uname -r\n\n[root@localhost ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core) [root@localhost ~]# uname -r3.10.0-957.el7.x86_64\n\n9.2  查看内存使用情况：free常用命令： free -h，选项 -h 让输出更易读\n\n9.3 查看磁盘占用：df  和 du&#x3D;&#x3D;df命令&#x3D;&#x3D;:作用：查看磁盘占用，磁盘总容量、用了多少、剩余多少，显示文件系统格式\n选项：-h，以更人性化的单位显示\n\n&#x3D;&#x3D;du命令&#x3D;&#x3D;：作用：查看单个文件&#x2F;目录，文件&#x2F;目录总共占用多少空间\ndu #查看目录中的所有文件或目录的占用空间，默认单位kbdu -h mysqldu -h test.txtdu \n\n\n指定查看深度(层级)\n\n–max-depth 选项指定查看的深度， 数字 1 表示只查看1层目录\n\ndu -h --max-depth=1 #只查看1层目录\n\n\n\n&#x3D;&#x3D;df和du区别&#x3D;&#x3D;：\n\ndf ：查看磁盘占用情况，检查系统分区是否快满\ndu：查看单个文件&#x2F;目录的占用情况，定位“哪个文件&#x2F;目录占用空间最多”\n通过df掌握全局空间，通过du定位局部占用，高效管理磁盘\n\n9.4 查看主机状态：top功能：查看主机运行状态，可以通过top命令查看cup、内存的使用\n语法：top，查看基础信息\n\ntop - 14:09:26 up  2:31,  2 users,  load average: 0.00, 0.01, 0.05Tasks: 217 total,   1 running, 216 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1863248 total,   175304 free,  1092132 used,   595812 buff/cacheKiB Swap:  2097148 total,  2092028 free,     5120 used.   517632 avail Mem \n\n第一行(任务队列信息)：\n\ntop：命令名称；14:09:26：表示当前系统时间；up  2:31：表示启动时间；\n2 users：表示2个用户登陆；load average: 0.00, 0.01, 0.05：表示负载时间\n\n第二行(进程信息)：\n\nTasks：表示进程进程数量；1 running：表示1个进程正在运行；216 sleeping：表示266个进程处于睡眠状态；0 stopped：表示0个停止进程； 0 zombie：0个僵尸进程\n\n第三行(CPU信息)：\n\n%Cpu(s)：CPU使用率；\n\nus：用户CPU使用率；\nsy：系统CPU使用率；\nni：高优先级进程占用时间百分比；\nid：空闲CPU率；\nwa：IO等待CPU占用率；\nhi：CPU硬件中断率；\nsi：CPU软件中断率；\nst：强制等待CPU占用率\n\n\n第四行(物理内存信息)：\n\nKiB Mem：物理内存；\n\ntotal：总量；free：空闲； used：使用；buff/cache：buff和cache占用\n\n\n第五行(交换分区swap信息)\n\nKiB Swap：交换内存；\n\ntotal：总量；free：空闲； used：使用；avail Mem：可用内存\n\n\ntop命令的内容：\n\n\nPID：进程id\nUSER：进程所属用户\nPR：进程优先级，越小越高\nNI：负值表示高优先级，正表示低优先级\nVIRT：进程使用虚拟内存，单位KB\nRES：进程使用物理内存，单位KB\nSHR：进程使用共享内存，单位KB\nS：进程状态（S休眠，R运行，Z僵死状态，N负数优先级，I空闲状态）\n%CPU：进程占用CPU率\n%MEM：进程占用内存率\nTIME+：进程使用CPU时间总计，单位10毫秒\nCOMMAND：进程的命令或名称或程序文件路径\n\n\n常用语法：\ntop\t#实时显示所有进程信息top -c\t#实时显示所有进程信息(显示完整命令)top -p PID #实时显示指定进程信息top -p 4642\n\n\n\n可用选项：\n\n交互式模式中，可用快捷键：\n\n9.5 查看磁盘和CPU：iostat作用：查看CPU、磁盘的相关信息\n语法：isostat [-x] [num1] [num2]\n\n选项 [-x]，显示更多信息\n参数 [num1] 刷新间隔 ，[num2]刷新次数\n\n\n\ntps：该设备每秒的传输次数\n\n“一次传输”意思是”一次I&#x2F;O请求”\n多个逻辑请求可能会被合并为”一次I&#x2F;O请求”\n“一次传输”请求的大小是未知的\n\n\n显示更详细的信息：iostat -x\n\n\n%user：CPU在用户态执行的时间百分比。\n%sys：CPU在内核态执行的时间百分比。\n%iowait：CPU花费在等待I&#x2F;O操作完成上的时间百分比，与磁盘I&#x2F;O性能密切相关。\n%idle：CPU空闲的时间百分比。\n\nrrqm&#x2F;s：    每秒这个设备相关的读取请求有多少被合并Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge, 提高IO利用率, 避免重复调用）；wrqm&#x2F;s：    每秒这个设备相关的写入请求有多少被合并Merge了。rsec&#x2F;s：    每秒读取的扇区数；sectorswsec&#x2F;：    每秒写入的扇区数。rKB&#x2F;s：    每秒发送到设备的读取请求数wKB&#x2F;s：    每秒发送到设备的写入请求数avgrq-sz：  平均请求扇区的大小avgqu-sz：  平均请求队列的长度。毫无疑问，队列长度越短越好。await：      每一个IO请求的处理的平均时间（单位是微秒毫秒）。svctm        表示平均每次设备I&#x2F;O操作的服务时间（以毫秒为单位）%util：     磁盘利用率\n9.6  网络次数：sar -n DEV作用：查看网络相关统计\n语法：sar -n DEV num1 num2\n选项-n ：表示查看网络，DEV表示查看网络接口\n参数： [num1] 刷新间隔(不填) [num2]刷新次数\nsar -n DEV 3 2 #查看2次，间隔3秒钟刷新一次，并最终汇总平均记录\n\n\n\nIFACE 本地网卡接口的名称rxpck&#x2F;s 每秒钟接受的数据包txpck&#x2F;s 每秒钟发送的数据包rxKB&#x2F;S 每秒钟接受的数据包大小，单位为KBtxKB&#x2F;S 每秒钟发送的数据包大小，单位为KBrxcmp&#x2F;s 每秒钟接受的压缩数据包txcmp&#x2F;s 每秒钟发送的压缩包rxmcst&#x2F;s 每秒钟接收的多播数据包\n\n9.5 小结1、du,top,iostat,sar的作用\n\ndu：用于分析文件和目录占用的磁盘空间。du -sh /path/可以显示指定路径的总占用空间，以易读的形式（如KB、MB、GB）展示，是定位大文件和分析磁盘占用的合适工具。\ntop：专注于显示当前最占用资源的系统进程，重点在CPU和内存使用情况，与磁盘占用分析无关。\niostat：用于实时监控磁盘I&#x2F;O性能，显示磁盘读写速率、设备利用率等。它可以帮助分析磁盘性能，但无法直接定位大文件。\nsar：是系统活动报告工具，用于记录和分析系统的各类性能指标。sar -n DEV专门用于监控网络设备性能，与磁盘空间分析无直接关联。\n\n10、环境变量10.1 理解概念概念：环境变量是操作系统在运行的时候，记录的一些关键内容，用以辅助系统的运行\n环境变量的作用：简单理解为在任意位置可以通过变量名来执行可执行的程序\n例如：cd命令在/usr/bin/cd目录下，但是可以在任意工作目录执行cd命令\n10.2 查看环境变量：env环境变量是key&#x3D;value的结构组织数据：\n\n环境变量记录了：\n\n\nHOME&#x3D;&#x2F;home&#x2F;shu 用户的home路径\nPATH&#x3D;…… 用来记录系统执行命令时搜索的路径\n\n例如：执行cd命令，会依次搜索path中指定的路径：/usr/local/sbin,usr/local/bin,usr/sbin,usr/bin直到找到cd命令的执行脚本\n\n10.3 PATH 变量记录了执行程序的搜索路径\n\n解析：\n当需要执行某个命令时，默认在PATH环境变量配置的搜索路径中查找 该命令的执行脚本，找到则可以执行该命令\n好处：在任意位置可以执行命令\n\n[shu@localhost ~]$ which pwd/usr/bin/pwd[shu@localhost ~]$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin[shu@localhost ~]$ pwd/home/shu\n\n\n可以自定义路径加入PATH内，实现自定义命令在任意地方均可执行的结果\n1.创建目录\t2.创建文件\t3.编辑文件内容\t4.修改可执行权限\t5.修改path路径值\nmkdir myenv #创建目录touch myenv/sayhi #创建文件vim myenv/sayhi#编辑内容： echo &quot;hi ,nice to meet you!!&quot;sayhi #权限不足chmod 777 myenv/sayhi #修改可执行权限sayhi #输出内容export PATH=$PATH:/home/shu/myenv #临时修改环境变量path值#任意位置可以执行：sayhi\n\n永久修改：\n\n10.4 $符号可以取出指定的环境变量的值\n语法：$变量名\n示例：\necho $PATH，输出PATH环境变量的值\necho $&#123;PATH&#125;ABC，输出PATH环境变量的值以及ABC\n如果变量名和其它内容混淆在一起，可以使用${}\n\n10.5 自定义环境变量\n临时设置：export 变量名=变量值\n特点：只能在当前会话Shell中使用，会话关闭或重启系统后失效\n使用场景：临时测试、脚本内部使用。\n\n\n永久设置：\n针对用户，设置用户HOME目录内：.bashrc或~/.profile文件\n相同的用户，不同的会话，可以访问\n仅限当前用户，其他用户不可取\n\n\n针对全局（root权限），设置/etc/profile\n通过source 配置文件命令，立刻生效，或者重启客户端\n\n\n\n#1、设置临时变量export shu=&quot;666&quot;echo $shu\t#取值并输出 666#2、设置用户级别变量echo &#x27;export hiShu=&quot;hello shu&quot;&#x27; &gt;&gt;  .bashrc #配置变量hiShusource .bashrc #重新加载配置文件（让更新后的配置文件立即生效）echo $hiShu #取值输出 hello shu#3、设置全局变量(root权限)echo &#x27;export hello=&quot;hello linux&quot; &#x27;&gt;&gt; /etc/profilesource /etc/profileecho $hello #取值输出 hello linux\n\n\n\n\n\n\n\n\n\n\n\n10.6 小结1、什么是环境变量环境变量是一组信息记录，类型key&#x3D;value，用于操作系统运行的时候记录关键信息\n2、查看环境变量env命令\n3、通过 $ 取出环境变量的值4、什么是PATH，作用是什么？环境变量PATH记录一组目录，目录和目录之间使用冒号 : 分隔\n记录的是命令的搜索路径，当执行命令时，会从记录的目录中依次搜索要执行的命令\n可以通过修改PATH变量值，添加自定义的命令搜索路径\n临时添加方法：export PATH&#x3D;$PATH:自定义路径\n5、如何修改环境变量\n临时生效\n永久生效\n针对用户，设置用户HOME目录内：.bashrc文件\n针对全局，设置/etc/profile\n通过source 配置文件命令，立刻生效，或者重启客户端\n\n\n\n11、压缩解压11.1 压缩命令：gzip作用：用于压缩文件，文件压缩后，会多出gz 扩展名的文件\n\n注意：源文件消失，保留gz结尾的压缩文件\n\n语法： gzip [选项] [文件或目录]\n选项：\n\n-d：表示解压缩\n-v：列出详细信息\n查看 gzip 压缩文件的原始文件名：\n\ngzip aaa/a.txt #压缩单个a.txt文件gzip aaa/* #批量压缩aaa目录下所有文件，已经压缩过的a.txt.gz没有改变\n\n\n\n\n\n解压缩：\ngzip -dv aaa/* #解压缩aaa目录下的所有压缩文件，列出详细信息\n\n\n\n\n扩展： 解压缩：gunzip\n作用：用于解压缩，和gzip -d 作用是一样的\n\n11.2 压缩命令：zipzip 命令是在 Linux 系统中用于创建和提取 ZIP 格式压缩文件的命令。它可以将多个文件和目录打包成一个 ZIP 归档文件，并可以对 ZIP 文件进行解压缩操作。\n基本语法：\nzip [选项] [归档文件名] [文件或目录...]\n常用选项：\n\n-r：递归地将目录及其内容添加到 ZIP 文件中。\n-q：静默模式，不显示处理过程的输出信息。\n-d：从 ZIP 文件中删除指定的文件。\n-u：更新 ZIP 文件，只添加新文件或修改过的文件。\n-l：列出 ZIP 文件的内容信息，包括文件大小和压缩比率。\n\n作用：用于压缩文件，文件压缩后会产生另外的.zip 结尾的文件\n\n注意：和gzip的区别是，gzip压缩是替换(gz压缩文件是替换源文件)，zip是另外生成(源文件保留，额外生成zip文件)\n\n语法：zip [选项] [文件]\n选项：\n\n-q ：不显示指令执行过程\n-r ：递归处理，将指定目录下的所有文件和子目录一并处理\n\n#将aaa目录递归压缩成abc.zip文件zip -rq abc.zip aaa #将aaa目录下的所有文件压缩为aaa目录下的cba.zip文件#使用*获取指定目录下的所有文件或目录zip -rq aaa/cba.zip aaa/* \n\n\n\n解压缩：unzip作用：只能用于解压缩 .zip扩展名的压缩文件\n常用语法：\nunzip -l 压缩文件  #查看压缩文件中的内容unzip -d 指定目录名 压缩文件名  #解压到指定目录\n\n选项：\n\n-l ：用于显示压缩文件内包含的文件\n-d ：用于指定文件加压缩后存储的目录\n\nunzip -l abc.zip #-l查看压缩文件内包含的内容unzip -d bbb aaa/cba.zip #将aaa目录下的cba.zip文件解压到当前bbb目录下，bbb目录不存在则会自动创建\n\n\n11.3 压缩命令：bzip2作用：是.bz2文件的压缩程序\n\n注意：压缩过后生成.bz2文件，并删除源文件\n\n\n和gzip对比：\n\nbz2格式的算法更先进，压缩比更好\ngz格式相对 压缩时间更快\n\n\nbzip2 aaa #不能直接压缩目录bzip2 aaa/a.txt #压缩指定文件，并删除源文件ll aaa\n\n\n\n**解压缩：**bunzip2作用：用于 .bz2 文件的解压缩程序\n选项：-v , 显示解压缩文件时的详细信息\nbunzip aaa/a.txt.bz2bzip2 aaa/a.txtbunzip -v aaa/a.txt.bz2 #-v显示解压缩信息\n\n\n\n11.4 打包命令：tartar  解压和压缩工具\n详解：\ntar 命令是在 Linux 系统中用于创建和提取归档文件的常用命令。它的名称代表 “tape archive”（磁带归档），虽然最初设计用于磁带备份，但现在主要用于创建和操作归档文件。\n基本语法：\ntar [选项] [归档文件] [文件或目录...]\n常用选项：\n\n-c：创建新的归档文件。\n-x：从归档文件中提取文件。\n-f：指定归档文件的名称。\n-v：显示详细信息，例如正在处理的文件列表。\n-z：使用 gzip 压缩或解压缩归档文件。\n-j：使用 bzip2 压缩或解压缩归档文件。\n-C：指定提取文件的目标目录。\n\n\n打包和压缩的区别：\n\n打包：将一堆文件或者目录变成一个总的文件\n压缩：将一个大的文件经过某种压缩算法变成一个小文件\n\n\ntar命令：\n作用：打包、压缩和解压文件\n\n注意：tar命令本身不具有压缩功能，通过调用压缩功能实现\n\n常用语法：\ntar -cvf 打包文件名  文件名  # 打包文件，并指定打包之后的文件名（仅打包不压缩）tar -zcfv 打包文件名\t文件名/目录名\t #打包文件，并指定打包之后的文件名（打包并压缩）tar -ztvf 压缩文件名   #查看压缩文件中有哪些文件tar -zxvf 压缩文件名   #解压缩包tar -xvf 压缩文件名\t  #解包tar -czf  #打包并用gzip压缩tar -xzf  #解压gzip压缩的tar包tar -tvf  #查看tar包内文件列表\n\n选项：\n\n-c 建立新的压缩文件（创建）\n\n-v 在压缩或解压缩过程中显示正在处理的文件名（详细信息）\n\n-f &lt;备份文件&gt; 指定压缩文件，后面必须跟上要处理的文件名。（文件名）\n\n-z 通过gzip支持的压缩或解压缩。（gzip）\n\n-t  表示出压缩文件中的内容（列表）\n\n-x ，解压\n\n\n仅打包不压缩：\ncd aaatar -cvf a.tar a.txt #将a.txt打包成a.tar，并显示打包过程#选项-cvf表示建立新压缩文件，显示指令执行过程，指定打包后文件为a.targzip a.txtlsgunzip a.txt.gz\n\n\n&#x3D;&#x3D;打包并压缩&#x3D;&#x3D;：\n\n调用gzip功能将b.txt打包并压缩\n\ntar -zcvf b.gz b.txt #打包的格式可以自定义，gz。。。#选项-z功能表示调用gzip功能\n\n\n练习：将aaa目录打包并压缩为aaa.tar.gz文件\ncd ..ll aaatar -zcvf aaa.tar.gz aaa#.tar.gz 文件后缀用来标识该文件是打包并压缩的文件#或者tar -cvf aaa.tar aaagzip aaa.tarlsgunizp aaa.tar.gz\n\n\n\n注意：\n\n参数f后面的文件名称是自定义的，通常使用.tar表示打包文件；\n如果加参数（表示调用了.gzip工具压缩），一般文件的名称以.tar.gz或者.tgz来表示压缩过的tar包\n\n\n查看tar打包文件\n\n\n-ztvf 或者 -ztf \n\ntar -ztvf aaa.tar.gz\t#-zyvf查看压缩包中的内容\t#-z调用gzip功能 #-t列出文件中的内容 \n\n\n\n\n&#x3D;&#x3D;解压缩包&#x3D;&#x3D;\n\n\n解压缩aaa.tar.gz\n\ntar -zxvf aaa.tar.gz #会覆盖原来的aaa目录#调用zip功能(-z),解压(-x),显示指令执行过程(-v),指定文件(-f) aa.tar.gz\n\n\n\n注意：\ngunzip aaa.tar.gz\t#调用gunzip解压gzip压缩的文件，解压后谁一个tar包 aa.tartar -xvf aaa.tar\t#需要通过-xvf解包\n\n\n\n11.5 小结\n.gz ：由gzip工具压缩的文件\n.zip ：由 zip 压缩工具压缩的文件\n.bz2 ：由bzip2压缩工具压缩的文件\n.tar：tar 命令打包的文件 (tar 本身没有压缩和解压的功能，把多个文件&#x2F;目录合并成一个文件)\n.tar.gz ：经过tar打包，并调用gzip工具压缩后的文件\n\n第十三章、正则表达式1、什么是正则表达式？正则表达式是一种用于匹配、查找、替换文本的模式描述语言。它能通过简洁的符号组合，定义复杂的文本规则，广泛应用于文本处理、数据验证、日志分析等场景（如 Linux 的 grep&#x2F;sed&#x2F;awk，编程语言 Python&#x2F;Java，文本编辑器 VS Code&#x2F;Sublime 等）。\n2、基础元字符（单个字符匹配）元字符是正则的“基础零件”，用于描述单个字符的匹配规则。\n\n\n\n元字符\n含义\n示例\n匹配效果\n\n\n\n.\n匹配任意单个字符（除换行符 \\n）\na.c\n匹配 abc、a1c、a&amp;c 等\n\n\n[abc]\n匹配方括号内的任意一个字符\n[abc]\n匹配 a、b 或 c\n\n\n[^abc]\n匹配非方括号内的任意一个字符\n[^abc]\n匹配 d、1、@ 等（除 a&#x2F;b&#x2F;c）\n\n\n[a-z]\n匹配小写字母 a 到 z 中的任意一个（字符范围）\n[a-z]\n匹配 a、m、z 等\n\n\n[A-Z]\n匹配大写字母 A 到 Z 中的任意一个\n[A-Z]\n匹配 A、M、Z 等\n\n\n[0-9]\n匹配数字 0 到 9 中的任意一个\n[0-9]\n匹配 0、5、9 等\n\n\n[0-9] 可以用 \\d 表示\n实践案例：基础元字符匹配现有文本文件 test.txt，内容：\nabca1ca&amp;cADCaZc123acabcabbbcaaabaabaaaab\n\n\n匹配“a 开头、c 结尾，中间任意单个字符”：\ngrep &#x27;a.c&#x27; reg.txt\n\n\n解释：a.c 中 . 匹配中间任意字符。\n效果：输出 abc、a1c、a&amp;c。\n\n \n\n匹配“a 开头、c 结尾，中间为小写字母”：\ngrep &#x27;a[a-z]c&#x27; reg.txt\n\n\n解释：[a-z] 限制中间为小写字母。\n效果：输出 abc（aZc 中 Z 是大写，不匹配）。\n\n\n\n\n3、量词（重复次数匹配）量词用于描述“前面的字符&#x2F;子表达式重复多少次”。\n\n\n\n量词\n含义\n示例\n匹配效果\n\n\n\n*\n匹配前面的元素 0 次或多次\nab*c\n匹配 ac（b 出现 0 次）、abc（b 出现 1 次）、abbbbbc（b 出现多次\n\n\n+\n匹配前面的元素 1 次或多次\nab+c\n匹配 abc、abbbbbc（b 至少出现 1 次），不匹配 ac\n\n\n?\n匹配前面的元素 0 次或 1 次（可选）\nab?c\n匹配 ac（b 出现 0 次）、abc（b 出现 1 次），不匹配 abbbc\n\n\n&#123;n&#125;\n匹配前面的元素恰好 n 次\na&#123;3&#125;b\n匹配 aaab（a 出现 3 次）\n\n\n&#123;n,&#125;\n匹配前面的元素至少 n 次\na&#123;2,&#125;b\n匹配 aab、aaab、aaaaab 等（a 至少出现 2 次）\n\n\n&#123;n,m&#125;\n匹配前面的元素至少 n 次，最多 m 次\na&#123;1,3&#125;b\n匹配 ab（a 1 次）、aab（a 2 次）、aaab（a 3 次），不匹配 aaaab（a 4 次）\n\n\n实践案例：量词匹配现有文本：\nacabcabbbcaaabaabaaaab\n\n\n匹配“a 后面跟 0 或多个 b，再跟 c”：\ngrep &#x27;ab*c&#x27; reg.txt\n\n\n解释：b 表示 b 出现 0 次或多次。\n效果：输出 ac、abc、abbbc。\n\n\n\n匹配“a 后面跟 1 到 3 个 b，再跟 c”（用扩展正则 grep -E 避免转义）：\ngrep -E &#x27;ab&#123;1,3&#125;c&#x27; test.txt\n\n\n解释：b&#123;1,3&#125; 表示 b 出现 1~3 次，-E 开启扩展正则（量词无需转义）。\n效果：输出 abc、abbbc，不输出 ac（b 0 次）、aaab（a 多了）。\n\n\n\n\n4、锚定符（位置匹配）锚定符不匹配具体字符，而是匹配“文本的位置”（如开头、结尾、单词边界）。\n\n\n\n锚定符\n含义\n示例\n匹配效果\n\n\n\n^\n匹配行的开头\n^abc\n匹配以 abc 开头的行\n\n\n$\n匹配行的结尾\nabc$\n匹配以 abc 结尾的行\n\n\n\\b\n匹配单词边界（单词与非单词的分隔处，如空格、标点、行首&#x2F;行尾）\n\\bthe\\b\n匹配独立的单词 the，不匹配 there 中的 the\n\n\n实践案例：锚定符匹配现有文本文件 lines.txt，内容：\nabc defdef abcabcdefThe cat and the hatThere is a cat\n\n\n匹配“以 abc 开头的行”：\ngrep &#x27;^abc&#x27; lines.txt\n\n\n解释：^ 锚定行开头。\n效果：输出第一行 abc def。\n\n \n\n匹配“独立单词 the”（忽略大小写，用 grep -Ei）：\ngrep -Ei &#x27;\\bthe\\b&#x27; lines.txt\n\n\n解释：\\b 锚定单词边界，-i 忽略大小写，确保 the 是独立单词。\n效果：输出 The cat and the hat 中的两个 the（The 首字母大写也会匹配）。\n\n\n\n\n5、分组与引用（() 和 \\n）\n()：将多个字符分组，作为一个“整体单元”参与匹配或量词约束。\n\\n：引用第 n 个分组的内容（n 为分组序号，从 1 开始）。\n\n实践案例：分组与引用现有文本 info.txt，内容：\nAlice:25:EngineerBob:30:Designer\n\n提取“姓名 + 职业”并重组为“职业: 姓名”，用 sed（流编辑器）演示：\nsed -r &#x27;s/([a-zA-Z]+):[0-9]+:([a-zA-Z]+)/\\2: \\1/&#x27; info.txt\n\n\n解释：\n\n([a-zA-Z]+)：第 1 组，匹配姓名（字母）。\n:[0-9]+:：匹配年龄部分（数字）。\n([a-zA-Z]+)：第 2 组，匹配职业（字母）。\n\\2: \\1：引用第 2 组（职业）和第 1 组（姓名），重组格式。\n\n\n效果：\nEngineer: AliceDesigner: Bob\n\n\n\n\n练习：\n手机号码的正则表达式：13开头，11位数\n^13[0-9]&#123;9&#125;grep &#x27;^13[0-9]&#123;9&#125;&#x27; reg.txt\n\n \n简单邮箱验证：\n[a-zA-Z0-9_]+@sc\\.\\comgrep -E &#x27;[a-zA-Z0-9_]+@sc\\.\\com&#x27; reg.txt\n\n \n6、常用工具中的正则6.1 grep：文本搜索\n基本用法：grep &#39;正则&#39; 文件名\n扩展正则：grep -E &#39;扩展正则&#39; 文件名（支持 +&#x2F;?&#x2F;&#123;&#125; 等，无需转义）\n忽略大小写：grep -i &#39;正则&#39; 文件名\n显示行号：grep -n &#39;正则&#39; 文件名\n\n6.2 sed：流编辑（前文案例已用）\n替换操作：sed -r &#39;s/原正则/新内容/g&#39; 文件名（g 表示全局替换）\n直接修改文件：sed -ri &#39;s/原正则/新内容/g&#39; 文件名（-i 直接修改源文件）\n\n6.3 awk：文本分析（简单示例）提取以 a 开头的行的第二个字段（假设字段用空格分隔）：\nawk &#x27;/^a/ &#123;print $2&#125;&#x27; test.txt\n\n\n解释：/^a/ 是正则，匹配以 a 开头的行；&#123;print $2&#125; 打印该行第二个字段。\n\n7、实战综合案例：日志分析现有 app.log，内容包含大量日志，需提取“ERROR 级别的日志，且包含用户 ID（格式 user[0-9]+）”。\n日志示例：\nINFO: 2023-10-01 ... normal taskERROR: 2023-10-02 ... user123 login failedWARN: 2023-10-03 ... timeoutERROR: 2023-10-04 ... user456 permission denied\n\n命令：\ngrep -E &#x27;ERROR.*user[0-9]+&#x27; app.log\n\n\n解释：\n\nERROR：匹配包含 ERROR 的行。\n.*：匹配 ERROR 后任意字符（直到遇到 user）。\nuser[0-9]+：匹配 user 后跟至少 1 个数字。\n\n\n效果：输出所有含“ERROR”且带“user+数字”的日志行：\nERROR: 2023-10-02 ... user123 login failedERROR: 2023-10-04 ... user456 permission denied\n\n \n[0-9] 可以用 \\d 表示\n二.硬盘管理第一章、认识电脑的组件​\t在将硬盘管理前，我们讲下电脑组件有哪些？各有什么作用？\n\n外设：就是安装在电脑主机箱外面的设备（显示器，鼠标，键盘，打印机，摄像头，音响，麦克风，耳机…）\n\n液晶显示屏：说白了，就是屏幕，作用就是显示内容，有屏幕大小之分（就是几寸屏幕的说法），分辨率（就是说的2K屏，4K屏之类的），还有刷新频率（就是屏幕宣传的Hz，对于某些打FPS游戏的玩家来说，这项很重要）、色域（对于搞设计、媒体等领域的人来说，这一项很重要，至少要及格）、响应速度、板面材质、可视角度之分\n\n鼠标：控制电脑光标的设备，现在常见的是光电鼠标，然后鼠标比较重要的是手感，然后是及格线以上的延迟\n\n键盘：输入内容至电脑用的控制设备，国内使用的键盘分布都是美式键盘分布，然后键盘分为薄膜键盘、机械键盘等，比较重要的参数也有延迟，及格就够用，如果这个是机械键盘则还需要看按键的触发行程、触发压力等\n\n打印机：将内容打印到纸张的设备，也可以用作扫描内容进电脑\n\n摄像头：视频输入设备，主要用于：实时监控、视频会议、远程医疗等领域\n\n音响：输出声音的设备，主要用于外放声音的\n\n麦克风：输入声源的设备，主要用于收录声音\n\n耳机：输出声音的设备，主要用于给个人使用，部分耳机还会带有小麦克风\n\n\n\n内设：就是安装在电脑主机箱内的设备(CPU，主板，内存，磁盘，电源，显卡，散热风扇，水冷，主机箱…)\n\nCPU（中央处理器）：电脑的重要组成之一，主要负责电脑的运算，可以理解成是电脑的“大脑”，部分CPU还会带有核显（核心显卡）用于处理图像功能，CPU的主要参数有：核心数、线程数（部分技术下1个物理核心可以模拟出2个线程数）、主频（每个周期可以处理的数据量）、架构、指令集、一级缓存（位于CPU内核旁边，用于存储当前处理的数据和对应要执行的指令，一般大小只有几十KB）、二级缓存（位于CPU和内存之间的临时存储器，用于给一缓和CPU提供即将使用的数据，一般大小只有几至几十MB）、三级缓存（用于读取二缓后未命中数据设计的，一般大小只有几十MB）、热功耗、最大支持的内存、插槽类型（类型很重要，如果和主板不对则安装不了CPU）等\n\n主板：电脑的重要组成之一，主要用于连接各个组件，可以理解成是电脑的“身躯”，其可以不要最好的，但是必须要及格，它是电脑里少数几个好不会增加性能，差会减少性能的组件，其主要参数有：主芯片组（支持什么CPU，及扩展能力是怎样的）、内存插槽数和内存插槽支持的内存版本、主板大小、供电模式、主板集成芯片（主要是集成网卡和声卡，分别影响电脑的网速和声音的质量）、CPU插槽类型（主要是要和CPU的插槽类型对应上）、扩展规格（可以插多少东西）等\n\n内存：电脑的重要组成之一，主要用于存储运行中的运算数据，包括但不限于当前正则执行的进程数据、下载数据时进行解密的数据，其内存特点就是断电数据清空，在台湾也被称之为“記憶體”，內存的主要数据有：内存版本类型（这个版本类型要和主板支持的内存版本一致）、内存主频、内存容量、CL延迟等\n\n磁盘：电脑的重要组成之一，主要用于存储程序数据的，包括操作系统，其存储是永久化的存储，不会因为断电而消失，主流的磁盘分为：机械硬盘和固态硬盘，其主要参数有：存储容量、接口类型、大小等；而机械硬盘额外有碟片数量、单碟容量、缓存、转速、接口速率等参数；固态硬盘有额外的读取速度、写入速度、4K随机读取速度、4K随机写入速度等参数\n\n电源：电脑的重要组成之一，笔记本电脑是电池加上电源适配器，其作用是将市电转化为电脑可以使用的电压电流及给电脑的所有组件供电，可以理解成是电脑的“心脏”，其在市面上又被分为非模组电源和模组电源，也就是电源输出线是固定好的还是可以根据需求更改的；电源的主要参数有：额定功率、电源转换效率（这个其实就是市面上电源说的金牌认证、铂金认证等这些认证）、尺寸大小、输出线接口的规格等\n\n显卡：电脑的内部组成之一，因为部分CPU不带核显或者核显很差或者核显跟不上你的需求，那么一般来说，会增加一张独立显卡，独立显卡由电源供电，通过主板上的插槽和系统交互数据，其作用是用于处理图形输出和处理大量简单的运算，在显卡内部最为核心的是GPU，一般来说显卡的GPU一样，那么性能相差不会特别多，其主要参数有：GPU芯片、核心频率、显存频率、显存容量、显存位宽、电源接口、散热方式、功率、尺寸大小\n\n散热风扇：作为电脑内部的散热组件，其分为两种：CPU散热和机箱散热，两边的风扇尺寸合适的话通用，但是两边的需求不一样，机箱散热只是作为辅助散热手段，主要是加强机箱内部与外部的气体交换速度，加强内部其它散热的效果，机箱散热因此主要看重风道构建和噪音问题，而非散热强度；CPU散热主要是缓解和释放CPU运行时持续产生的热量，因此CPU风扇更看重散热强度，当然也会适度考虑噪音问题，其主要参数有：风扇尺寸、噪音、最高转速、最大风量、风压等参数\n\n水冷：作为电脑内部的散热组件，其主要是作为CPU散热和显卡散热的，它通过导热效率高的金属将CPU的热量传导至流动的液体中，通过液体的比热容将热量带走，在后的设备中，会通过将液体在导热金属流动将液体的热量传导至金属，金属通过散热风扇将热量完全释放；但是在水冷的使用过程中，有着如下的优缺点：刚开始导热效率因为高比热容散热快，但是当长时间运行后，后续的散热部分无法完全带走液体中多余的热量，导致散热效率下滑，另一方面，因为水冷内部流动的液体导电，因此在部分特殊场景下因为漏液导致的一波“带走”也影响人们使用水冷的因素之一，其主要参数有：冷头尺寸、噪音、水冷排尺寸、风扇个数、最高转速、最大风量、风压等参数\n\n主机箱：作为电脑的保护壳子，其主要作用是提供电脑各种组件的固定位置、防尘和颜值，其主要参数有：机箱体积、适用的主板类型、支持的显卡极限长度、支持CPU散热器的极限高度、各种外置接口数量\n\n\n\n\n1. Linux 硬件文件的名称​\t我们都知道在 Linux 中，我们所有的硬件设备都会以文件的形式存在于 /dev 目录下。\n​\t这里我们了解下各种设备是以什么名字存储在 /dev 目录下的。\n\n\n\n硬件设备\n名称\n\n\n\nIDE接口设备\n/dev/hd[a-d] ，例如：/dev/hda 、/dev/hdb 、/dev/hdc 等\n\n\nSCSI&#x2F;SATA&#x2F;USB接口设备\n/dev/sd[a-p] ，例如：/dev/sda 、/dev/sdb 、/dev/sdc 等\n\n\n软盘\n/dev/fd[0-1]\n\n\n光盘\n/dev/cdrom 、/dev/sr0\n\n\n打印机\n/dev/lp[0-15]\n\n\n鼠标\n/dev/mouse\n\n\n终端\n/dev/tty*\n\n\n伪终端\n/dev/pts/[0-n]\n\n\n第二章. 硬盘分类硬盘如我们上面所说，分为两大类：机械硬盘和固态硬盘。\n1 机械硬盘的结构机械硬盘（Hard Disk Drive，简称HDD）是使用类似于以前的磁带、光盘这类技术制作的。它有着磁头、碟片、控制器这些核心组件组成，通过控制器控制磁头在高速转动的碟片上读取上面磁粉的磁极来获取获取数据，你可以认为两个磁极被分别使用0和1去表示，这样来表示我们数据的。然后写入数据时，由控制器控制磁头释放磁力将碟片上的磁粉的磁极修改，这就是写入数据。\n因此，它从结构和原理上有着以下优缺点：\n\n因为使用了机械结构，因此有噪音\n因为盘片和磁头的工作需要在高速转动下完成，因此不抗震，震动会导致盘片和磁头打到一起，刮花盘面，导致数据丢失\n同时高速转动的盘片和磁头因为工作需要以纳米为单位的精细操作，因此，灰尘会严重影响到正常工作，正常情况下，机械硬盘一般是半密封或者完全密封的。其中半密封的为空气盘，其需要和外界保持同一气压环境，因此带有空气过滤片；其中完全密封的为氦气盘，通过向完全密封的硬盘内填充氦气这种惰性气体以实现更小的空气阻力和更稳定的环境，同时因为更小的空气阻力，因此产生的热量也小，但是因为氦气无法完全密封，因此当硬盘内的氦气低于一个警戒线时，硬盘将会根据厂商设置的安全策略进入只读模式\n因为机械硬盘的读写机制依赖于对盘片上的磁极的读改，因此速度有明显的极限，大概在300MB&#x2F;s\n因为机械硬盘的技术成熟，而且厂家内卷（现在都开始摆烂了），因此单位价格相对而言便宜很多\n因为机械硬盘的存储技术方案，决定了每个机械硬盘，它能存储数据的上限都很大\n因为机械硬盘存储数据是依赖于盘片上磁粉的磁极，因此长期不使用并不会导致数据丢失，而且哪怕出现了问题，也可以通过剩余没问题部分的磁极恢复部分数据；同时，机械硬盘也有坏道这种东西，意思就是机械硬盘上有一段区域无法正确读取到数据\n\n因为我们磁盘是通过读取盘片上的磁粉来获取数据的，因此，我们读取到磁粉的量越多，那么读写速度就越快，而在恒速转动的碟片上，角速度都一致，那么半径越大，线速度（也就是磁头相对于磁盘的速度）也就越大，即：同一块机械硬盘的读写速度和其读写的位置也有关系，读写的位置越靠近外圈读写的速度越快。\n在机械硬盘上，我们为了方便管理，因此我们称呼在每个盘片的每一面上，以转动轴为轴心、以一定的密度为间隔的若干个同心圆为磁道（Track），然后以一定角度为划分，将同心圆划分为等数量的块称之为扇区（Sector），数据就按扇区存放在硬盘上。\n一个机械硬盘会有大于等于一个盘面，在每个盘面上都相应的有一个读&#x2F;写磁头（Head），所以不同的磁头的所有相同位置的磁道就构成了柱面（Cylinder）。传统的硬盘读写都是以柱面、磁头、扇区为寻址方式的（CHS寻址）。\n2 固态硬盘的结构​\t固态硬盘（Solid State Drive，简称SSD）是用能“囚禁”电子的颗粒芯片构成的硬盘，其有主控芯片、闪存颗粒和缓存单元组成。其中主控芯片是固态硬盘的大脑，负责了对数据分配在各个闪存芯片上的负荷和承担了整个数据的中转，因此它的发热量是在固态硬盘中最高的（不压的情况下动不动就稳定90+℃），而且不同品牌的主控之间的能力差距大，在数据处理能力、算法上，对闪存颗粒的读写控制会有非常大的不同，从而间接导致固态硬盘在性能上产生较大的差距；然后是闪存颗粒，也就是闪存单元，它是固态硬盘的核心组件，其定位是类似于机械硬盘里的盘片的，闪存（Flash Memory）本质上是一种长寿命的非易失性（指在断电情况下仍能保持所存储的数据）的存储器，其数据管理不是以字节位单位，而是以固定的区块作为单位，在固态硬盘中，NAND闪存被广泛使用；最后是缓存芯片，其是用于将要读写的内容提前提取到缓存以加快速度，和保护闪存颗粒的寿命。\n因此，它从结构和原理上有着以下优缺点：\n\n因为它是靠着“囚禁”电子存储数据的，而电子会逃逸，虽然有检验弥补电子的方案，但是要通电，因此在长期断电的场景下会数据丢失\n因为它全靠着主控去管理和记录数据，包括数据位置，因此当主控损坏时，所有数据的为位置就都不清楚，从而导致全部数据丢失（不知道数据在哪导致的丢失）\n因为它存储数据不是线性存储的，是东存一块西存一块的，只有主控知道在哪，然后这些数据是分布在多个闪存颗粒上的，因此，当闪存颗粒损坏时，数据不再完整，从而数据也是全部丢失\n因为它的制造技术问题，所以它的容量上限比机械硬盘小很多\n因为它的制造成本问题，所以它的单位价格相对而言贵很多\n因为它读写是靠着读取“囚禁”电子的数量来获取的，走的是电路，理论上是光速，实际上因为总总限制，速度只能在有缓存的前提下达到现在常见的7000MB&#x2F;s的读取速度，但是也是比机械硬盘快的多得多\n因为它没有机械结构，因此它的抗震能力很强、而且没有什么噪音\n\n第三章. 文件系统文件系统是指操作系统用于明确存储设备或分区上的文件的方法和数据结构，即在存储设备上组织文件的方法。就是文件是以怎样的形式存储在存储设备上的。\n操作系统中负责管理和存储文件信息的软件组织结构称之为文件管理系统，简称文件系统，但是和上述的用于组织文件在存储设备上存储的文件系统不是同一个东西。\n1.文件系统的类型​\t文件系统：简单来说就是收纳文件、数据的收纳规则，根据平台分为不同的类型：\n\nWindows 系统：\n\nFAT32 ：单个文件最大支持2GB\nNTFS ：Windows 平台最常用的，也是 Windows 系统专属的一种文件系统\nexFAT\n\n\n\nWindows 默认文件系统为 NTFS（支持权限&#x2F;加密）或 FAT32（兼容 U 盘）。\n\n\n\nLinux 系统：\n\next4 ：最大最实用的主流规则\n\n\nExt4 是 Linux 默认文件系统（如 Ubuntu、CentOS）。\n\n\n特点：\n(1)容量超大：单个文件最多能存16TB\n(2)带记账功能：有日志功能-每次存文件都会记录。(好处：突然断电&#x2F;系统崩溃，能够通过日志恢复文件，不容易丢失)\n(3)稳定又能装：主流Linux系统默认都用ext4当作主力收纳规则\n\n\next3 ：于2001年诞生，具有日志特性，单文件最大尺寸支持16GB - 2TB\n\next2 ：于1993年诞生，在2002-2003年是Linux发行版本的首选文件系统，于Linux内核6.9版本标记为已弃用，最大文件尺寸是16GB - 2TB\n\niso9660 ：这个是给光盘用的\n\nvfat\n\nhfs和hfsplus ：苹果mac电脑专属的收纳规则\n\n\n\n网络文件系统\n\nNFS ：全名 Network File System，类似于存在另一台服务器的云收纳器\n\n特点：\n(1)文件不是存在自己电脑的硬盘里，而是存在网络上的另一台电脑 (服务器)里(2)你通过网络，就能像用自己的硬盘一样，存取那台电脑里的文件\n\n\n\n\n\n第四章、查看硬盘使用情况1.查看磁盘空间使用情况我们可以通过 df 来查看磁盘空间的使用情况，它用于显示系统上的磁盘空间使用情况。\ndf  [选项...]  [文件路径...]\n\n其可以指定查询某个目录所在文件系统（分区）的使用情况，默认是查询所有文件系统。\n我们查看后，会显示文件系统的名称、块的数量（总容量）、使用的块的数量（已用空间）、剩余块的数量（可用空间）、使用量及挂载的位置这些信息。\n\n\n\n选项\n描述\n\n\n\n-a\n显示所有文件系统，包括虚拟文件系统\n\n\n-B 块的大小\n指定以特定块的大小显示磁盘空间信息\n\n\n-i\n显示 inode 的使用情况而非块的使用情况\n\n\n-l\n仅显示本地文件系统\n\n\n-k\n以KB为单位显示磁盘空间信息\n\n\n-h\n使用可读性高的单位显示输出结果\n\n\n示例：\ndf -h  # 以人类易读格式显示# 解释：输出中每一行对应一个分区，能看到/（根分区）、/boot等的容量和使用比例\n\n\n\n\n\n2.查看磁盘使用量我们可以使用 du 查询一个文件或者目录的磁盘使用量。\n它可以递归地遍历指定目录下的所有文件和子目录，并计算它们的磁盘使用量。\n它主要是用来快速了解文件和目录占用磁盘的情况，方便进行磁盘清理或者查找磁盘空间占用较大的文件。\ndu [选项...] [文件...]\n\n\n\n\n选项\n描述\n\n\n\n-a\n显示目录中个别文件的大小\n\n\n-b\n显示目录或者文件大小时，以byte为单位\n\n\n-c\n除了显示个别目录或者文件的大小外，还显示所有目录或文件的总和\n\n\n-D\n显示指定软链接的源文件的大小\n\n\n-h\n使用易读取的单位显示（1024进制）\n\n\n-H\n使用易读取的单位显示（1000进制）\n\n\n-k\n使用1024Byte为单位\n\n\n-m\n使用1MB为单位\n\n\n-l\n重复计算硬链接的文件\n\n\n-L  软链接文件路径\n实现指定软链接的源文件大小\n\n\n-s\n仅显示指定目录或者文件的总大小，而非其子目录的大小\n\n\n--exclude=目录或文件的路径\n跳过指定的目录或者文件\n\n\n--max-depth=层数\n限制递归的深度\n\n\n示例：查看目录占用（找大文件）\ndu -sh /var  # 查看/var目录总占用du -h --max-depth=1 /var  # 查看/var下一级目录的占用# 解释：-s是 “summary”（汇总），-h易读格式，--max-depth=1限制显示深度，方便定位大目录（如/var/log可能占用较多空间）\n\n\n\n3.查看设备结构\nlsblk：查看块设备（磁盘、分区）的树形结构。\n\nlsblk# 解释：输出以树形展示磁盘（如sda）和分区（如sda1、sda2）的关系，还能看到磁盘类型（SSD/HDD）、大小等信息。\n\n\n\n\n\n\n\n第五章、分区管理分区管理：把硬盘拆成“多个小区域”更灵活\n1、分区的作用​\t分区的作用有以下几点：\n\n实现空间配额的限制：给系统&#x2F;程序专门划分区域，防止单个程序“吃空”整个硬盘\n隔离系统和程序：系统文件和软件文件分开存储(例如，系统文件在A区，软件在B区)，就算软件出问题，也不容易影响系统的稳定性\n安装多个不同的操作系统：给多个系统各自一个区，就能在同一块硬盘上安装不同的操作系统\n\n2、分区的方式​\t我们的分区方式总共有2种：\n2.1 MBR（Master  Boot  Record，主引导记录）\n最大只支持4个主分区（经典的 C、D、E、F 盘分区就是这样来的）\n如果需要创建更多的分区，就需要创建扩展分区，然后在扩展分区中创建逻辑分区，最大支持15个分区\n最大只支持2TB的硬盘\n\n2.2  GPT（Global  Unique  ID  Partition  Table，全局唯一标识符分区表）\n每个分区都有一个自己的UUID，可以使用命令 blkid 进行查看\nsudo  blkid\n\n可以使用 parted 命令进行分区\n\n支持128个分区\n\n与MBR相比没有2TB的限制，单分区支持256TB\n\nGPT分区如果要安装系统，必须先创建一个 ESP 分区来存放 boot 引导程序的文件 *.efi\n\n\n\nMBR和GPT核心区别：\n\nMBR：\n分区表位置：第一个扇区（无备份）。\n兼容性：兼容所有 BIOS 系统。\n缺点：无冗余、分区数受限、容量受限。\n\n\nGPT：\n分区表位置：磁盘头尾各存一份（冗余）。\n优势：支持超大磁盘、更多分区、CRC校验。\n依赖：UEFI（或 BIOS + GPT-aware bootloader）\n\n\n\n\n2.3  主分区和逻辑分区\n主分区：就行[独立的小块菜地]，可以直接存储数据（例如，Windows的C盘，Linux的根目录/，格式化后都可以装系统、存文件），又能引导电脑启动。每块菜地之间相互独立，互不干扰\n逻辑分区：MBR模式下，主分区最多只能有4块，不够用时，需要先建立一个[扩展分区]，再在这个扩展分区里拆分多个逻辑分区，用来灵活存各类数据。\n\n3、创建 MBR 分区3.1 **查看当前磁盘 **lsblk操作完毕后，我们需要通过命令来查看当前系统连接的设备有哪些，这个命令是 lsblk（list block device）。\n\n3.2 添加硬盘添加硬盘之前查看硬盘：\n首先，创建分区就要有要创建分区的硬盘，所以我们去买硬盘先去虚拟机加硬盘。\n添加虚拟机硬盘步骤：\n\n打开对应虚拟机的设置菜单\n\n点击添加设备\n\n选择硬盘，点击下一步\n\n选择SCSI，点击下一步\n\n选择创建新的虚拟磁盘，然后点击下一步\n\n因为是练习，所以磁盘大小不要设置太大，3G足矣，点击下一步\n\n直接点击完成\n\n\n​\t\n\n\n\n\n在虚拟机中添加完硬盘，系统是无法自动识别的，所以需要让它识别，识别的方法有两种：\n\n重启系统\n\n使用命令，让系统自动扫描设备\necho &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan\n\n操作完毕后，查看当前系统连接的设备，命令 lsblk（list block device）。\n\n执行完毕后，会多出一个硬盘，硬盘的名字会按照硬件设备文件的名字依次命名，比如：你原本是到了 /dev/sdb 那么新增的硬盘设备就会被命名为 /dev/sdc 。\n3.2 磁盘分区现在识别到了硬盘，那么就要对这个硬盘进行分区了。\n所有的磁盘文件保存在 &#x2F;dev 目录下：\n\n使用命令 fdisk 进行分区：\nfdisk  [选项...]  [要操作的磁盘设备路径]\n\n首先，指定要操作的磁盘设备的路径，如：\nfdisk  /dev/sdb\n\n执行完毕后，\n\n可以看到，它提示输入 m 可以获取帮助。\n其常见内容操作如下：\n\n\n\n命令\n描述\n\n\n\nm\n获取帮助信息\n\n\nl\n列出所有已知的分区类型\n\n\np\n打印当前磁盘的分区表\n\n\nn\n为当前磁盘添加一个新分区\n\n\nd\n删除当前磁盘的一个分区\n\n\nw\n保存对磁盘的操作并执行退出\n\n\nq\n不执行对磁盘的操作，直接退出\n\n\n\n\n\n步骤解析：\n\n输入创建新分区的 n\n\n可以看到它有提示：分区类型有 p primary（主分区）、e extended（扩展分区），然后还提示了当前有0个主分区，0个扩展分区和4个可用分区的名额，默认是创建 p 主分区；同时，如果我们现在有扩展分区则还会有一个新的类型 l logical（逻辑分区），我们这里按照需求创建分区\n\n然后如果创建的是主分区，则会提示请选择你要创建的主分区序号，有剩下可用的分区序号，这里默认是可选的里面最小的\n\n选择完分区序号后，它会继续询问你这个分区的起始扇区在哪，默认是可用值里最小的\n\n输入完分区的起始扇区后，它最后会询问你这个分区到哪结束，你可以输入具体的扇区位置、也可以以+号开始输入你要往后增加多少扇区的量、&#x3D;&#x3D;也可以以+号开始以K、M、G结尾来指定你要设置多大的存储大小&#x3D;&#x3D;，同时这里默认是到最后一个扇区，这里按需求来\n\n到这里，一次分区的划分就结束了，但是这个分区划分没有写入磁盘做实质性的操作，因此，我们需要使用 w 来保存并退出\n\n\n\n\n注意：磁盘分区会导致磁盘上以前的数据（如果有）全部清空\n\n\n4、创建 GPT 分区首先，要添加硬盘，添加硬盘后，如果系统识别到了这个硬盘，那么就要对这个硬盘进行分区了。\n添加硬盘的流程和上面MBR的一样。\n分区我们使用命令 parted 进行分区。\nparted [选项...]  [存储设备 [要执行的命令... [命令的参数...]]]\n\n这个命令有两种执行方式，分别是交互式和非交互式。我们先掌握交互式的使用方法：\n4.1 parted 的交互式使用首先，指定要操作的磁盘设备的路径，如：\nparted  /dev/sdc\n\n执行完毕后：\n\n可以看到，它提示输入 help 可以获取帮助，展示支持的命令。\n其常见内容操作如下：\n\n\n\n操作\n描述\n\n\n\nmklabel 或者 mklabel 卷标\n用于创建新的磁盘卷标（分区表）\n\n\nmkpart 分区类型 [文件系统类型] 起始位置 结束位置\n起始位置可以写K、M、G的大小单位，也可以使用数字表示扇区位置，这里会取最合适的位置，比如：1 表示扇区开始的位置，-1 表示扇区最后的位置\n\n\n&#96;print [devices\nfree\n\n\nrm 分区编号\n删除指定分区编号的分区\n\n\nquit\n退出，也可以使用 q 退出\n\n\n\n\n\n步骤解析：\n(1)要创建GPT分区，首先要指明分区格式为GPT分区。\nmklabel gpt\n\n(2)然后才是指明分区的范围，这里指定分区范围，不像 fdisk 那边那样一直询问，而是一条 mkpart 命令搞定，同时命令执行完毕没有报错的情况下，是直接分区的，而不像 fdisk 一样是等到执行并退出时写入磁盘的。\nmkpart  primary  1  500Mmkpart primary 500M -1\n\n(3)然后划分完毕后，如果需要查看，则可以使用 print 打印当前情况，也可以使用缩写 p 打印。\n(4)分区完毕，使用 q 退出。\n\n查看结果：\n\n4.2 parted 的非交互式使用有的时候，我们可能并不期望使用交互式的方式操作。\n因此，它还有非交互式的操作方案。\nparted  -s  要操作的硬盘设备  动作\n\n选项，-s ，是指以脚本形式运行，不提示 y/n 。\n其中的 动作 是指我们在交互式下，在 parted 命令内的操作。\n现在使用脚本的形式完成上面交互式完成的操作：\n# 将挂载的1GB硬盘划分为两个500M的分区# 1. 查看设备lsblk# 2. 查看当前分区情况parted -s /dev/sdb p# 3. 设置分区表为GPT分区parted -s /dev/sdb mklabel gpt# 4. 划分分区parted -s /dev/sdb mkpart primary 1 500Mparted -s /dev/sdb mkpart primary 500M -1\n\n\n\n第六章、磁盘使用1.MBR 分区完整使用流程如果我们需要使用 MBR 分区的硬盘，其完整流程如下：\n\n检查要分区的设备\nlsblk\n\n对设备进行分区\nfdisk  设备文件的绝对路径\n\n格式化分区\n\n创建挂载点\n\n挂载并设置开机自动挂载\n\n\n2.GPT 分区完整使用流程​\t如果我们需要使用 GPT 分区的硬盘，其完整流程如下：\n\n检查要分区的设备\nlsblk\n\n设置分区表的类型\nparted  设备文件的绝对路径# 进入后执行以下代码mklabel gpt# 或者使用非交互式的方案parted -s 设备文件的绝对路径 mklabel gpt\n\n对设备进行分区\nparted  设备文件的绝对路径# 或者使用非交互式的方案parted -s 设备文件的绝对路径 动作\n\n格式化分区\n\n创建挂载点\n\n挂载并设置开机自动挂载\n\n\n3.格式化分区我们可以通过一个系列的格式化命令实现对分区的不同格式化处理，将其转换为不同的文件系统。\n# 格式化为 ext3 文件系统mkfs.ext3  分区文件的绝对路径# 格式化为 ext4 文件系统mkfs.ext4  分区文件的绝对路径# 格式化为 xfs 文件系统mkfs.xfs  分区文件的绝对路径\n\n\n\n4.挂载分区挂载分区首先要知道，在Linux当中不像Windows一样是分盘符的，因此，这些挂载的设备都是以目录的形式存在于文件管理系统当中。\n因此，我们挂载分区首先要决定其挂载到哪，并将目录创建出来，这个目录以后就是相当于这个分区了。\nmkdir  目录路径\n\n接下来我们使用挂载命令将分区挂载到这个目录上，挂载命令是 mount 。\nmount [选项...]  [要挂载的分区的绝对路径]  [要挂载到那个目录的绝对路径]\n\n一般来说挂载可以不加任何选项，只使用 要挂载的分区的绝对路径 、要挂载到那个目录的绝对路径 两个参数就行。\n如：要将 /dev/sdb1 挂载到 /root/backup/ 目录上，则可以执行以下命令：\nmount  /dev/sdb1  /root/backup/\n\n挂载完毕后，会在 lsblk 的分区信息后面显示挂载目录的绝对路径。\n但是我们这样挂载，仅在我们这一次系统的周期中有效，下次开机并不会挂载。\n5.开机自动挂载我们系统开机自动挂载是通过 /etc/fstab 文件实现的，里面指明了系统启动时，要挂载什么目录，如果这个文件出错，那么系统开机将不会挂载任何内容，包括但不限于系统根目录。\n​\t这个文件的格式如下：\n\n文件默认内容格式：\n/dev/mapper/  /centos-root/  ext4  defaults  0 0\n\n按照顺序，分别是：\n\n要挂载的分区的路径或者存储设备的UUID\n你要挂载到的位置\n要挂载设备或者分区的文件系统类型，其值可以是：ext3 、ext4 、xfs 、iso9660 、swap\n挂载时使用的参数，有些参数是特定文件系统才有的，常用参数有：\nauto ：在启动时或者输入了 mount -a 时才自动挂载\nnoauto ：只在你的命令下才被挂载\nexec ：允许执行此分区的二进制文件\nnoexec ：不允许执行此文件系统上的二进制文件\nro ：以只读模式挂载文件系统\nrw ：以读写模式挂载文件系统\nuser ：允许任意用户挂载此文件系统，若无显式定义，则隐式启用 noexec 、nosuid 、nodev 参数\nusers ：允许所有 users 组中的用户挂载文件系统\nnouser ：只允许被 root 挂载\nowner ：只允许被设备所有者挂载\nsync ：I&#x2F;O同步进行\nasync ：I&#x2F;O异步进行\ndev ：解析文件系统上的块特殊设备\nnodev ：不解析文件系统上的块特殊设备\nsuid ：允许 suid 操作和设置 suid 位，一般用于临时提权\nnosuid ：禁止 suid 操作和设置 suid 位\nnoatime ：不更新文件系统上的 inode 访问记录，可以提升性能\nnodiratime ：不更新文件系统上目录的 inode 访问记录，可以提升性能\nrelatime ：实时更新 inode 访问记录，只有在记录中的访问时间早于当前访问才会被更新\ndefaults ：使用文件系统的默认挂载参数，如：ext4 默认是 rw 、suid 、dev 、exec、auto 、nouser 、async\n\n\ndump 工具通过它决定何时作备份，0是不做，1是做\n决定要检查的文件系统的检测顺序，其值有0、1、2，0表示不会被检测\n\n\n​\t更改完毕后，强烈推荐使用 mount -a 进行挂载测试。\n​\tmount -a 会根据 /etc/fstab 进行挂载操作，如果文件有错，则挂载命令会报错。\n6.重新使用旧硬盘做分区挂载我们重新使用旧硬盘做分区挂载前，先要从 /etc/fstab 中移除这个硬盘。\n然后需要去解除挂载，使用 umount 命令就可以解除挂载。\numount 设备的绝对路径# 或者umount 挂载点的绝对路径umount /mnt/mydisk/\n\n然后后续内容就是我们重新分区、重新格式化等操作。\n\n7.实践案例将/dev/sdb1（MBR 分区）用于存储数据\n\n格式化分区：\nmkfs.ext4 /dev/sdb1# 解析：mkfs.ext4在/dev/sdb1上创建 ext4 文件系统（Linux 最常用的日志文件系统），执行后分区具备 “存储文件” 的能力\n\n \n\n临时挂载分区\nmkdir /mnt/mydisk        # 创建挂载点目录mount /dev/sdb1 /mnt/mydisk  # 将分区挂载到/mnt/mydisk，挂载完成后，mydisk目录就是sdb1分区df -h                # 查看挂载情况# 解析 ：mount将设备（/dev/sdb1）关联到目录（/mnt/mydisk），# 之后对/mnt/mydisk的操作就是对分区的操作；# df -h可验证挂载成功（能看到/dev/sdb1的挂载信息）。\n\n\n\n开机自动挂载\n# 步骤1：获取分区的UUID（更稳定，避免设备名变化）blkid /dev/sdb1# 步骤2：编辑/etc/fstab，添加一行（示例UUID需替换为实际值）UUID=xxx-xxx-xxx-xxx  /mnt/mydisk  ext4  defaults  0 0# 步骤3：验证配置并挂载所有分区mount -a# 解析：/etc/fstab是系统开机自动挂载的配置文件。# blkid获取分区唯一标识（UUID），避免磁盘顺序变化导致设备名（如/dev/sdb1变/dev/sdc1）失效；# defaults表示使用默认挂载选项（读写、自动挂载等）；mount -a让新配置立即生效（无需重启）\n\n\n\n\n4.验证分区使用\n\n5.卸载分区\n\n第七章、交换分区交换分区，SWAP，Linux 中用于“虚拟内存”的分区&#x2F;文件,其作用是在内存不足时，使用软件将硬盘空间模拟成内存去使用，用于弥补内存的不足。\n其在Windows上叫虚拟内存，在Linux上虚拟内存由交换分区实现。\n虚拟内存通常是物理内存的 1.5 ~ 2 倍。\n1.使用磁盘分区实现交换分区操作步骤：\n\n准备新的分区\n\n\n将其格式化为SWAP分区\nmkswap 分区文件的绝对路径mkswap /dev/sdb2\n\n\n\n激活交换分区\nswapon 分区文件的绝对路径swapon /dev/sdb2\n\n将挂载信息写入配置文件 /etc/fstab\n请参照文件原本带有的案例书写\n分区文件的绝对路径  swap  swap  defaults  0  0echo &quot;/dev/sdb2 swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab\n\n\n解析：第一列：分区设备第二、三列：文件系统和挂载类型(都是swap)第四列： defaults 表示默认挂载选项第五、六列：00 表示交换分区无需备份、开机检查\n\n\n执行挂载命令 mount -a\n\n\n\n6.查看验证\nlsblkswapon --showfree -h\n\n\n2、使用文件实现交换分区实现步骤：\n\n制作一个交换文件\n使用 dd 命令创建一个指定大小的文件。\ndd [选项...]\n\n这里所需的选项有：\n\n\n\n选项\n描述\n\n\n\nif=文件路径\n输入文件的文件路径，默认为标准输入流。用于指定源文件\n\n\nof=文件路径\n输出文件的文件路径，默认为标准输出流。用于指定目标文件\n\n\nibs=字节\n一次读入指定的字节数，即指定一个块大小为指定的字节数\n\n\nobs=字节\n一次输出指定的字节数，即指定一个块大小为指定的字节数\n\n\nbs=字节\n同时设置读入和输出的块大小为指定的字节数\n\n\ncbs=字节\n一次转换指定数量的字节，即指定转换缓冲区大小\n\n\nskip=块的数量\n从输入文件开头跳过指定的块的数量后才开始复制\n\n\nseek=块的数量\n从输出文件开头跳过指定的块的数量后才开始复制\n\n\ncount=块的数量\n仅复制指定的块的数量，块大小由 ibs 指定\n\n\n因此，我们可以通过以下命令来创建一个100MB的文件。\ndd  if=/dev/zero  of=/opt/tmp.swap  bs=1M  count=100\n\n\n\n\n将文件格式化为SWAP分区\nmkswap  /opt/tmp.swap# 为了安全和硬性要求，修改文件权限chmod 600 /opt/tmp.swap\n\n\n\n激活交换分区\nswapon /opt/tmp.swap\n\n写配置文件 /etc/fstab\n/opt/tmp.swap  swap  swap  defaults  0  0echo &quot;/opt/teo.swap swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab\n\n挂载 \nmount -a\n\n6.验证\nlsblkswapon --showfree -h\n\n\n3.卸载 swap 分区\n删除 /etc/fstab 配置文件中的挂载信息\nsed -i &#x27;$d&#x27; /etc/fstab #删除源文件中的最后一行\n\n\n\n设置 SWAP 分区或者 SWAP 文件无效\n这里我们使用 swapoff 来关闭交换分区\nswapoff /opt/tmp.swap\n\n删除 SWAP 分区或者文件\n# 删除交换分区parted -s 硬盘绝对路径 rm 待删除的交换分区的编号# 删除交换文件rm -f 交换文件的绝对路径rm -f /opt/tmp.swap\n\n\n注意：\n如果是分区(如，&#x2F;dev&#x2F;sdb2),需要使用 parted &#x2F; fdisk 删除分区\n\n\n\n\n6.4 实践案例创建并启用 Swap 分区\n\n用分区创建 Swap（假设新分区/dev/sdb2）\nmkswap /dev/sdb2    # 将分区格式化为Swap类型swapon /dev/sdb2    # 启用Swapfree -h             # 查看内存和Swap使用情况# 解释：mkswap设置 Swap 签名，swapon启用后，free -h能看到 Swap 空间从 0 变为配置的大小。\n\n用文件创建 Swap（临时测试）\ndd if=/dev/zero of=/swapfile bs=1M count=1024  # 创建1GB空文件chmod 600 /swapfile         # 限制权限（安全）mkswap /swapfile            # 格式化为Swapswapon /swapfile            # 启用# 解释：dd生成指定大小的空文件（bs=1M是块大小 1MB，count=1024是 1024 块，共 1GB）；chmod 600确保只有 root 能访问；后续步骤同分区版 Swap\n\n卸载 Swap\nswapoff /dev/sdb2    # 或 swapoff /swapfile# 解释：swapoff停止使用 Swap 分区 / 文件，执行后free -h中 Swap 会变为 0。\n\n6.小结​\t创建交换分区有两种方案：\n\n\n\n分区创建\n文件创建\n\n\n\n创建磁盘分区格式化为SWAP分区激活SWAP分区写入配置文件加载配置文件\n创建指定大小的文件格式化为SWAP分区激活SWAP分区写入配置文件加载配置文件\n\n\n第八章、文件系统的组成1.block（块）文件系统存储数据的最小单位，分为：512B、1K、2K、4K。\n\nblock文件存储的 “最小单位”，默认 4KB，文件内容按块分配。 \n\n问：在块为4K的情况下，我一个1B数据大小的文件占用多大磁盘空间；大小为3K的又占用多大磁盘空间；大小为5K的又占用多大磁盘空间？答案是：4K、4K、8K\n\n\n\n2.inode（索引节点）存储文件的元信息，比如：文件的创建者、创建时间、文件大小、文件对应的 block 号等，这种存储文件的元信息的区域叫做 inode ，也就是索引节点\n\ninode 存储文件的元数据（权限、所有者、大小、修改时间等），每个文件对应一个 Inode。 \n\n问：Linux系统无法创建新文件，检查发现磁盘还有空余、而且当前用户也有创建文件的权限，问，可能是什么原因？答：有可能是 `inode` 号用完了\n\n\ndata block（数据块）：存储文件的实际内容，inode 通过指针指向这些块。默认大小4kb\n\n3.superblock（超级块）超级块，用于存储文件系统的大小，空闲的 block 号以及 inode 数量等，要访问一个分区，首先要访问超级块。\n如果超级块出了问题，磁盘就无法访问。\n\n超级块 存储文件系统的整体信息（总块数、空闲块数、Inode 总数等），是文件系统的 “户口本”。 \n\n关系：系统通过 superblock 识别文件系统整体信息 → 通过 inode 找到文件元数据和数据块指针 → 最终从 data block 读取文件内容。\n4.实践案例\n查看文件的 Inode\nls -i file.txt  # 显示文件的Inode编号stat file.txt   # 显示文件的元数据（Inode存储的信息）# 解释：ls -i输出第一列是 Inode 号；# stat能看到更详细的元数据（如权限Access、修改时间Modify等）。\n\n\n\n模拟 Block 分配（通过创建大文件）\ndd if=/dev/zero of=bigfile bs=4K count=1000  # 创建4KB×1000=4MB文件du -h bigfile     # 查看文件占用空间（验证Block分配）# 解释：bigfile大小 4MB，按默认 4KB/Block，会占用约 1000 个 Block；du -h能看到文件实际占用的磁盘空间（Block 总数 ×Block 大小）。\n\n\n\n查看 Superblock 信息\ndumpe2fs /dev/sda1  # 假设/dev/sda1是ext4分区# 解释：dumpe2fs用于查看 ext 系列文件系统的详细信息，输出中会包含 Superblock 的内容（如 “Block count”“Inode count” 等）。\n\n第九章、链接文件链接文件分为硬链接和软连接（符号链接）。\n1.创建链接文件使用 ln 命令创建链接文件，其默认创建的是硬链接文件。\nln [选项...]  源文件路径  链接文件路径\n\n在创建过程中，源文件最好写绝对路径。\t\n其中常用选项为：\n\n\n\n选项\n描述\n\n\n\n-s\n创建软链接，而非硬链接\n\n\n2.硬链接硬链接你可以理解为给文件取别名。 与原文件共享Inode，相当于 “别名”，删除原文件不影响硬链接（只要有一个链接存在，文件就不会被真正删除），不支持跨分区。 \n\n给同一个 inode 号指定多个文件名\n任意删除一个文件名，只要还有其它文件名，文件都不会损坏\n可以对重要的文件数据备份，防止误删除\n不占用新的 inode 号、不占用新的空间\n不可用给目录创建\n不能跨文件系统（分区）创建\n\n创建硬链接：ln 文件 链接名称\n\n2.软链接软连接可以理解成类似于 Windows 下的快捷方式。 ，有自己的 Inode，存储原文件的路径，支持跨分区，原文件删除\n后软链接失效。 \n\n可以跨分区创建\n占用新的 inode 号，占用少量的磁盘空间\n删除原文件，软链接也会失效\n对文件和目录都有效\n\n创建软链接：ln -s 文件/目录名 路径\n \n \n4.实践案例\n创建硬链接\ntouch original.txtln original.txt hardlink.txtls -li original.txt hardlink.txt  # 查看Inode，两者应相同# 解释：ln默认创建硬链接，执行后两个文件 Inode 编号一致，修改其中一个，另一个也会变化。\n\n创建软链接\nln -s original.txt softlink.txtls -l softlink.txt  # 会显示“softlink.txt -&gt; original.txt”# 解释：ln -s创建软链接，ls -l能看到软链接指向原文件的路径；若删除original.txt，softlink.txt会变成 “断裂的链接”\n\n5.小结简述硬链接与软链接的核心区别。硬链接：\n\n使用 ln 命令创建链接文件，其默认创建的是硬链接文件。\n共享 inode，不跨文件系统，删除源文件不影响硬链接（inode 引用计数减 1）。\n\n软链接：\n\n使用 ln -s 命令创建\n独立 inode，存储路径，可跨文件系统，源文件删除后失效。\n\n第十章、RAID 磁盘阵列​\tRAID磁盘阵列是一种将多块磁盘按照指定方式组合起来使用的一套技术，从而获取到比单块磁盘更高的性能和安全性。\n​\t磁盘阵列的实现方式有几种：\n\n外接磁盘阵列：单独使用磁盘阵列卡去控制实现磁盘阵列，有着比集成RAID控制器更多、更细的功能\n内置的RAID：使用主板上集成的RAID控制器实现，性能也就是可用级别，不如外接磁盘阵列\n软RAID：使用软件模拟RAID\n\n​\t磁盘阵列有好几种组成方式，经典的有：\n\nRAID0\nRAID1\nRAID5\nRAID10\n\n1.RAID0你想想，现在你有两块硬盘，为了速度，你可以怎样设计存储方案来提升速度。\n\n那就是将数据分开写入到这些硬盘之中，这样，就可以将写入的压力分摊，来提高写入速度；而读取时，则是从多块硬盘分别读取数据，使得我们每块硬盘要读取的内容减少，使得我们读取的速度变快。\n因为将数据写入到了多块硬盘，因此当数据丢失时，一块丢失了就等于全部丢失了，带来的数据安全性的风险很大。\n总结：\n\nRAID0是专注于读写速率的方案，其可以提高读写性能\n可用空间：最小的磁盘空间 * 组RAID0的磁盘数量\n没有任何容错能力，甚至会比使用单盘带来更高的数据丢失风险\n最少需要两块硬盘\n\n\n规则：多块硬盘串联，数据被分成小块，写入多块硬盘\n优点：读写速度最快(多硬盘并行工作)\n缺点：无数据冗余，一块硬盘损坏，所有数据丢失\n\n2.RAID1你想想，现在你有两块硬盘，为了安全，你可以怎样设计存储方案来提升安全性，避免数据因为意外丢失。\n\n那就是将要写入数据同时写入到这两块硬盘，这两块硬盘写入相同的数据，这样，哪怕一块硬盘的数据丢失了，我也还有一块硬盘持有完全一样的数据，安全性得到了保障。这种方案也被称之镜像。\n​\t首先，写入数据时，因为要保证多块硬盘同时写入相同的数据，所以写入性能会略微变慢；而在读取数据时，因为这些硬盘的数据都一样，那么我就可以同时从多块硬盘上读取数据，来分摊压力，因此，读取速度会提升。\n总结：\n\nRAID1是专注于安全性的方案，其有容错能力，允许损坏一半的量（因为是镜像，还有一份完整的备份）\n基于其机制，读性能提升，写性能下降\n可用空间：最小的磁盘空间 * 组RAID1的磁盘数量 &#x2F; 2\n最少需要两块硬盘\n\n\n规则：两块硬盘镜像，同一份数据同时写入两块硬盘\n优点：数据冗余性强，一块硬盘损坏，另一块仍有完整数据\n缺点：容量利用率低（两块硬盘只能用1块的容量）\n\n3.RAID5现在，有了保障安全的RAID1，但是嫌它贵，空间利用率不高，于是基于奇偶校验的技术，实现了一种折中的方案。\n\n在这里，我们写入数据时，会将数据类似于RAID0一样存储在多块硬盘上，但是每次其中有1块硬盘不是写入我们要存储的数据，而是其它硬盘上写入数据的校验和。当硬盘出现损坏时，损坏量不大于1，那么我们就可以通过现有的其它数据，通过运算，计算出损失的数据，以此来保障数据的安全性。同时，考虑到写入数据时，需要记录校验和，当任何数据发生改变时都要改变校验和，存储校验和的硬盘就会有更多次的读写，损毁的更快，（将校验和放在一块硬盘是RAID3的方案），因此将校验和与数据打散来存放。\n​\t而当，RAID5损坏一块硬盘时，并不会影响使用，但是，其磁盘阵列的级别就会变得和RAID0一样了，数据不再安全，这就是磁盘阵列的降级。\n总结：\n\nRAID5是专注于安全性和成本的方案，其有容错能力，最高允许损坏1块硬盘\n基于其机制，读写性能提升\n可用空间：最小的磁盘空间 * （组RAID5的磁盘数量 - 1）\n最少需要三块硬盘\n\n\n规则：至少三块硬盘，数据分块存储+奇偶校验信息分散存于不同硬盘\n优点：&#x3D;&#x3D;兼顾性能和安全&#x3D;&#x3D;，允许一块磁盘损坏（可以通过奇偶校验恢复数据）\n缺点：写入性能略低（需要计算奇偶校验）\n\n4.RAID10虽然RAID5解决了我们成本和性能的均衡问题，但是，更看重安全性的场合并不会使用RAID5，尤其是当硬盘数量更多时；而RAID1却又牺牲了性能，虽然安全了，但是在安全的基础上付出了容量的代价，已经很心疼了，还要付出性能的代价，就有点过分了。因此，就有了在RAID1级别的安全性上增加性能的方案 —— 混合使用多个磁盘阵列方案。\n这里，我们比较经典的就是RAID1和RAID0的组合，RAID10。\n\n在这套方案下，数据首先会通过RAID0的方案拆分成多块，写入到多个硬盘中，但是这边的硬盘是使用通过RAID1的技术整合在一起的磁盘组，这样，速度上有基于RAID0的提升，在安全上又有基于RAID1的镜像备份。\n总结：\n\nRAID10，其有容错能力，最高允许损坏每组一半硬盘\n基于其机制，读写性能均提升\n可用空间：最小的磁盘空间 * 组RAID10的磁盘数量 &#x2F; 2\n最少需要四块硬盘\n\n\n规则：先做RAID1(镜像)，再把多个镜像做RAID0(条带)，至少需要四块硬盘(2组RAID1，再组成RAID0)\n优点：既有RAID0的高性能(多组并行读写)，又有RAID1的高冗余(每组镜像备份)\n缺点：成本高(需要很多硬盘，容量利用率50%)\n\n第十一章、逻辑卷管理 LVM逻辑卷管理LVM是一个磁盘系统工具，非常好用。传统分区使用固定大小分区，重新调整大小十分麻烦。\n但是LVM可以创建和管理“逻辑”卷，而不是直接使用物理硬盘。可以让管理员弹性管理逻辑卷的扩大缩小，操作简单，而不损坏已经存储的数据。可以随意将新的硬盘加入到LVM，以直接扩展已经存在的逻辑卷。LVM不需要重启就可以让内核知道分区的存在。\n1.层次结构\n首先是我们实际的硬盘，将它划分出分区，然后将分区（Partition）的系统识别码（System ID）改为Linux LVM的识别码后，再通过 pvcreate 命令转化为LVM最底层的物理卷（Physical Volume，PV）。\n然后将多个物理卷进行整合，就可以形成卷组（Volume Group，VG），在64位系统中，卷组基本没有大小限制，而32位系统中大小则和PE的大小有关。\n在卷组中，存在PE，即物理区块（Physical Extent，PE），它是LVM中的最小存储单元，类似于文件系统中的 block 。\n最后从卷组中划分出逻辑卷（Logical Volume，LV），其大小和 PE 的大小及数量有关，Size（LV）&#x3D;Count（PE）* Size（PE）。\n2.工作原理​\tLVM通过将底层的物理硬盘抽象封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取，而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。比如说我增加一个物理硬盘，这个时候上层的服务是感觉不到的，因为呈现给上层服务的是以逻辑卷的方式。\n3.LVM的优缺点​\t优点：\n\n可以在系统运行的状态下动态扩展文件系统的大小\n\n文件系统可以跨多个磁盘，文件系统的大小不受磁盘大小的限制\n\nLVM的存储空间可以通过新增磁盘的方式扩容\n缺点：\n\n从卷组中移除一个硬盘时，必须使用 vgreduce 命令·\n\n当卷组中有一个磁盘损坏了，那么整个卷组都会受到影响\n\n在磁盘的创建过程中增加了额外的步骤，所以数据存储性能会受到影响\n\n\n4.创建LVM\n创建物理卷 PV 前的准备工作\n首先对硬盘进行分区处理，这里我们分1个大区就可以了。然后，通过 fdisk 的 t 命令将磁盘分区的System ID 改为Linux LVM的识别码，这个识别码的代号数字可以通过 l 查看 ，将文件系统的类型更改为 Linux LVM 。\n\n\nlsblkfdisk /dev/sdct31w \n\n \n \n  \n\n创建物理卷 PV\n我们使用命令 pvcreate 创建物理卷。\npvcreate 要转化为PV的磁盘分区路径pvcreate /dev/sdc1\n\n\n这里我们除了创建用的命令外，还有其它命令。\n首先是显示当前PV相关信息的 pvscan 。\npvscan  [选项...]\n\n\n\n然后是显示详细的PV信息的 pvdisplay 。\npvdisplay [选项...] [要查询的PV卷]pvdisplay /dev/sdc1\n\n \n\n创建卷组 VG\n\n我们使用 vgcreate 可以创建卷组 VG。\nvgcreate [选项...]  VG卷组的名称  PV的名称\n\n\n\n\n选项\n描述\n\n\n\n-s PE大小\n设置VG卷组的PE大小，单位可以是 m 、g 、t\n\n\n然后，这里我们除了创建用的命令外，还有其它命令。\n首先是显示当前VG相关信息的 vgscan 。\nvgscan\n\n\n\n然后是显示详细的VG信息的 vgdisplay 。\nvgdisplay\n\n\n\n增删改操作\n\n再准备一个 pv 卷\nfdisk /dev/sdct231wpvcreate /dev/sdc2 #再准备一个pv卷\n\n\n然后是增加VG内的PV的命令 vgextend。\nvgextend  VG名称   PV名称vgextend tmp /dev/sdc2 #添加pv到vg卷组vgdisplay tmp #查看当前卷组\n\n\n与之对应的删除VG内指定PV的命令 vgreduce。\nvgreduce  VG名称  PV名称vgreduce tmp /dev/sdc2 #将PV从VG卷组中移除\n\n修改VG卷组的属性信息的命令 vgchange。\n 核心作用是 激活&#x2F;停用 卷组 和 调整 pe 大小\nvgchange [选项...] # 激活 卷组vgchange -a y tmp # -a （active） 为 yes （默认是激活状态）# 示例：修改 PE的大小vgchange -s 8m tmp # -s 选项表示 size\n\n \n删除VG卷组的命令 vgremove。\nvgremove  VG名称\n\n\n\n\n创建逻辑卷 LV\n\n我们接下来就是LVM的最后一步，创建逻辑卷，我们可以使用 lvcreate 来创建逻辑卷。\nlvcreate [选项...]  VG名称lvcreate -L &quot;300m&quot; -n &quot;swap&quot; tmp\n\n\n\n\n常用选项\n描述\n\n\n\n-L  LV的大小\n指定逻辑卷的大小，单位可以是 m ，g ，t\n\n\n-l PE的个数\n指定逻辑卷的物理区块的数量，从而间接指定逻辑卷的大小\n\n\n-n 逻辑卷的名称\n指定逻辑卷的名称\n\n\n然后，这里我们除了创建用的命令外，还有其它命令。\n首先是显示当前LV相关信息的 lvscan 。\nlvscan\n\n\n\n然后是显示详细的LV信息的 lvdisplay 。\nlvdisplay\n\n\n\n对LV逻辑卷进行文件系统的格式化\nmkswap lv逻辑卷\n\n挂载:swapon\nmkswap /dev/tmp/swap #格式化swapon /dev/tmp/swap #挂载lsblk /dev/tmp/swap #查看\n\n\n\n\n5.扩容逻辑卷\n我们在扩展逻辑卷之前要先确认VG是否存在多余的容量，如果不存在容量则在扩展VG之前无法扩容\n \n\n使用逻辑卷大小调整命令 lvextend 或 lvresize 将逻辑卷扩容\nlvextend [选项...] LV名称lvresize [选项...] LV名称lvextend -L +1.5G /dev/tmp/swap #扩容1.5G\n\n\n\n\n选项\n描述\n\n\n\n-L 大小\n扩展大小到指定大小，单位支持  m 、g 、t另外你也可以在大小前面加上加号表示增加多少容量\n\n\n\n到这里，我们逻辑卷的尺寸已经扩容完毕，但是，我们文件系统的尺寸并没有跟随发生变化\nlvextend -L +1.5G /dev/tmp/swap #扩容1.5Glvdisplaydf -h /dev/tmp/swap #查看文件系统swapoff /dev/tmp/swap #停用分区mkswap /dev/tmp/swap #重新格式化分区swapon /dev/tmp/swap #激活分区\n\n\n​        \n\n6.缩容逻辑卷缩容逻辑卷在处理上比扩容逻辑卷简单，但是更容易丢失数据，因此强烈推荐先备份再缩容\n文件系统正确缩容完毕后，才是缩容逻辑卷，缩容逻辑卷可以使用 lvreduce 或 lvresize 实现\nlvreduce [选项...] LV名称lvresize [选项...] LV名称\n\n\n\n\n选项\n描述\n\n\n\n-L 大小\n缩小大小到指定大小，单位支持  m 、g 、t另外你也可以在大小前面加上减号表示缩小多少容量\n\n\nxfs 文件系统操作步骤：\n\n解除挂载状态: \nswapoff /dev/tmp/swap\n\n直接缩容\nlvreduce -L -1G /dev/tmp/swap \n\n \n\n重新挂载\nmkswap /dev/tmp/swap #重新格式化swapon /dev/tmp/swap #重新挂载\n\n\n\n\n如果是 ext4 文件系统的数据卷，操作步骤如下：\n\n卸载挂载\n检查文件系统的完整性\n\ne2fsck -f 逻辑卷的绝对路径\n\n\n将文件系统缩容\nresize2fs 逻辑卷的绝对路径 新的尺寸\n\n缩容完毕后，恢复挂载就好了\n\n\n7.删除逻辑卷\n确认卷上没有任何有价值的数据\n\n从系统上解除挂载（包括配置文件中对应的配置信息）\n\n使用命令 lvremove 移除逻辑卷\nlvremove  逻辑卷的路径/名称\n\n8.扩展卷组\n当卷组没有剩余空间，但是还是需要空间时，我们可以添加新的物理卷，并将物理卷添加到卷组中，实现对卷组的扩容。因此，首先，我们要找到用于扩容的物理卷。\n\n将物理卷通过 vgextend 命令进行扩容：\nvgextend  VG名称   PV名称\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"博客架构全景 (One-Page Cheatsheet)","url":"/2025/09/19/%E5%8D%9A%E5%AE%A2%E6%9E%B6%E6%9E%84/","content":"📜 博客架构全景图 (One-Page Cheatsheet)  \n❶ 核心概念：域名 ≠ 服务器  \n+ 域名 = 门牌号（告诉世界去哪找你）  + 服务器 = 房子（真正储存内容的地方）  ! GitHub Pages 就是你的“免费房东”  \n\n❷ 技术栈分工  \n\n\n\n模块\n工具\n作用\n\n\n\n域名\n阿里云注册\n你的专属门牌 (yourdomain.com)\n\n\n解析\n阿里云 DNS\n翻译门牌→GitHub 地址📍\n\n\n服务器\nGitHub Pages\n托管 HTML&#x2F;CSS&#x2F;JS 的免费房子\n\n\n博客生成\nHexo (本地)\n装修队：Markdown → 静态网页🏗️\n\n\n部署\ngit push\n把装修成果快递到 GitHub 🚚\n\n\n❸ 关键设置：CNAME 解析的意义  \n# 阿里云操作：添加CNAME记录  主机记录：@ 或 www  记录值：yourname.github.io  ↓  当访问 yourdomain.com 时：  1. DNS 指向 GitHub 服务器集群  2. GitHub 检查仓库内 `CNAME` 文件确认身份✅  3. 返回你的博客内容  ✨ 优势：GitHub 换 IP 你无需干预 | 比 A 记录更稳定  \n\n❹ 速度提升的秘诀  \n1. 🚀 阿里云 DNS 国内 Anycast 节点 → 首次查询省 30-80ms  2. 🗼 GitHub Pages 背后是 Fastly CDN → 覆盖京/沪/穗/港节点  3. 📦 静态文件缓存到边缘节点 → 90% 请求无需越洋  4. 💡（进阶）套阿里云 CDN → RTT 压至 20-40ms  \n\n❺ DNS 本质揭秘  \n\n🌐 互联网的分布式电话簿核心任务：域名 ⇄ IP 的双向翻译分层查询流程：浏览器缓存 → 运营商DNS → 根服务器 → .com服务器 → 阿里云DNS⏱️ 毫秒级完成 · 全球协作  \n\n\n✅ 终极一句话串讲  \n\n“你用阿里云买门牌，GitHub 免费提供房子，Hexo 在本地装修，DNS 瞬间翻译门牌地址，Fastly CDN 加速配送——这套组合拳让 yourdomain.com 又快又稳地打开你的博客。”\n\n\n🛠️ 未来升级指南  \n\n\n\n变更需求\n需改动模块\n\n\n\n换域名 (如切到腾讯云)\n阿里云域名 + DNS 解析设置\n\n\n换托管 (如切到 Vercel)\nDNS 解析指向新服务商\n\n\n换生成器 (如切到 Hugo)\n本地 Hexo → Hugo 流程\n\n\n加速优化\n接入 CDN（阿里云&#x2F;Cloudflare）\n\n\n","tags":["Blog","Hexo","GitHub Pages","DNS"]}]